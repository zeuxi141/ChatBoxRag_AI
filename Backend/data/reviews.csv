review_ID,Review,Metadata
1,"Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          1                                         tenshi3003@gmail.com  Lời nói đầu   Lập trình c ấu trúc l à phương pháp t ổ chức, phân chia ch ương tr ình thành các hàm, th ủ tục, chúng  được dùng đ ể xử lý dữ liệu nh ưng l ại tách rời các cấu trúc dữ liệu.",LTHDT_PhamVanAt.pdf - Sentence 1
2,"Thông qua các ngôn ngữ Foxpro,  Pascal, C đa s ố những ng ười làm Tin h ọc đã khá qu en bi ết với ph ương pháp l ập trình này.",LTHDT_PhamVanAt.pdf - Sentence 2
3,Lập tr ình h ướng đối t ượng dựa tr ên vi ệc tổ chức ch ương tr ình thành các l ớp.,LTHDT_PhamVanAt.pdf - Sentence 3
4,"Khác với h àm và  thủ tục, lớp l à một đơn vị bao gồm cả dữ liệu v à các phương th ức xử lý.",LTHDT_PhamVanAt.pdf - Sentence 4
5,"V ì vậy lớp có thể mô tả các  thực thể một cách chân th ực, đầy đủ cả phần dữ liệu v à yêu c ầu quản lý.",LTHDT_PhamVanAt.pdf - Sentence 5
6,"T ư tưởng lập tr ình h ướng  đối tượng đ ược áp dụng cho hầu hết các ngôn ngữ mới chạy tr ên môi trư ờng Windows nh ư  Microsoft Access, Visual Basic, Visual C.",LTHDT_PhamVanAt.pdf - Sentence 6
7,"Vì v ậy việc nghi ên cứu ph ương pháp l ập trình m ới này là  rất cần thiết đối với tất cả những ng ười quan tâm, y êu thích Tin h ọc.",LTHDT_PhamVanAt.pdf - Sentence 7
8,C ra đ ời năm 1973 với mục đích ban đầu l à để viết hệ điều h ành Unix trên máy tính mini PDP.,LTHDT_PhamVanAt.pdf - Sentence 8
9,Sau đó C đ ã được sử dụng rộng r ãi trên nhi ều loại máy tính khác nhau v à đã trở thành m ột ngôn  ngữ lập tr ình c ấu trúc rất đ ược ưa chu ộng.,LTHDT_PhamVanAt.pdf - Sentence 9
10,"Để đưa C vào th ế giới h ướng h ướng đối t ượng, năm 1980 nh à khoa h ọc ng ười Mỹ B.",LTHDT_PhamVanAt.pdf - Sentence 10
11,"Stroustrup  đã cho ra đời một ngôn ngữ C mới có t ên ban đ ầu là “C có l ớp”, sau đó đến năm 1983 th ì gọi là  C++.",LTHDT_PhamVanAt.pdf - Sentence 11
12,Ngôn ng ữ C++ l à một sự p hát tri ển mạnh mẽ của C.,LTHDT_PhamVanAt.pdf - Sentence 12
13,"Trong C++ chẳng những đ ưa vào t ất cả  các khái ni ệm, công cụ của lập tr ình h ướng đối t ượng m à còn đưa vào nhi ều khả năng mới mẻ cho  hàm.",LTHDT_PhamVanAt.pdf - Sentence 13
14,Như v ậy C++ l à một ngôn ngữ lai cho phép tổ chức ch ương tr ình theo các l ớp và các hàm.,LTHDT_PhamVanAt.pdf - Sentence 14
15,Có  thể nói C++ đ ã thúc đẩy ngôn ngữ C vốn đ ã rất thuyết phục đi v ào th ế giới lập tr ình h ướng đối  tượng v à C++ đ ã trở thành ngôn ng ữ hướng đối t ượng nổi bật trong những năm 90.,LTHDT_PhamVanAt.pdf - Sentence 15
16,"Cuốn sách n ày sẽ trình b ầy một cách hệ thống các khái niệm của lập tr ình h ướng đối t ượng được  cài đ ặt trong C++ nh ư lớp, đối t ượng, sự thừa kế, tính t ương ứng bội v à các kh ả năng mới trong xây  dựng, sử dụng h àm như: đ ối tham chiếu, đối mặc định, h àm trùng tên, hàm toán t ử.",LTHDT_PhamVanAt.pdf - Sentence 16
17,Có một số vấn  đề còn ít được biết đến nh ư cách xây d ựng h àm v ới số đối  bất định trong C cũng sẽ đ ược giới thiệu.,LTHDT_PhamVanAt.pdf - Sentence 17
18,"Các chương t ừ 1 đến 10 với cách giải thích tỉ mỉ v à với gần 100 ch ương tr ình minh ho ạ sẽ cung cấp  cho b ạn đọc các khái niệm, ph ương pháp và kinh nghi ệm lập tr ình h ướng đối t ượng tr ên C++.",LTHDT_PhamVanAt.pdf - Sentence 18
19,"M ục  lục cuối sách sẽ hệ t hống ngắn gọn ph ương pháp phân tích, thi ết kế v à lập tr ình h ướng đối t ượng  trên bình di ện chung.",LTHDT_PhamVanAt.pdf - Sentence 19
20,"Cuốn sách gồm 10 ch ương và 6 ph ụ lục   Chương 1  hướng dẫn cách l àm vi ệc với phần mềm TC++ 3.0 để thử nghiệm các ch ương tr ình,  trình b ầy sơ lược về các ph ương phá p lập trình và gi ới thiệu một số mở rộng đ ơn gi ản của C++ .",LTHDT_PhamVanAt.pdf - Sentence 20
21,"Chương 2  trình b ầy các khả năng mới trong việc xây dựng v à sử dụng h àm trong C++ như bi ến  tham chi ếu, đối có kiểu tham chiếu, đối có giá trị mặc định,  h àm tr ực tuyến, h àm trùng tên, hàm  toán t ử.",LTHDT_PhamVanAt.pdf - Sentence 21
22,"Chương 3  nói v ề một khái niệm trung tâm của lập tr ình h ướng đối t ượng l à lớp gồm: Định nghĩa  lớp, khai báo các biến, mảng đối t ượng (kiểu lớp), ph ương th ức, d ùng con tr ỏ this trong ph ương  thức, phạm vi truy xuất của các th ành ph ần, các ph ương th ức toán tử.",LTHDT_PhamVanAt.pdf - Sentence 22
23,"Chương 4  trình b ầy các vấn đề tạo dựng, sao chép, huỷ bỏ các đối t ượng v à các v ấn đề khác có  liên quan như: Hàm t ạo, h àm tạo sao chép, h àm hu ỷ, toán tử gán, cấp phát bộ nhớ cho đối t ượng,  hàm b ạn, lớp bạn.",LTHDT_PhamVanAt.pdf - Sentence 23
24,"Chương 5  trình b ầy một khái niệm quan trọng tạo nên kh ả năng mạnh của lập tr ình h ướng đối  tượng trong việc phát triển, mở rộng phần mềm, đó l à khả năng thừa kế của các lớp.",LTHDT_PhamVanAt.pdf - Sentence 24
25,"Chương 6  trình b ầy một khái niệm quan trọng khác cho phép xử lý các vấn đề khác nhau, các  thực thể khác nhau, các thuật toán khác n hau theo cùng m ột lược đồ thống nhất, đó l à tính tương  ứng bội v à phương th ức ảo.",LTHDT_PhamVanAt.pdf - Sentence 25
26,Các công cụ n ày cho phép d ễ dàng t ổ chức ch ương tr ình qu ản lý nhiều  dạng đối t ượng khác nhau.,LTHDT_PhamVanAt.pdf - Sentence 26
27,Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          2                                         tenshi3003@gmail.com  Chương 7  nói v ề việc tổ chức v ào - ra trong C++.,LTHDT_PhamVanAt.pdf - Sentence 27
28,C++ đưa vào m ột khái niệm mới g ọi là các  dòng tin (Stream).,LTHDT_PhamVanAt.pdf - Sentence 28
29,"Các thao tác vào - ra sẽ thực hiện trao đổi dữ liệu giữa bộ nhớ với d òng tin: Vào  là chuy ển dữ liệu từ d òng nh ập vào bộ nhớ, ra l à chuy ển dữ liệu từ bộ nhớ l ên dòng xu ất.",LTHDT_PhamVanAt.pdf - Sentence 29
30,"Để nhập  xuất dữ liệu tr ên m ột thiết bị cụ thể n ào, ta ch ỉ cần gắn d òng nh ập xuất với thiết bị đó.",LTHDT_PhamVanAt.pdf - Sentence 30
31,Việc tổ chức  vào ra theo cách như v ậy là rất khoa học v à tiện lợi v ì nó có tính độc lập thiết bị.,LTHDT_PhamVanAt.pdf - Sentence 31
32,Chương 8  trình b ầy các h àm đ ồ hoạ sử dụng trong C v à C++.,LTHDT_PhamVanAt.pdf - Sentence 32
33,Các hàm này đư ợc sử dụng rải rác  trong toàn b ộ cuốn sách đ ể xây dựng các đối t ượng đồ hoạ.,LTHDT_PhamVanAt.pdf - Sentence 33
34,"Chương 9  trình b ầy các h àm truy xu ất trực tiếp v ào bộ nhớ của máy tính, trong đó có bộ nhớ  màn hình.",LTHDT_PhamVanAt.pdf - Sentence 34
35,Các hàm này s ẽ được sử dụng trong ch ương 10 đ ể xây dựng các lớp menu v à cửa sổ .,LTHDT_PhamVanAt.pdf - Sentence 35
36,Chương 10  giới thiệu 5 ch ương tr ình tương  đối ho àn ch ỉnh nhằm minh hoạ th êm kh ả năng v à kỹ  thuật lập tr ình h ướng đối t ượng tr ên C++   Phụ lục 1 trình b ầy các phép toán trong C++ v à thứ tự ưu của chúng.,LTHDT_PhamVanAt.pdf - Sentence 36
37,Phụ lục 2  liệt kê một danh sách các từ khoá của C++.,LTHDT_PhamVanAt.pdf - Sentence 37
38,Phụ lục 3  trình b ầy bảng m ã ASCII và mã quét  của các ký tự.,LTHDT_PhamVanAt.pdf - Sentence 38
39,"Phụ lục 4  trình b ầy một vấn đề quan trọng nh ưng c òn ít được nói đến trong các t ài liệu, đó l à  cách s ử dụng con trỏ void để xây dựng các h àm v ới số đối không cố định giống nh ư các hàm printf  và scanf c ủa C.",LTHDT_PhamVanAt.pdf - Sentence 39
40,"Vì trong C++ v ẫn sử dụng các h àm c ủa C, n ên trong phụ lục 5  sẽ giới thiệu tóm tắt h ơn 200 hàm  để  bạn đọc tiện việc tra cứu.",LTHDT_PhamVanAt.pdf - Sentence 40
41,"Cuối cùng, phụ lục 6  trình b ầy một cách ngắn gọn ph ương pháp phân tích, thi ết kế v à lập trình  hướng đối t ượng tr ên bình di ện chung.",LTHDT_PhamVanAt.pdf - Sentence 41
42,"Khi vi ết chúng tôi đ ã hết sức cố  gắng để cuốn sách đ ược ho àn ch ỉnh, song chắc chắn không tránh  khỏi thiếu sót, v ì vậy rất mong nhận đ ược sự góp ý của độc giả.",LTHDT_PhamVanAt.pdf - Sentence 42
43,Nhân d ịp này chúng tôi xin chân thành cám ơn c ử nhân Nguyễn Văn Phác đ ã tận tình giúp đỡ  trong vi ệc hiệu đính v à biên t ập cuốn sá ch này.,LTHDT_PhamVanAt.pdf - Sentence 43
44,Tác gi ả       Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          3                                         tenshi3003@gmail.com  Chương 1   C++ và l ập trình  hướng đối t ượng  Trong chương này trình  bầy các vấn đề sau:   -  Cách s ử dụng phần mềm TC++ 3.0   - Những sửa đổi cần thiết  một ch ương trình  C để biến nó th ành m ột ch ương trình  C++ (ch ạy  được trong môi tr ường C++)   - Tóm lư ợc về các ph ương pháp l ập trình  cấu trúc và lập trình  hướng đối t ượng  - Những mở rộng của C++ so với C   Bài 1.,LTHDT_PhamVanAt.pdf - Sentence 44
45,Làm vi ệc với TC++ 3.0   Các ví d ụ trong cuốn sách n ày sẽ viết v à thực hiện tr ên môi trư ờng TC++ 3.0.,LTHDT_PhamVanAt.pdf - Sentence 45
46,Bộ c ài đặt TC++  3.0 g ồm 5 đĩa.,LTHDT_PhamVanAt.pdf - Sentence 46
47,"Sau khi c ài đặt (giả sử v ào thư m ục C: \TC) thì trong thư m ục TC sẽ gồm các th ư  mục con sau:   C:\TC\BGI  ch ứa các tệp đuôi BGI v à CHR   C:\TC\BIN ch ứa các tệp ch ương trình  (đuôi EXE) như TC, TCC, TLIB, TLINK   C:\TC\INCLUDE ch ứa các tệp ti êu đề đuôi H   C:\TC\LIB  ch ứa các tệp đuôi LIB, OBJ   Để vào môi trư ờng của TC++ chỉ cần thực hiện tệp ch ương trình  TC trong thư m ục C: \TC\BIN .",LTHDT_PhamVanAt.pdf - Sentence 47
48,Kết quả nhận đ ược hệ menu chính của TC++ với mầu nền xanh gần giống nh ư hệ menu quen thuộc  của TC (Turbo C).,LTHDT_PhamVanAt.pdf - Sentence 48
49,"Hệ menu của TC++ gồm các menu: File, Edit, Search, Run, Compile, Debug,  Project, Options, Window, Help.",LTHDT_PhamVanAt.pdf - Sentence 49
50,"Cách so ạn thảo, bi ên dịch v à chạy ch ương trình  trong TC++ cũngg giống nh ư trong TC, ngo ại  trừ điểm sau: Tệp ch ương trình  trong h ệ soạn thảo của TC++ có đuôi m ặc định l à CPP cũng trong  TC thì tệp ch ương trình  luôn có đuôi C.",LTHDT_PhamVanAt.pdf - Sentence 50
51,Trong TC++ có th ể thực hiện cả ch ương trình  C và C++.,LTHDT_PhamVanAt.pdf - Sentence 51
52,"Đ ể thực hiện ch ương trình  C cần dựng  đuôi C đ ể đặt t ên cho t ệp ch ương trình , để thực hiện ch ương trình  C++ c ần dựng đuôi CPP để đặt  tên cho t ệp ch ương trình .",LTHDT_PhamVanAt.pdf - Sentence 52
53,Bài 2.,LTHDT_PhamVanAt.pdf - Sentence 53
54,C và C++   - Có th ể nói  C++ là s ự mở rộng (đáng kể) của C.,LTHDT_PhamVanAt.pdf - Sentence 54
55,"Điều đó có nghĩa l à mọi khả năng, mọi khái  niệm trong C đều d ùng đư ợc trong C++.",LTHDT_PhamVanAt.pdf - Sentence 55
56,"- Vì trong C++ s ử dụng gần nh ư toàn b ộ các khái niệm, định nghĩa, các kiểu dữ liệu, các cấu trúc  lệnh, các h àm và các công c ụ khác của C, nên yêu c ầu bắt buộc đối với các đọc giả C++ l à phải biết  sử dụng t ương đ ối thành th ạo ngôn ngữ C.",LTHDT_PhamVanAt.pdf - Sentence 56
57,"- Vì C++ là s ự mở rộng của C, nên bản thân một ch ương trình  C đó là chương trình  C++ (ch ỉ cần  thay đuôi C b ằng đuôi CPP).",LTHDT_PhamVanAt.pdf - Sentence 57
58,"Tuy nhi ên Trình  biên dịch TC++ yêu cầu mọi h àm chu ẩn dùng trong  chương trình  đều phải khai báo nguy ên m ẫu bằng một câu lệnh #include, trong khi điều n ày không  bắt buộc đối với Trình  biên dịch của TC.",LTHDT_PhamVanAt.pdf - Sentence 58
59,Trong C có th ể dùng m ột hàm chu ẩn m à bỏ qua câu lệnh #include để khai báo nguy ên m ẫu của  hàm đư ợc dùng.,LTHDT_PhamVanAt.pdf - Sentence 59
60,"Đi ều này không báo l ỗi khi bi ên dịch, nh ưng có th ể dẫn đến kết quả sai khi chạy  chương trình .",LTHDT_PhamVanAt.pdf - Sentence 60
61,Ví d ụ khi biên d ịch ch ương trình  sau trong môi trường C sẽ không gặp các dòng  cảnh báo  (Warning) và thông  báo lỗi (error).,LTHDT_PhamVanAt.pdf - Sentence 61
62,Nh ưng khi ch ạy sẽ nhận đ ược kết quả sai.,LTHDT_PhamVanAt.pdf - Sentence 62
63,"#include <stdio.h>   void main()  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          4                                         tenshi3003@gmail.com  {  float a,b,c,p,s;   printf("" \nNhap a, b, c "");   scanf(""%f%f%f"",&a,&b,&c);   p=(a+b+c)/2;   s= sqrt(p*(p -a)*(p -b)*(p -c));  printf("" \nDien tich = %0.2f"",s);   getch();   }  Nếu bi ên dịch ch ương trình  này trong TC++ s ẽ nhận đ ược các thông báo lỗi sau:   Eror:  Funtion ‘sqrt’ should have a prototype   Eror:  Funtion ‘getch’ should have a prototype   Để biến ch ương trình  trên thành m ột ch ương trình  C++ c ần:  + Đặt tên chương chư ờng với đuôi CPP   + Thêm 2 câu l ệnh #include để khai báo ng uyên m ẫu cho các h àm sqrt, getch:   #include <math.h>   #include <conio.h>   Bài 3.",LTHDT_PhamVanAt.pdf - Sentence 63
64,Lập trình cấu tr úc và l ập tr ình hướng đối t ượng  3.1.,LTHDT_PhamVanAt.pdf - Sentence 64
65,Phương pháp l ập trình  cấu trúc  - Tư tư ởng chính của lập trình  cấu trúc là tổ chức ch ương trình  thành các chương trình  con.,LTHDT_PhamVanAt.pdf - Sentence 65
66,Trong PASCAL có 2 kiểu ch ương trình  con là th ủ tục v à hàm.,LTHDT_PhamVanAt.pdf - Sentence 66
67,Trong C ch ỉ có một loại ch ương  trình  con là hàm.,LTHDT_PhamVanAt.pdf - Sentence 67
68,"Hàm là m ột đơn vị chương trình  độc lập d ùng đ ể thực hiện một phần việc n ào đó như: Nh ập số  liệu, in kết quả hay thực hiện một số tính toán.",LTHDT_PhamVanAt.pdf - Sentence 68
69,"H àm c ần có đối và các bi ến, mảng cục bộ d ùng riêng  cho hàm.",LTHDT_PhamVanAt.pdf - Sentence 69
70,Việc trao đổi dữ liệu giữa các h àm th ực hiện thông qua các đối v à các bi ến to àn bộ.,LTHDT_PhamVanAt.pdf - Sentence 70
71,"Các ngôn ng ữ như C, PASCAL, FOXPRO là các ngôn ng ữ cho phép triển khai ph ương pháp l ập  trình  cấu trúc.",LTHDT_PhamVanAt.pdf - Sentence 71
72,"Một ch ương trình  cấu trúc gồm các cấu trúc dữ liệu (nh ư biến, mảng, bản ghi) v à các hàm, th ủ  tục.",LTHDT_PhamVanAt.pdf - Sentence 72
73,"Nhiệm vụ chính của việc tổ chức thiết kế ch ương trình  cấu trúc là tổ chức ch ương trình  thành các  hàm, th ủ tục: Ch ương trình  sẽ bao gồm các hàm, th ủ tục n ào.",LTHDT_PhamVanAt.pdf - Sentence 73
74,"Ví dụ xét yêu c ầu sau: Vi ết ch ương trình  nhập toạ độ (x,y) của một dẫy điểm, sau đó tìm một  cặp điểm cách xa nhau nhất.",LTHDT_PhamVanAt.pdf - Sentence 74
75,"Trên tư tư ởng của lập trình  cấu trúc có thể tổ chức ch ương trình  như sau:   + Sử dụng 2 mảng thực to àn bộ x v à y đ ể chứa toạ độ dẫy điẻm   + Xây d ựng 2 h àm:  Hàm nhapsl dùng đ ể nhập toạ độ n điểm, h àm này có m ột đối l à biến nguy ên n và đư ợc khai báo  như sau:   void nhapsl(int n);  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          5                                         tenshi3003@gmail.com  Hàm do_dai dùng đ ể tính độ d ài đo ạn thẳng đi qua 2 điểm có chỉ số l à i và j , nó đư ợc khai báo  như sau:   float  do_dai(int i, int j);   Chương trình  C cho bài toán trên được viết nh ư sau:   #include <stdio.h>   #include <conio.h>   #include <math.h>   float x[100],y[100];   float do_dai(int i, int j)   {  return sqrt(pow(x[i] -x[j],2)+pow(y[i] -y[j],2));   }  void nhapsl(int n)   {  int i;   for (i=1;i<=n;++i)   {  printf("" \nNhap toa do x, y cua diem thu %d : "",i);   scanf(""%f%f"",&x[i],&y[i]);   }  }  void main()   {  int n,i,j,imax,jmax;   float d,dmax;   printf("" \nSo diem N= "");   scanf(""%d"",&n);   nhapsl(n);   dmax=do_dai(1,2); imax=1;jmax=2;   for (i=1;i<=n -1;++i)   for (j=i+1;j<=n;++j)   {  d=do_dai(i,j);   if (d>dmax)   {  dmax=d;   imax=i;   jmax=j;   }  }  printf("" \nDoan thang lon nhat co do dai bang: %0.2f"",dmax);   printf("" \n Di qua 2 diem co chi so la %d va %d"",imax,jmax);  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          6                                         tenshi3003@gmail.com  getch();   }  3.2.",LTHDT_PhamVanAt.pdf - Sentence 75
76,Ph ương pháp l ập trình  hướng đối t ượng  + Kh ỏi niệm trung t õm c ủa lập trình  hướng đối t ượng l à lớp (class).,LTHDT_PhamVanAt.pdf - Sentence 76
77,Có thể xem lớp l à sự kết hợp  các thành ph ần dữ liệu v à các hàm.,LTHDT_PhamVanAt.pdf - Sentence 77
78,Cũngg có th ể xem lớp l à sự mở rộng của cấu trúc trong C  (struct) b ằng cách đ ưa thêm vào các phương th ức (method) hay cũng gọi là hàm thành viên  (member function).,LTHDT_PhamVanAt.pdf - Sentence 78
79,M ột lớp đ ược định nghĩa nh ư sau:          Class Tên_L ớp  {  // Khai báo các thành ph ần dữ liệu   // Khai báo các phương th ức  };  + Các phương th ức có thể đ ược viết (xây dựng) b ên trong ho ặc bên ngoài (phía dư ới) phần định  nghĩa lớp.,LTHDT_PhamVanAt.pdf - Sentence 79
80,Cấu trúc (cách viết) ph ương th ức tương t ự như hàm ngo ại trừ quy tắc sau: Khi xây dựng  một ph ương th ức bên ngoài đ ịnh nghĩa lớp thì trong dòng  đầu tiên cần dùng tên l ớp và 2 d ấu : đặt  trước tên phương th ức để chỉ rừ phương th ức thuộc lớp n ào (xem ví d ụ bên dư ới).,LTHDT_PhamVanAt.pdf - Sentence 80
81,"+ Sử dụng các th ành ph ần dữ liệu trong ph ương th ức: Vì phương th ức và các thành ph ần dữ liệu  thuộc cùng m ột lớp v à vì phương th ức được lập l ên cốt để xử lý các thành ph ần dữ liệu, nên trong  thân của ph ương  thức có quyền truy nhập đến các th ành ph ần dữ liệu (của c ùng l ớp).",LTHDT_PhamVanAt.pdf - Sentence 81
82,"+ Biến lớp: Sau khi định nghĩa một lớp, có thể d ùng tên l ớp để khai báo các biến kiểu lớp hay  cũng gọi là đối tượng.",LTHDT_PhamVanAt.pdf - Sentence 82
83,Mỗi đối t ượng sẽ có các th ành ph ần dữ liệu v à các phương th ức.,LTHDT_PhamVanAt.pdf - Sentence 83
84,Lời gọ i một  phương th ức cần chứa t ên đối tượng để xác định ph ương th ức thực hiện từ đối t ượng n ào.,LTHDT_PhamVanAt.pdf - Sentence 84
85,+ Một ch ương trình  hướng đối t ượng sẽ bao gồm các lớp có quan hệ với nhau.,LTHDT_PhamVanAt.pdf - Sentence 85
86,"+ Vi ệc phân tích, thiết kế ch ương trình  theo phương pháp hư ớng đối t ượng nhằm thiết kế , xây  dựng các lớp.",LTHDT_PhamVanAt.pdf - Sentence 86
87,"+ Từ khái niệm lớp nẩy sinh h àng lo ạt khái niệm khác nh ư: Thành ph ần dữ liệu, ph ương th ức,  phạm vi, sự đóng gói, h àm t ạo, h àm hu ỷ, sự thừa kế, lớp c ơ sử, lớp dẫn xuất, t ương ứng bội,  phương th ức ảo, ...",LTHDT_PhamVanAt.pdf - Sentence 87
88,+ Ưu đi ểm của việc thiết kế h ướng đối tượng l à tập trung xác định các lớp để mô tả các thực thể  của bài toán.,LTHDT_PhamVanAt.pdf - Sentence 88
89,M ỗi lớp đ ưa vào các thành ph ần dữ liệu của thực thể v à xây d ựng luôn các ph ương  thức để xử lý dữ liệu.,LTHDT_PhamVanAt.pdf - Sentence 89
90,"Nh ư vậy việc thiết kế ch ương trình  xuất phát từ các nội dụng, các vấn đề c ủa  bài toán.",LTHDT_PhamVanAt.pdf - Sentence 90
91,"+ Các ngụn ngữ thuần tuý h ướng đối t ượng (nh ư Smalltalk) ch ỉ hỗ trợ các khái niệm về lớp,  không có các khái ni ệm h àm.",LTHDT_PhamVanAt.pdf - Sentence 91
92,"+ C++ là ngôn ng ữ lai , nó cho phép sử dụng cả các công cụ của lớp v à hàm.",LTHDT_PhamVanAt.pdf - Sentence 92
93,Để minh hoạ các khái niệm vừa n êu về lập trình  hướng đối tượng ta trở lại xét b ài toán tìm độ  dài lớn nhất đi qua 2 điểm.,LTHDT_PhamVanAt.pdf - Sentence 93
94,Trong b ài toán này ta g ặp một thực thể l à dẫy điểm.,LTHDT_PhamVanAt.pdf - Sentence 94
95,Các th ành ph ần dữ  liệu của lớp dẫy điểm gồm:   - Biến nguy ên n là s ố điểm của dẫy   - Con tr ỏ x kiểu thực trỏ đến v ùng nh ớ chứa dẫy ho ành độ  - Con tr ỏ y kiểu thực trỏ đến v ùng nh ớ chứa dẫy tung độ   Các phương th ức cần đ ưa vào theo yêu c ầu bài toán g ồm:  - Nhập toạ độ một điểm  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          7                                         tenshi3003@gmail.com  - Tính đ ộ dài đo ạn thẳng đi qua 2 điểm   Dưới đây l à chương trình  viết theo thiết kế h ướng đối t ượng.,LTHDT_PhamVanAt.pdf - Sentence 95
96,Để thực hiện ch ương trình  này nh ớ  đặt tên tệp có đuôi CPP.,LTHDT_PhamVanAt.pdf - Sentence 96
97,"Xem ch ương trình  ta thấy thờm một điều mới trong C++ l à:   Các khai báo bi ến, mảng có thể viết bất kỳ chỗ n ào trong chương trình  (tất nhiên  phải trước khi  sử dụng biến, mảng).",LTHDT_PhamVanAt.pdf - Sentence 97
98,"#include <stdio.h>   #include <conio.h>   #include <math.h>   #include <alloc.h>   class daydiem   {  public:   int n;   float *x,*y;   float do_dai(int i, int j)   {  return sqrt(pow(x[i] -x[j],2)+pow(y[i] -y[j],2));   }  void nhapsl(void);   };  void daydiem::nhapsl(void)   {  int i;   printf("" \nSo diem N= "");   scanf(""%d"",&n) ;  x=(float*)malloc((n+1)*sizeof(float));   y=(float*)malloc((n+1)*sizeof(float));   for (i=1;i<=n;++i)   {  printf("" \nNhap toa do x, y cua diem thu %d : "",i);   scanf(""%f%f"",&x[i],&y[i]);   }  }  void main()   {  daydiem p;   p.nhapsl();   int n,i,j,imax,jmax;   float d,dmax;   n=p.n;   dmax=p.do_dai(1,2); imax=1;jmax=2;   for (i=1;i<=n -1;++i)  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          8                                         tenshi3003@gmail.com  for (j=i+1;j<=n;++j)   {  d=p.do_dai(i,j);   if (d>dmax)   {  dmax=d;   imax=i;   jmax=j;   }  }  printf("" \nDoan thang lon nhat co do dai bang: %0.2f"",dmax);   printf("" \n Di qua 2 diem co chi so la %d va %d"",imax ,jmax);   getch();   }  Bài 4.",LTHDT_PhamVanAt.pdf - Sentence 98
99,"M ột số mở rộng đ ơn gi ản của C++ so với C   Trong m ục này trình  bầy một số mở rộng của C++ , tuy đ ơn gi ản, ngắn gọn nh ưng đem l ại rất  nhiều tiện lợi.",LTHDT_PhamVanAt.pdf - Sentence 99
100,4.1.,LTHDT_PhamVanAt.pdf - Sentence 100
101,Vi ết các dòng  ghi chú  Trong C++ v ẫn có thể viết các dòng  ghi chú trong các dấu /* v à */ như trong C.,LTHDT_PhamVanAt.pdf - Sentence 101
102,Cách  này cho  phộp viết các ghi chú trên nhiều dòng  hoặc trên một dòng .,LTHDT_PhamVanAt.pdf - Sentence 102
103,"Ngoài ra trong C++ cũng cho ph ộp viết   ghi chú trên một dòng  sau 2 d ấu gạch chộo, vớ dụ:   int x,y ;   // Khai báo 2 bi ến thực   4.2.",LTHDT_PhamVanAt.pdf - Sentence 103
104,"Khai báo linh ho ạt  Trong C t ất cả các câu lệnh khai báo biế n, mảng cục bộ phải đặt tại đầu khối.",LTHDT_PhamVanAt.pdf - Sentence 104
105,"Do vậy nhiều khi,  vị trí khai báo v à vị trí sử dụng của biến khá xa nhau, gây khó khăn trong việc kiểm soát ch ương  trình .",LTHDT_PhamVanAt.pdf - Sentence 105
106,"C++ đó kh ắc phục nh ược điểm n ày bằng cách cho phép các lệnh khai báo biến, mảng có thể  đặt bất kỳ chỗ n ào trong chương trình  trước khi các biến, mảng đ ược sử dụng.",LTHDT_PhamVanAt.pdf - Sentence 106
107,"Ví dụ ch ương trình   nhập một dẫy số thực rồi sắp xếp theo thứ tự tăng dần có thể viết trong C++ nh ư sau:   #include <stdio.h>   #include <conio.h>   #include <alloc.h>   void main()   {  int n;   printf(""\n So phan tu cua day N= "");    scanf(""%d"",&n);   float *x= (float*)malloc((n+1)*sizeof(float));   for (int i=1;i<=n;++i)   {  printf("" \nX[%d]= "",i);  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          9                                         tenshi3003@gmail.com  scanf(""%f"",x+i);   }  for (i=1;i<=n -1;++i)   for (int j=i+1;j<=n;++j)   if (x[i]>x[j])   {  float tg=x[i];   x[i]=x[j];   x[j]=tg;   }  printf("" \nDay sau khi sap xep \n"");  for (i=1;i<=n;++i)            printf(""%0.2f "",x[i]);   getch();   }  4.3.",LTHDT_PhamVanAt.pdf - Sentence 107
108,Toán t ử ép kiểu   Toán t ử này đư ợc viết trong C nh ư sau:   (Kiểu) biểu thức   Trong C++ v ẫn có thể d ùng cách vi ết này.,LTHDT_PhamVanAt.pdf - Sentence 108
109,Ngoài ra C++ cho phép vi ết một cách khác tiện lợi  hơn như sau:   Kiểu(biểu thức)   Ví dụ chương trình  tớnh cụng thức   S = 2/1  +  3/2 + ...,LTHDT_PhamVanAt.pdf - Sentence 109
110,"+ (n+1)/n            với n l à một số nguy ên dương nh ập từ b àn phím, có th ể viết nh ư sau:   #include <stdio.h>   #include <conio.h>   void main()   {  int n;   printf("" \n So phan tu cua day N= "");   scanf(""%d"",&n);   float s=0.0;   for (int i=1;i<=n;++i)     s += float(i+1)/float(i) ; // Ep  kieu theo C++   printf(""S= %0.2f "",s);   getch();   }  4.4.",LTHDT_PhamVanAt.pdf - Sentence 110
111,"H ằng có kiểu   Để tạo ra một hằng có kiểu, ta sử dụng từ khoá const đặt tr ước một khai báo có khởi gán giá trị.",LTHDT_PhamVanAt.pdf - Sentence 111
112,Sau đây là m ột số ví dụ.,LTHDT_PhamVanAt.pdf - Sentence 112
113,"Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          10                                         tenshi3003@gmail.com   + Hằng nguy ên:  const int  maxsize = 1000;   int a[maxsize] ;     + Cấu trúc h ằng:  typedef  struct   {  int x, y ;  // To ạ độ của điểm   int  mau ;  // Mó m ầu của điểm   }  DIEM ;   const DIEM  d = {320, 240, 15};     Chương trình  dưới đây minh hoạ cách d ùng h ằng có kiểu.",LTHDT_PhamVanAt.pdf - Sentence 113
114,Ch ương trình  tạo một cấu trúc hằng  (kiểu DIEM) mụ tả điểm giữa m àn hình đồ hoạ với mầu trắng.,LTHDT_PhamVanAt.pdf - Sentence 114
115,Điểm n ày đư ợc hiển thị tr ên màn  hình đồ hoạ.,LTHDT_PhamVanAt.pdf - Sentence 115
116,"#include <stdio.h>   #include <conio.h>   #include <graphics.h>   #include <stdlib.h>   typedef struct    {       int x,y;       int mau;   } DIEM;   void main()   {  int mh=0,mode=0;   initgraph(&mh,&m ode,"""");   int loi=graphresult();   if (loi)   {  printf("" \nLoi do hoa: %s"",grapherrormsg(loi));   getch(); exit(0);   }  const DIEM gmh = {getmaxx()/2,getmaxy()/2,WHITE};   putpixel(gmh.x,gmh.y,gmh.mau);   getch();     closegraph();   }  Chú ý:  a.",LTHDT_PhamVanAt.pdf - Sentence 116
117,Có th ể dùng các hàm đ ể gán gi á trị cho các hằng có kiểu (trong ch ương trình  trên dựng các  hàm getmax và getmaxy).,LTHDT_PhamVanAt.pdf - Sentence 117
118,b.,LTHDT_PhamVanAt.pdf - Sentence 118
119,M ọi câu lệnh nhằm thay đổi giá trị hằng có kiểu đều bị báo lỗi khi bi ên dịch ch ương trình .,LTHDT_PhamVanAt.pdf - Sentence 119
120,Vớ  dụ nếu trong ch ương trình  đưa vào câu l ệnh: Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          11                                         tenshi3003@gmail.com  gmh.x=200;   thì khi d ịch ch ương  trình  sẽ nhận đ ược thông báo lỗi nh ư sau:   Cannot modify a const object   4.5.,LTHDT_PhamVanAt.pdf - Sentence 120
121,"Các ki ểu char v à int   Trong C m ột hằng ký tự đ ược xem l à nguyên do đó nó có kích thư ớc 2 byte, ví dụ trong C:   sizeof(‘A’) = sizeof(int) = 2   Cũng trong C++ m ột hằng ký tự đ ược xem l à giá tr ị kiểu char v à có kích thư ớc một byte.",LTHDT_PhamVanAt.pdf - Sentence 121
122,Nh ư  vậy trong C++ thì:  sizeof(‘A’) = sizeof(char) = 1   4.6.,LTHDT_PhamVanAt.pdf - Sentence 122
123,L ấy địa chỉ các phần tử mảng thực 2 chiều   Trong Turbo C 2.0 không cho phép dùng phép & đ ể lấy địa chỉ các phần tử mảng thực 2 chiều.,LTHDT_PhamVanAt.pdf - Sentence 123
124,Vì vậy khi nhập m ột ma trân thực (d ùng scanf) ta ph ải nhập qua một biến trung gian sau đó mới gán  cho các ph ần tử mảng.,LTHDT_PhamVanAt.pdf - Sentence 124
125,"Trong TC ++ 3.0 cho phép l ấy địa chỉ các phần tử mảng thực 2 chiều, do đó có thể d ùng scanf đ ể  nhập trực tiếp v ào các ph ần tử mảng.",LTHDT_PhamVanAt.pdf - Sentence 125
126,Chương trình  C++ dư ới đây s ẽ minh hoạ điều n ày.,LTHDT_PhamVanAt.pdf - Sentence 126
127,Chương trình  nhập một ma trận thực cấp mxn  và xỏc định phần tử có giá trị lớn nhất.,LTHDT_PhamVanAt.pdf - Sentence 127
128,"#include <conio.h>   #include <stdio.h>   void main()   {  float a[20][20], smax;   int   m,n,i,j, imax, jmax;   clrscr();   puts( ""Cho biet so hang va so cot  cua ma tran: "") ;   scanf(""%d%d"",&m,&n) ;   for (i=1;i<=m;++i)   for (j=1;j<=n;++j)   {  printf("" \na[%d][%d]= "",i,j);   scanf(""%f"",&a[i][j]); // L ấy địa chỉ phần tử mảng thực    // 2 chi ều  }  smax = a[1][1]; imax=1; jmax=1;   for (i=1;i<=m;++i)   for (j=1;j<=n;++j)   if (sm ax<a[i][j])   {  smax = a[i][j];   imax=i ; jmax = j;   } Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          12                                         tenshi3003@gmail.com  puts( "" \n\n Ma tran"") ;   for (i=1;i<=m;++i)   for (j=1;j<=n;++j)   {  if (j==1) puts("""");   printf(""%6.1f"", a[i][j]);   }  puts( "" \n\nPhan tu max:"" );   printf("" \nco gia tri = %6.1f"", smax);   printf("" \nTai hang %d   cot  %d "" ,imax, jmax) ;   getch();   }  Bài 5.",LTHDT_PhamVanAt.pdf - Sentence 128
129,Vào ra trong C++   5.1.,LTHDT_PhamVanAt.pdf - Sentence 129
130,"Các toán t ử và phương th ức xuất nhập   Để in dữ liệu ra m àn hình và nh ập dữ liệu từ b àn ph ớm , trong C++ vẫn có thể dựng các hàm  printf và scanf (như ch ỉ ra trong các ch ương trình  C++ ở các mục trên).",LTHDT_PhamVanAt.pdf - Sentence 130
131,Ngoài ra trong C++ cũng dựng toán tử xuất:   cout  << bi ểu thức << .,LTHDT_PhamVanAt.pdf - Sentence 131
132,..,LTHDT_PhamVanAt.pdf - Sentence 132
133,"<< bi ểu thức ;     để đưa giá tr ị các biểu thức ra m àn hình,  dựng toán tử nhập:   cin  >> bi ến >> ...",LTHDT_PhamVanAt.pdf - Sentence 133
134,>> biến   để nhập các giá trị số (nguy ên th ực) từ b àn phím và gán cho các bi ến.,LTHDT_PhamVanAt.pdf - Sentence 134
135,"Để nhập một dẫy không quá n ký tự v à chứa vào m ảng h (kiểu char) có thể d ùng phương th ức  cin.get như sau:   cin.get(h,n);   Chú ý 1: Toán t ử nhập cin >> sẽ để lại ký tự chuyển dòng  ‘\n’ trong b ộ đệm, ký tự n ày có th ể  làm trôi phương th ức cin.get.",LTHDT_PhamVanAt.pdf - Sentence 135
136,Để khắc phục tỡnh trạng trên cần dựng ph ương th ức cin.ignore để bỏ  qua m ột ký tự chuyển dòng  như sau:   cin.ignore(1);   Chú ý 2: Để sử dụng các toán tử v à phương th ức nói tr ên cần khai báo tệp ti êu đề:  #include  <iostream.h>   Chương trình  sau minh ho ạ việc sử dụng các cụng cụ v ào ra m ới của C++ để nhập một danh sách  n thí sinh.,LTHDT_PhamVanAt.pdf - Sentence 136
137,"D ữ liệu mỗi thí si nh gồm họ t ên, các đi ểm toán, lý, hoá.",LTHDT_PhamVanAt.pdf - Sentence 137
138,Sau đó in danh sách thí sinh theo  thứ tự giảm của tổng điểm.,LTHDT_PhamVanAt.pdf - Sentence 138
139,"#include <iostream.h>   #include <conio.h>   void main()   {  struct   {  char ht[25];  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          13                                         tenshi3003@gmail.com  float t,l,h,td;   } ts[50],tg;   int   n,i,j;   clrscr();   cout << "" So thi sinh: "" ;   cin   >> n ;   for (i=1;i<=n;++i)   {  cout << "" \n Thi sinh "" << i ;   cout << "" \n Ho ten: ""  ;   cin.ignore(1);   cin.get(ts[i].ht,25) ;   cout << ""Cac diem toan, ly, hoa: "";   cin >> ts[i].t >> ts[i].l >> ts[i].h ;   ts[i].td = ts[i].t + ts[i].l + ts[i].h ;   }  for (i=1;i <=n-1;++i)   for (j=i+1;j<=n;++j)   if (ts[i].td < ts[j].td )   {  tg=ts[i];   ts[i]=ts[j];   ts[j]=tg;   }  cout << "" \nDanh sach thi sinh sau khi sap xep "" ;   for (i=1;i<=n;++i)   {  cout << "" \n Ho ten: "" << ts[i].ht;   cout << ""   Tong diem: ""  << ts[i].td;   }  getch();   }  5.2.",LTHDT_PhamVanAt.pdf - Sentence 139
140,"Định dạng khi in ra m àn hình     + Để quy định số thực (float, double) đ ược in ra có đúng p chữ số sau dấu chấm thập phân, ta  sử dụng đồng thời các h àm sau:   setiosflags(ios::showpoint);   // B ật cờ hiệu showpoint   setprecision(p);   Các hàm này c ần đặt trong toán t ử xuất nh ư sau:   cout  << setiosflags(ios::showpoint) << setprecision(p) ;   Câu l ệnh tr ên sẽ có hiệu lực đối với tất cả các toán tử xuất tiếp theo cho đến khi gặp một câu lệnh  định dạng mới.",LTHDT_PhamVanAt.pdf - Sentence 140
141,"Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          14                                         tenshi3003@gmail.com     + Để quy định độ rộng tối thiểu l à w v ị trí cho giá trị (n guyên, th ực, chuỗi) đ ược in trong các  toán t ử xuất, ta d ùng hàm   setw(w)   Hàm này c ần đặt trong toán tử xuất v à nó ch ỉ có hiệu lực cho một giá trị đ ược in gần nhất.",LTHDT_PhamVanAt.pdf - Sentence 141
142,Các  giá tr ị in ra tiếp theo sẽ có độ rộng tối thiểu mặc định l à 0.,LTHDT_PhamVanAt.pdf - Sentence 142
143,"Như v ậy câu lệnh:   cout <<  setw(3) << “AB” << “CD”   Sẽ in ra 5 ký tự l à: một dấu cách và 4 ch ữ cỏi A, B, C v à D.",LTHDT_PhamVanAt.pdf - Sentence 143
144,Chú ý: Muốn sử dụng các h àm trên c ần đưa vào câu l ệnh #include sau:   #include <iomanip.h>   Trở lại ch ương trình  trên ta thấy danh sỏch thớ sinh in ra sẽ không  thẳng cột.,LTHDT_PhamVanAt.pdf - Sentence 144
145,"Để  khắc phục điều  này c ần viết lại đoạn ch ương trình  in như sau:   cout << "" \nDanh sach thi sinh sau khi sap xep "" ;   cout << setiosflags(ios::showpoint) << setprecision(1) ;   for(i=1;i<=n;++i)   {  cout <<  "" \n Ho ten: "" << setw(25) << ts[i].ht;   cout << ""   Tong d iem: ""  << setw(5)<< ts[i].td;   }  getch();    Chương trình  dưới đây l à một  minh hoạ khác về việc sử dụng các toán tử nhập xuất v à cách đ ịnh  dạng trong C++ .",LTHDT_PhamVanAt.pdf - Sentence 145
146,Ch ương trình  nhập một ma trận thực cấp mxn.,LTHDT_PhamVanAt.pdf - Sentence 146
147,Sau đó in ma trận d ưới dạng bảng  và tìm một phần tử lớn n hất.,LTHDT_PhamVanAt.pdf - Sentence 147
148,"#include <iostream.h>   #include <iomanip.h>   #include <conio.h>   void main()   {     float a[20][20], smax;   int   m,n,i,j, imax, jmax;   clrscr();   cout << "" Cho biet so hang va so cot cua ma tran: "" ;   cin  >> m >> n ;   for (i=1;i<=m;++i)   for (j=1;j<=n;++j)   {  cout << ""a["" << i << "","" << j << ""]= "" ;   cin >> a[i][j] ;   }  smax = a[1][1]; imax=1; jmax=1;   for (i=1;i<=m;++i)   for (j=1;j<=n;++j)   if (smax<a[i][j])  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          15                                         tenshi3003@gmail.com  {  smax = a[i][j];   imax=i ; jmax = j;   }  cout << "" \n\n Ma tran"" ;   cout << setiosflags(ios::showpoint) << setpre cision(1) ;   for (i=1;i<=m;++i)   for (j=1;j<=n;++j)   {  if (j==1) cout <<  ' \n' ;  cout << setw(6) << a[i][j];   }  cout << "" \n\n"" << ""Phan tu max:"" << ' \n' ;  cout << ""co gia tri = "" << setw(6) << smax;   cout << "" \nTai hang "" << imax << ""  cot "" << jmax ;   getch();   }  Bài 6.",LTHDT_PhamVanAt.pdf - Sentence 148
149,"Cấu trúc, hợp v à kiểu liệt k ê  6.1.",LTHDT_PhamVanAt.pdf - Sentence 149
150,"Tên sau t ừ khoá struct  đ ược xem nh ư tên ki ểu cấu trúc   Trong C++ m ột kiểu cấu trúc cũngg được định nghĩa nh ư C theo m ẫu:  struct  Tên_ki ểu_ct   {  // Khai báo các thành ph ần của cấu trúc   } ;  Sau đó đ ể khai báo các bi ến, mảng cấu trúc, trong C d ùng m ẫu sau:   struct  Tên_ki ểu_ct  danh sách biến, mảng cấu trúc ;   Như v ậy trong C, t ên vi ết sau từ khoá struct  ch ưa ph ải là tên ki ểu và chưa có th ể dùng đ ể khai  báo.",LTHDT_PhamVanAt.pdf - Sentence 150
151,Trong C++ xem tên vi ết sau từ khoá struct l à tên ki ểu cấu t rúc và có th ể  dùng nó đ ể khai báo.,LTHDT_PhamVanAt.pdf - Sentence 151
152,"Như v ậy để khai báo các biến, mảng cấu trúc  trong C++ , ta có thể d ùng m ẫu sau:   Tên_ki ểu_ct  danh sách biến, mảng cấu trúc ;   Ví dụ sau s ẽ: Định nghĩa kiểu cấu trúc TS (thí sinh) gồm các th ành ph ần : ht (họ t ên), sobd ( số  báo danh), dt (đi ểm toán), dl (điểm lý), dh (điểm hoá) v à td (t ổng điểm), sau đó khai báo biến cấu  trúc h và m ảng cấu trúc ts.",LTHDT_PhamVanAt.pdf - Sentence 152
153,"struct TS   {  char ht [25];   long sobd;   float dt, dl, dh, td;   } ;  TS   h, ts[1000] ;   6.2.",LTHDT_PhamVanAt.pdf - Sentence 153
154,"Tên sau t ừ khoá union  đ ược xem nh ư tên  kiểu hợp  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          16                                         tenshi3003@gmail.com  Trong C++ m ột kiểu hợp (union) cũngg được định nghĩa nh ư C theo m ẫu:  union  Tên_ki ểu_hợp   {  // Khai báo các thành ph ần của hợp   } ;  Sau đó đ ể khai báo các biến, mảng kiểu hợp , trong C d ùng m ẫu sau:   union  Tên_ki ểu_hợp  danh sách biến, mảng kiểu hợ p ;   Như v ậy trong C, t ên vi ết sau từ khoá union  ch ưa ph ải là tên ki ểu và chưa có th ể dùng đ ể khai  báo.",LTHDT_PhamVanAt.pdf - Sentence 154
155,Trong C++ xem tên vi ết sau từ khoá union l à tên ki ểu hợp v à có th ể dùng nó đ ể khai báo.,LTHDT_PhamVanAt.pdf - Sentence 155
156,"Nh ư  vậy để khai báo các biến, mảng kiểu hợp, trong C++ có thể dùng m ẫu sau:   Tên_ki ểu_hợp  danh sách biến, mảng kiểu hợp ;   6.3.",LTHDT_PhamVanAt.pdf - Sentence 156
157,Các union không tên   Trong C++ cho phép dùng các union không tên d ạng:  union   {  // Khai báo các thành ph ần  } ;   Khi đó các thành ph ần  (khai báo trong union) sẽ d ùng chung m ột vùng nh ớ.,LTHDT_PhamVanAt.pdf - Sentence 157
158,Điều n ày cho phép  tiết kiệm bộ nhớ v à cho phép d ễ dàng tách các byte c ủa một v ùng nh ớ.,LTHDT_PhamVanAt.pdf - Sentence 158
159,"Ví dụ nếu các biến nguyên  i , bi ến ký tự ch v à biến thực x không  đồng thời sử dụng thì có thể  khai báo chúng  trong m ột union không  tên như sau:   union   {  int i ;   char ch ;   float x ;  } ;  Khi đó các bi ến i , ch v à f sử dụng chung một v ùng nh ớ 4 byte.",LTHDT_PhamVanAt.pdf - Sentence 159
160,"Xét ví d ụ khác, để tách các byte của một biến unsigned long ta d ùng union không tên sau:   union   {  unsigned long   u ;   unsigned char   b[4] ;   };  Khí đó n ếu gán   u = 0xDDCCBBAA;  // S ố hệ 16  thì :  b[0] = 0xAA        b[1] = 0xBB       b[2] = 0xCC        b[3] = 0xDD  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          17                                         tenshi3003@gmail.com  6.4.",LTHDT_PhamVanAt.pdf - Sentence 160
161,"Ki ểu liệt k ê (enum)   + Cũngg giống nh ư cấu trúc v à hợp, tên vi ết sau từ khoá enum đ ược xem l à kiểu liệt k ê và có th ể  dùng đ ể khai báo, ví dụ:   enum MAU { xanh, do, tim, vang } ;  // Định nghĩa kiểu MAU   MAU  m, dsm[10] ; // Khai báo các bi ến, mảng kiểu MAU   + Các giá tr ị kiểu liệt k ê (enum) là các s ố nguy ên.",LTHDT_PhamVanAt.pdf - Sentence 161
162,"Do đó có th ể thực hiện các phép tính tr ên các  giá tr ị enum,  có thể in các giá trị enum, có thể gán giá trị enum cho biến nguy ên, ví d ụ:  MAU   m1 , m2 ;   int   n1, n2 ;   m1 = tim ;   m2 = vàng ;   n1 = m1 ; //  n1 = 2   n2 = m1 + m2 ;  // n2 = 5   printf (“ \n %d “ , m2 );  // in ra s ố 3  + Không th ể gán trực tiếp một giá trị nguy ên cho m ột biến enum m à phải dùng phép ép ki ểu, ví  dụ:  m1 = 2 ;   // lỗi  m1 = MAU(2) ;   // đúng       Bài 7.",LTHDT_PhamVanAt.pdf - Sentence 162
163,Cấp phát bộ nhớ   7.1.,LTHDT_PhamVanAt.pdf - Sentence 163
164,"Trong C++  có th ể sử dụng các h àm c ấp phát bộ nhớ động của C nh ư: hàm malloc đ ể cấp phát  bộ nhớ, h àm free đ ể giải phóng bộ nhớ đ ược cấp phát.",LTHDT_PhamVanAt.pdf - Sentence 164
165,7.2.,LTHDT_PhamVanAt.pdf - Sentence 165
166,Ngoài ra trong C++  cũng đưa thêm toán t ử new đ ể cấp phát bộ nhớ v à toán t ử delete để giải  phóng b ộ nhớ đ ược cấp phát bởi new   7.3.,LTHDT_PhamVanAt.pdf - Sentence 166
167,"Cách dùng toán t ử new để cấp phát bộ nhớ nh ư sau:   + Trư ớc hết cần khai báo một con trỏ để chứa địa chỉ v ùng nh ớ sẽ đ ược cấp phát:   Kiểu   *p;   ở đây Kiểu có thể l à:  - các ki ểu dữ liệu chuẩn của C++ nh ư int , long, float , double, char , ...",LTHDT_PhamVanAt.pdf - Sentence 167
168,"- các kiểu do lập trình  viên định nghĩa nh ư: mảng, hợp, cấu trúc, lớp, ...",LTHDT_PhamVanAt.pdf - Sentence 168
169,+ Sau đó dùng toán t ử new theo mẫu:   p = new  Ki ểu ;  // Cấp phát bộ nhớ cho một biến (một phần tử)   p = new Ki ểu[n]  ;  //C ấp phát bộ nhớ cho n phần tử   Ví dụ để cấp phát bộ nhớ cho một biến thực ta d ùng câu l ệnh sau:   float  *px = new float ;   Để cấp phát bộ nhớ cho 100 phần tử nguy ên ta dùng các câu l ệnh:  int   *pn = new int[100] ;   for (int i=0 ; i <  100 ; ++i )                  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          18                                         tenshi3003@gmail.com    pn[i]  =  20*i ;   // Gán cho ph ần tử thứ i   7.4.,LTHDT_PhamVanAt.pdf - Sentence 169
170,Hai cách ki ểm tra sự th ành công c ủa new   Khi dùng câu l ệnh:  Kiểu *p = new Kiểu[n]  ;   hoặc câu lệnh:   Kiểu *p = new Kiểu  ;   để cấp phát bộ nhớ sẽ xuất hiện một trong 2 tr ường hợp: th ành công ho ặc kh ông thành công.,LTHDT_PhamVanAt.pdf - Sentence 170
171,Nếu th ành c ụng thì p sẽ chứa địa chỉ đầu v ùng nh ớ được cấp phát.,LTHDT_PhamVanAt.pdf - Sentence 171
172,Nếu không  thành c ụng thì p = NULL.,LTHDT_PhamVanAt.pdf - Sentence 172
173,Đoạn ch ương trình  sau minh ho ạ cách kiểm tra lỗi cấp phát bộ nhớ:   double  *pd ;   int n ;   cout << “ \n Số phần tử : “ ;   cin  >> n ;   pd = new do uble[n] ;   if (pd==NULL)   {  cout << “ L ỗi cấp phát bộ nhớ “   exit (0) ;   }  Cách th ứ 2 để kiểm tra sự th ành công c ủa toán tử new l à dùng con tr ỏ hàm:  _new_handler   được định nghĩa trong tệp “new.h”.,LTHDT_PhamVanAt.pdf - Sentence 173
174,Khi gặp lỗi trong toán tử new (cấp phát không th ành công)  thì chương trình  sữ thực hiện một h àm nào đó do con tr ỏ _new _handler tr ỏ tới.,LTHDT_PhamVanAt.pdf - Sentence 174
175,Cách d ùng con tr ỏ  này như sau:   + Xây d ựng một h àm dùng đ ể kiểm tra sự th ành công c ủa new   + Gán tên hàm này cho con tr ỏ  _new_handler   Như v ậy hàm ki ểm tra sẽ đ ược gọi mỗi khi có lỗi xẩ y ra trong toán t ử new.,LTHDT_PhamVanAt.pdf - Sentence 175
176,"Đoạn ch ương trình  kiểm tra theo cách thứ nhất có thể viết theo cách thứ hai nh ư sau:   void kiem_tra_new(void)  // L ập hàm ki ểm tra   {  cout << “ L ỗi cấp phát bộ nhớ “   exit (0) ;   }  _new _handler  = kiem_tra_new  // Gán tên hàm cho con tr ỏ  double  *pd ;   int n ;   cout << “ \n Số phần tử : “ ;   cin  >> n ;   pd = new double[n] ;  // Khi x ẩy ra lỗi sẽ gọi h àm ki ểm_tra_new  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          19                                         tenshi3003@gmail.com  Chú ý: Có th ể dùng l ệnh gán để gán t ên hàm x ử lý lỗi cho con trỏ _new _handler như trong đo ạn  chương trình  trên, hoặc dựng h àm:  set_new_handler(Tên hàm) ;   (xem các chương trình  minh ho ạ bên dưới)  7.5.",LTHDT_PhamVanAt.pdf - Sentence 176
177,Toán t ử delete d ùng đ ể giải phóng v ùng nh ớ được cấp phát bởi new   Cách dùng như sau:   delete  p ;  // p là con tr ỏ dùng trong new   Ví dụ:  float  *px ;   px = new float[2000] ;  // C ấp phá t bộ nhớ cho 2000 phần tử thực   // Sử dụng bộ nhớ đ ược cấp phát   delete px ;  // gi ải phóng bộ nhớ   7.6.,LTHDT_PhamVanAt.pdf - Sentence 177
178,Hai chương trình  minh ho ạ  Chương trình  thứ nhất minh hoạ cách dựng new để cấp phát bộ nhớ chứa n thí sinh.,LTHDT_PhamVanAt.pdf - Sentence 178
179,"Mỗi thí sinh  là một cấu trúc gồm các tr ường ht  (họ tên), sobd (s ố báo danh) v à td (t ổng điểm).",LTHDT_PhamVanAt.pdf - Sentence 179
180,"Ch ương trình  sẽ  nhập n, cấp phát bộ nhớ chứa n thớ sinh, kiểm tra lỗi cấp phát bộ nhớ (dựng cách 1), nh ập n thớ  sinh, s ắp xếp thớ sinh theo thứ tự giảm của tổng điểm, in danh sách thí sinh sau khi sắp xếp, v à cuối  cùng là gi ải phóng bộ nhớ đó cấp phát.",LTHDT_PhamVanAt.pdf - Sentence 180
181,"#include <iomanip.h>   #include <iostream.h>   #include <stdlib.h>   #include <conio.h>   struct TS   {  char ht[20];   long sobd;   float td;   } ;  void main(void)   {  TS*ts ;   int n;   cout << "" \n So thi sinh n =  "" ;   cin >> n;   ts = new TS[n+1];   if(ts==NULL)   {  cout << "" \nLoi cap phat bo nho "" ;   getch();   exit(0);   } Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          20                                         tenshi3003@gmail.com  for (int i=1;i<=n;++i)   {  cout <<"" \nThi sinh thu "" << i;   cout << "" \nHo ten: "" ;   cin.ignore(1) ;   cin.get(ts[i].ht,20);   cout << ""So bao danh: "" ;   cin >> ts[i].sobd ;   cout <<  ""Tong diem: "" ;   cin >> ts[i].td ;   }  for (i=1;i<=n -1;++i)   for (int j=i+1;j<=n;++j)   if (ts[i].td < ts[j].td)   {  TS tg=ts[i];   ts[i]=ts[j];   ts[j]=tg;   }  cout << setiosflags(ios::showpoint) << setprecision(1) ;   for (i=1;i<=n;++i)   cout << "" \n"" << setw(20) << ts[i ].ht <<   setw(6)<< ts[i].sobd <<setw(6)<< ts[i].td;   delete ts;   getch();   }  Chương trình  thứ hai minh hoạ cách dựng con trỏ _new_handler để kiểm tra sự th ành công c ủa  toán t ử new.",LTHDT_PhamVanAt.pdf - Sentence 181
182,Ch ương trình  sẽ cấp phát bộ nhớ cho một mảng con trỏ v à sẽ theo rồi khi nào thì  không đ ủ bộ  nhớ để cấp phát.,LTHDT_PhamVanAt.pdf - Sentence 182
183,"#include <new.h>   #include <iostream.h>   #include <stdlib.h>   #include <conio.h>   int k;   void loi_bo_nho(void)   {  cout << "" \nLoi bo nho khi cap phat bo nho cho q["" << k << ""]"";   getch();   exit(0);   }  void main()  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          21                                         tenshi3003@gmail.com  {  double *q[100] ;   long n;   clrscr();   set_new_handler(loi_bo_nho) ;   // _new_handler=loi_bo_nho;   n=10000;   for ( k=0;k<100;++k)   q[k] = new double[n];   cout << ""Khong loi"";   getch();   }  Bài 8.",LTHDT_PhamVanAt.pdf - Sentence 183
184,"Các hàm trong C++   Trong C++ có r ất nhiều mở rộng, cải tiến về h àm làm cho vi ệc xây dựng v à sử dụng h àm rất tiện  lợi.",LTHDT_PhamVanAt.pdf - Sentence 184
185,Điều n ày sẽ trình  bầy kỹ trong ch ương sau.,LTHDT_PhamVanAt.pdf - Sentence 185
186,Trong m ục này ch ỉ thống k ê một số điểm mới về  hàm  mà C++ đưa vào.,LTHDT_PhamVanAt.pdf - Sentence 186
187,8.1.,LTHDT_PhamVanAt.pdf - Sentence 187
188,"Đ ối kiểu tham chiếu   Trong C, đ ể nhận kết quả của h àm c ần dùng đ ối con trỏ, l àm cho vi ệc xây dựng cũngg như s ử  dụng hàm khá phi ền phức.",LTHDT_PhamVanAt.pdf - Sentence 188
189,"Trong C++ đ ưa vào đ ối kiểu tham chiếu (giống nh ư PASCAL) dùng đ ể  chứa kết quả của h àm, khi ến cho việc tạo lập cũngg như s ử dụng h àm đơn gi ản hơn.",LTHDT_PhamVanAt.pdf - Sentence 189
190,8.2.,LTHDT_PhamVanAt.pdf - Sentence 190
191,Đ ối tham chiếu const   Đối tham chiếu có đặc điểm l à các câu l ệnh trong thân h àm có t hể truy nhập tới v à dễ dàng làm  cho giá tr ị của nó thay đổi.,LTHDT_PhamVanAt.pdf - Sentence 191
192,"Nhiều khi ta muốn d ùng đ ối kiểu tham chiếu chỉ để tăng tốc độ trao đổi  dữ liệu giữa các h àm ,  không mu ốn   d ùng nó đ ể chứa kết quả của h àm.",LTHDT_PhamVanAt.pdf - Sentence 192
193,Khi đó có th ể dùng đ ối  tham chi ếu const để bảo to àn gi á trị của đối trong thân h àm.,LTHDT_PhamVanAt.pdf - Sentence 193
194,8.3.,LTHDT_PhamVanAt.pdf - Sentence 194
195,Đ ối có giá trị mặc định   Trong nhi ều trương h ợp ng ười dùng vi ết một lời gọi h àm nhưng cũng chưa bi ết nên ch ọn giá trị  nào cho các đ ối .,LTHDT_PhamVanAt.pdf - Sentence 195
196,"Để khắc phục khó khăn n ày, C++ đưa ra gi ải pháp đối có giá trị mặc định.",LTHDT_PhamVanAt.pdf - Sentence 196
197,"Khi xây  dựng hàm, ta gán giá tr ị mặc định cho một số đối.",LTHDT_PhamVanAt.pdf - Sentence 197
198,"Ng ười dùng n ếu không cung cấp giá trị cho các  đối này, thì hàm s ẽ dựng giỏ trị mặc định.",LTHDT_PhamVanAt.pdf - Sentence 198
199,8.4.,LTHDT_PhamVanAt.pdf - Sentence 199
200,Hàm on line   Đối với một đoạn ch ương trình  nhỏ (số lệnh không  lớn) thì việc thay các đoạn ch ương trình  này  bằng các lời gọi hàm s ẽ làm cho chương trình  gọn nhẹ đôi chút nh ưng làm tăng th ời gian máy.,LTHDT_PhamVanAt.pdf - Sentence 200
201,"Trong các trư ờng hợp n ày có th ể dùng hàm tr ực tuyến (on line) vừa giảm kích th ước ch ương trình   nguồn, vừa không  làm tăng th ời gian chạy máy.",LTHDT_PhamVanAt.pdf - Sentence 201
202,8.5.,LTHDT_PhamVanAt.pdf - Sentence 202
203,"Các hàm trùng tên (đ ịnh nghĩa  chồng các h àm)  Để lấy giá trị tuyệt đối của một số, trong C cần lập ra nhiều h àm v ới tên khác nhau, ví d ụ abs cho  số nguy ên, fabs cho s ố thực, labs cho số nguy ên dài, cabs cho s ố phức.",LTHDT_PhamVanAt.pdf - Sentence 203
204,Điều n ày rừ ràng gõy phi ền  toỏi cho ng ười sử dụng.,LTHDT_PhamVanAt.pdf - Sentence 204
205,Trong C++ cho phép xây d ựng các h àm trùng tên nhưng khác nhau v ề kiểu  đối.,LTHDT_PhamVanAt.pdf - Sentence 205
206,Nh ư vậy chỉ cần lập một h àm đ ể lấy giá trị tuyệt đối cho nhiều kiểu dữ liệu khác nhau.,LTHDT_PhamVanAt.pdf - Sentence 206
207,8.6.,LTHDT_PhamVanAt.pdf - Sentence 207
208,"Đ ịnh nghĩa chồng toán tử  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          22                                         tenshi3003@gmail.com  Việc dựng các phộp toán thay cho m ột lời gọi h àm rừ ràng làm cho chương trình  ngắn gọn, sáng  sủa hơn nhi ều.",LTHDT_PhamVanAt.pdf - Sentence 208
209,Ví dụ để thực hiện phép cộng 2 ma trận nếu d ùng phép c ộng v à viết:  C = A + B ;   thì rất gần với toán học.,LTHDT_PhamVanAt.pdf - Sentence 209
210,Trong C++ cho phộp dựng các phộp toán chuẩn để đặt t ên cho các hàm  (gọi là định nghĩa chồng toán tử).,LTHDT_PhamVanAt.pdf - Sentence 210
211,Sau đó có thể thay lời g ọi hàm b ằng các phép toán nh ư nói ở trên.,LTHDT_PhamVanAt.pdf - Sentence 211
212,"Như v ậy một phép toán mang nhiều ý nghĩa, vớ dụ phộp + có thể hiểu l à cộng 2 số nguyên , 2 số  thực hoặc 2 ma trận.",LTHDT_PhamVanAt.pdf - Sentence 212
213,C++ sẽ căn cứ v ào ki ểu của các số hạng m à quy ết định chọn phép cộng cụ thể.,LTHDT_PhamVanAt.pdf - Sentence 213
214,Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          23                                         tenshi3003@gmail.com  chương 2   Hàm trong C++   Chương này tr ình b ầy những khả năng mới của C++ trong việc xây dựng v à sử dụng h àm.,LTHDT_PhamVanAt.pdf - Sentence 214
215,Đó là:   + Kiểu tham chiếu v à việc truyền dữ liệu cho h àm b ằng tham chiếu.,LTHDT_PhamVanAt.pdf - Sentence 215
216,+ Đối tham chiếu hằng (const)   + Đối có giá trị mặc định   + Hàm tr ực tuyến   + Việc định nghĩa chồng các h àm  + Việc định nghĩa chồng các toán tử   1.,LTHDT_PhamVanAt.pdf - Sentence 216
217,Bi ến tham chiếu (Reference variable)   1.1.,LTHDT_PhamVanAt.pdf - Sentence 217
218,"Hai lo ại biến d ùng trong C   Trước khi nói đến biến tham chiếu, chúng ta nhắc lại 2 loại biến gặp trong C l à:  Biến giá trị d ùng đ ể chứa dữ liệu (ngu yên, th ực, ký tự, ...",LTHDT_PhamVanAt.pdf - Sentence 218
219,)   Biến con trỏ d ùng đ ể chứa địa chỉ   Các bi ến này đều được cung cấp bộ nhớ v à có đ ịa chỉ.,LTHDT_PhamVanAt.pdf - Sentence 219
220,"Ví dụ câu lệnh khai báo:   double  x , *px;   sẽ tạo ra biến giá trị kiểu double x v à biến con trỏ kiểu double px.",LTHDT_PhamVanAt.pdf - Sentence 220
221,"Biến x có v ùng nh ớ 8 byte, biến  px có vùng nh ớ 4 byte (nếu d ùng mô hình Large).",LTHDT_PhamVanAt.pdf - Sentence 221
222,"Bi ến x d ùng đ ể chứa giá trị kiểu double, ví dụ  lệnh gán:   x = 3.14;   sẽ chứa giá trị 3.14 v ào bi ễn x.",LTHDT_PhamVanAt.pdf - Sentence 222
223,"Biến px d ùng đ ể chứa địa chỉ của một biến thực, ví dụ câu lệnh:   px = &x ;   sẽ lưu tr ữ địa chỉ của biễn x v ào con trỏ px.",LTHDT_PhamVanAt.pdf - Sentence 223
224,1.2.,LTHDT_PhamVanAt.pdf - Sentence 224
225,Bi ến tham chiếu   Trong C++ cho phép s ử dụng loại biến thứ ba l à biến tham chiếu.,LTHDT_PhamVanAt.pdf - Sentence 225
226,"So với 2 loại biến quen biết nói  trên, thì bi ến này có nh ững đặc điểm sau:   + Biến tham chiếu không đ ược cấp phát bộ nhớ, không có địa chỉ ri êng.",LTHDT_PhamVanAt.pdf - Sentence 226
227,+  Nó dùng làm  bí danh cho m ột biến (kiểu giá trị) n ào đó và nó s ử dụng v ùng nh ớ của biến n ày.,LTHDT_PhamVanAt.pdf - Sentence 227
228,"Ví dụ câu lệnh:   float   u, v, &r = u ;   tạo ra các biến thực u, v v à biến tham chiếu thực r.",LTHDT_PhamVanAt.pdf - Sentence 228
229,"Biến r không đ ược cấp phát bộ nhớ, nó l à một  tên khác (bí danh) c ủa u v à nó dùng ch ung vùng nh ớ của biến u.",LTHDT_PhamVanAt.pdf - Sentence 229
230,Thuật ngữ:  Khi r là bí danh (alias) c ủa u th ì ta nói r tham chi ếu đến  biến u.,LTHDT_PhamVanAt.pdf - Sentence 230
231,Nh ư vậy 2 thuật  ngữ trên đư ợc hiểu nh ư nhau.,LTHDT_PhamVanAt.pdf - Sentence 231
232,"ý ngh ĩa: Khi r là bí danh c ủa u th ì r dùng chung vùng nh ớ của u, dó đó :   + Trong m ọi câu lệnh, viết u hay  viết r đều có ý nghĩa nh ư nhau, v ì đều truy nhập đến c ùng m ột  vùng nh ớ.",LTHDT_PhamVanAt.pdf - Sentence 232
233,+ Có th ể dùng bi ến tham chiếu để truy nhập đến một biến kiểu giá trị.,LTHDT_PhamVanAt.pdf - Sentence 233
234,"Ví dụ: Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          24                                         tenshi3003@gmail.com  int u, v, &r = u;   r = 10 ;   // u=10   cout << u ;   // in ra s ố 10  r++   ;         // u = 11   ++ u ;         // r = 12   cout  << r ;    // in ra s ố 12  v = r ;          // v=12   & r ;           // Cho đ ịa chỉ của u       Công d ụng:  Biến tham chiếu th ường đ ược sử dụng l àm đ ối của h àm đ ể cho phép h àm truy nh ập  đến các tham số biến trong lời gọi h àm.",LTHDT_PhamVanAt.pdf - Sentence 234
235,Vài chú ý v ề biến t ham chi ếu:   a.,LTHDT_PhamVanAt.pdf - Sentence 235
236,"Vì bi ến tham chiếu không có địa chỉ ri êng, nó ch ỉ là bí danh c ủa một biến kiểu giá trị n ên  trong khai báo ph ải chỉ r õ nó tham chi ếu đến biến n ào.",LTHDT_PhamVanAt.pdf - Sentence 236
237,Ví d ụ nếu khai báo:   double &x ;   thì Trình biên d ịch sẽ báo lỗi:    Reference variable ‘x’ must b e initialized   b.,LTHDT_PhamVanAt.pdf - Sentence 237
238,"Bi ến tham chiếu có thể tham chiếu đến một phần tử mảng, ví dụ:   int  a[10] , &r = a[5];   r = 25 ;  // a[5] = 25   c.",LTHDT_PhamVanAt.pdf - Sentence 238
239,Không cho phép khai báo m ảng tham chiếu   d.,LTHDT_PhamVanAt.pdf - Sentence 239
240,Bi ến tham chiếu có thể tham chiếu đến một hằng.,LTHDT_PhamVanAt.pdf - Sentence 240
241,Khi đó nó sẽ sử dụng v ùng nh ớ của h ằng v à  nó có th ể làm thay đ ổi giá trị chứa trong v ùng nh ớ này.,LTHDT_PhamVanAt.pdf - Sentence 241
242,Ví dụ nếu khai báo:   int  &s = 23 ;   thì Trình biên d ịch đ ưa ra c ảnh báo (warning):   Temporary used to initialize 's'   Tuy nhiên chương tr ình v ẫn làm vi ệc.,LTHDT_PhamVanAt.pdf - Sentence 242
243,"Các câu lệnh d ưới đây vẫn thực hiện v à cho kết quả nh ư  sau:    s++;  cout << "" \ns= "" << s;  // In ra s=24    Chương tr ình d ưới đây minh hoạ cách d ùng bi ến tham chiếu đến một phần tử mảng cấu trúc để  nhập dữ liệu v à thực hiện các phép tính tr ên các trư ờng của phần tử mảng cấu trúc.",LTHDT_PhamVanAt.pdf - Sentence 243
244,"#include <iostream .h>  #include <conio.h>   struct TS   {  char ht[25];   float t,l,h,td;   } ;  void main()  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          25                                         tenshi3003@gmail.com  {  TS ts[10],&h=ts[1];  // h tham chi ếu đến ts[1]   cout << "" \n Ho ten: ""  ;   cin.get(h.ht,25) ;   cout << ""Cac diem toan, ly, hoa: "";   cin >> h.t >> h.l >> h.h ;   h.td = h.t + h.l + h .h ;  cout <<  "" \n Ho ten: "" <<  ts[1].ht;   cout <<  "" \n Tong diem: ""  <<  ts[1].td;   getch();   }  1.3.",LTHDT_PhamVanAt.pdf - Sentence 244
245,"H ằng tham chiếu (const)   Hằng tham chiếu đ ược khai báo theo mẫu:   int   n = 10 ;   const  int  &r = n;   Cũng giống nh ư biến tham chiếu, hằng tham chiếu có thể tha m chi ếu đến một biến hoặc một  hằng.",LTHDT_PhamVanAt.pdf - Sentence 245
246,Ví dụ:   int  n = 10 ;   const  int  &r = n ;  // H ằng tham chiếu r tham chiếu đến biến n   const  int  &s=123 ; //H ằng tham chiếu s tham chiếu đến hằng 123   Sự khác nhau giữa biến v à hằng tham chiếu ở chỗ: Không cho phép d ùng hằng tham chiếu để  làm thay đ ổi giá trị của v ùng nh ớ mà nó tham chi ếu.,LTHDT_PhamVanAt.pdf - Sentence 246
247,"Ví dụ:  int y = 12, z ;   const int &py=y; // H ằng tham chiếu py tham chiếu đến biến y   y++;     // Đúng    z = 2*py ;  // Đúng  z = 26   cout <<  y <<""  ""<< py;  // In ra:  13  13   py=py+1;  // Sai, Trình biên d ịch thông báo lỗi:   //  Cannot modify a const object   Cách dùng:  Hằng tham chiếu cho phép sử dụng giá trị chứa trong một v ùng nh ớ,  nh ưng không  cho phép thay đ ổi giá trị n ày.",LTHDT_PhamVanAt.pdf - Sentence 247
248,"Hằng tham chiếu th ường đ ược sử dụng l àm đ ối của h àm đ ể cho phép  hàm s ử dụng giá trị của các  tham s ố trong lời gọi h àm, nhưng tránh không làm thay đ ổi giá trị của các tham số.",LTHDT_PhamVanAt.pdf - Sentence 248
249,2.,LTHDT_PhamVanAt.pdf - Sentence 249
250,Truy ền giá trị cho h àm theo tham chi ếu  2.1.,LTHDT_PhamVanAt.pdf - Sentence 250
251,Hàm trong C   Trong C ch ỉ có một cách truyền dữ liệu cho h àm theo giá tr ị :  + Cấp phát v ùng nh ớ cho  các đ ối.,LTHDT_PhamVanAt.pdf - Sentence 251
252,+ Gán giá tr ị các tham số trong lời gọi h àm cho các đ ối sau đó h àm làm vi ệc trên vùng nh ớ của  các đ ối chứ không li ên quan gì đến các tham số.,LTHDT_PhamVanAt.pdf - Sentence 252
253,"Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          26                                         tenshi3003@gmail.com  Như vây chương tr ình s ẽ tạo ra các bản sao (các đối) của các tham số v à hàm s ẽ thao tác tr ên các  bản sao  này, ch ứ không l àm vi ệc trực tiếp với các tham số.",LTHDT_PhamVanAt.pdf - Sentence 253
254,Ph ương pháp này có 2 như ợc điểm  chính:   Tốn kém về thời gian v à bộ nhớ v ì phải tạo ra các bản sao.,LTHDT_PhamVanAt.pdf - Sentence 254
255,"Không thao tác trực tiếp tr ên các  tham s ố, vì vậy không l àm thay đ ổi được giá trị các tham số.",LTHDT_PhamVanAt.pdf - Sentence 255
256,2.2.,LTHDT_PhamVanAt.pdf - Sentence 256
257,Truy ền giá tr ị cho h àm theo tham chi ếu  Trong C++ cung c ấp th êm cách truy ền dữ liệu cho h àm theo tham chi ếu bằng cách d ùng đ ối là  biến tham chiếu hoặc đối l à hằng tham chiếu.,LTHDT_PhamVanAt.pdf - Sentence 257
258,"Cách n ày có ưu đi ểm:  Không c ần tạo ra các bản sao của các tham số, do đó tiết kiệm bộ nh ớ và thời gian chạy máy.",LTHDT_PhamVanAt.pdf - Sentence 258
259,"Hàm s ẽ thao tác trực tiếp tr ên vùng nh ớ của các tham số, do đó dễ d àng thay đ ổi giá trị các tham  số khi cần.",LTHDT_PhamVanAt.pdf - Sentence 259
260,2.3.,LTHDT_PhamVanAt.pdf - Sentence 260
261,M ối quan hệ giữa đối v à tham s ố trong lời gọi h àm  Nếu đối l à biến hoặc hằng tham chiếu kiểu K th ì  tham s ố (trong lờ i gọi hàm) ph ải là biến hoặc  phần tử mảng kiểu K.,LTHDT_PhamVanAt.pdf - Sentence 261
262,"Ví dụ:   + Đối là biến hoặc hằng tham chiếu kiểu double, th ì tham s ố là biến hoặc phần tử mảng kiểu  double   + Đối là biến hoặc hằng tham chiếu kiểu cấu trúc, th ì tham s ố là biến hoặc phần tử mảng kiểu  cấu trúc   2.4.",LTHDT_PhamVanAt.pdf - Sentence 262
263,"Các chương tr ình minh ho ạ  /*   Chương tr ình sau được tổ chức th ành 3 hàm:   Nhập dẫy số double   Hoán v ị 2 biến double   Sắp xếp dẫy số double theo thứ tự tăng dần   Chương tr ình s ẽ nhập một dẫy số v à in d ẫy sau khi sắp xếp   */  #include <iostream.h>   #include < conio.h>   #include <stdio.h>   void nhapds(double *a, int n)   {  for (int i=1; i<= n ; ++i)   {  cout << "" \nPhan tu thu "" << i << "" :  "" ;   cin >> a[i] ;   }  }  void hv(double &x, double &y)   {  double tg=x; x=y; y= tg;   }  void sapxep(double * a, int n)  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          27                                         tenshi3003@gmail.com  {  for (int i=1; i  <= n -1 ;++i)   for (int j=i+1 ; j<=n ;++j)   if (a[i] > a[j])   hv(a[i],a[j]);   }  void main()   {  double x[100];   int i, n;   cout <<"" \n N= "";   cin >> n;   nhapds(x,n);   sapxep(x,n);   for (i=1;i<=n;++i)   printf("" \n%0.1lf"",x[i]);      getch();     }  /*   Chương tr ình sau g ồm các h àm:  - Nhập dẫy cấu trúc (mỗi cấu trúc chứa dữ liệu một thí sinh)   - Hoán v ị 2 biến cấu trúc   - Sắp xếp dẫy thí sinh theo thứ tự giảm của tổng điểm   - In một cấu trúc (in họ t ên và t ổng điểm)   Chương tr ình s ẽ nhập dữ liệu một danh sách t hí sinh, nh ập điểm chuẩn v à in danh sách thí sinh  trúng tuy ển  */  #include <iostream.h>   #include <iomanip.h>   #include <conio.h>   struct TS   {  char ht[20];   float t,l,h,td;   } ;  void ints(const TS &ts)   {  cout << setiosflags(ios::showpoint) << setprecision(1) ;   cout << "" \nHo ten: "" << setw(20) << ts.ht << setw(6) << ts.td ;   } Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          28                                         tenshi3003@gmail.com  void nhapsl(TS *ts,int n)   {  for (int i=1;i<=n;++i)   {  cout << "" \n Thi sinh "" << i ;   cout << "" \n Ho ten: ""  ;   cin.ignore(1);   cin.get(ts[i].ht,25) ;   cout << ""Cac diem toan, ly, hoa: "";   cin >> ts [i].t >> ts[i].l >> ts[i].h ;   ts[i].td = ts[i].t + ts[i].l + ts[i].h ;   }  }  void hvts(TS &ts1, TS &ts2)   {  TS tg=ts1;   ts1=ts2;   ts2=tg;   }  void sapxep(TS *ts,int n)   {  for (int i=1;i<=n -1;++i)   for (int j=i+1;j<=n;++j)   if (ts[i].td < ts[j].td)   hvts(ts[i],ts[j]);   }  void main()   {  TS  ts[100];   int   n,i;   clrscr();   cout << "" So thi sinh: "" ;   cin   >> n ;   nhapsl(ts,n);   sapxep(ts,n) ;   float dc;   cout << "" Diem chuan:  "" ;   cin >> dc;   cout << "" \n\nDanh sach trung tuyen \n"" ;  for (i=1;i<=n;++i)   if (ts[i].td >= dc)  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          29                                         tenshi3003@gmail.com  ints(ts[i ]);  else  break;   getch();   }  /*   Chương tr ình sau g ồm các h àm:  Nhập một ma trận thực cấp mxn   In một ma trận thực d ưới dạng bảng   Tìm ph ần tử lớn nhất v à phần  tử nhỏ nhất của dẫy số th ưc;  Chương tr ình s ẽ nhập một ma trận, in ma trận vừa nhập v à in các ph ần tử lớn nhất v à nhỏ nhất  trên m ỗi hàng của ma trận   */  #include <iostream.h>   #include <iomanip.h>   #include <conio.h>   #include <stdio.h>   void nhapmt(float a[20][20], int m, int n)   {  for (int i=1 ; i<= m ; ++i)   for (int j=1; j<= n ; ++j)   {  cout << "" \na["" << i << "","" << j << ""]= "" ;   cin >> a[i][ j] ;  }  }  void inmt(float a[20][20], int m, int n)   {  cout << setiosflags(ios::showpoint) << setprecision(1);   for (int i=1 ; i<= m ; ++i)   for (int j=1; j<= n ; ++j)   {  if (j==1) cout << "" \n"" ;  cout << setw(6) << a[i][j] ;     }  }  void maxminds(float *x, int n,i nt &vtmax, int &vtmin)   {  vtmax = vtmin = 1 ;   for (int i=2; i<=n ; ++i)  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          30                                         tenshi3003@gmail.com  {  if (x[i] > x[vtmax]) vtmax = i;   if (x[i] < x[vtmin]) vtmin = i;   }  }  void main()   {  float a[20][20];   int m, n;   cout <<"" \n So hamg va so cot ma tran: "";   cin >> m >> n;   nhapmt(a,m,n);   clrscr();   inmt(a,m,n);   float *p = (float*)a;   int vtmax, vtmin;   for (int i=1;i<=m;++i)   {  p =  ((float*)a) + i*20 ;   maxminds(p , n, vtmax, vtmin) ;   printf("" \nHang %d Phan tu max= %6.1f tai cot   %d"",i,p[vtmax],vtmax);   printf("" \n Phan tu min= %6.1f tai cot %d"", p [vtmin],vtmin);   }  getch();   }  3.",LTHDT_PhamVanAt.pdf - Sentence 263
264,Hàm tr ả về các tham chiếu   Hàm có th ể có kiểu tham chiếu v à trả về giá trị tham chiếu.,LTHDT_PhamVanAt.pdf - Sentence 264
265,Khi đó có thể d ùng hàm đ ể truy nhập  đến một biến hoặc một phần tử mảng n ào đó.,LTHDT_PhamVanAt.pdf - Sentence 265
266,Dư ới đây l à một số ví dụ.,LTHDT_PhamVanAt.pdf - Sentence 266
267,Ví dụ 1 trình b ầy một h àm tr ả về một tham chiếu đến một biến to àn bộ.,LTHDT_PhamVanAt.pdf - Sentence 267
268,Do đó có th ể dùng hàm  để truy nhập đến biến n ày.,LTHDT_PhamVanAt.pdf - Sentence 268
269,"#include <iostream.h>   #include <conio.h>   int z ;   int &f()  // Hàm tr ả về một bí danh của biến to àn bộ z  {  return z;   }  void main(void)  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          31                                         tenshi3003@gmail.com  {  f()=50;   // z = 50    cout <<"" \nz= "" << z;   getch();   }      Ví dụ 2  trình b ầy một hàm tr ả về  bí danh của một biến cấu trúc to àn bộ.",LTHDT_PhamVanAt.pdf - Sentence 269
270,"Khác với ví dụ tr ên, ở  đây không dùng hàm m ột cách trực tiếp m à gán hàm cho m ột biến tham chiếu, sau đó d ùng bi ến  tham chi ếu này để truy nhập đến biến cấu trúc to àn bộ.",LTHDT_PhamVanAt.pdf - Sentence 270
271,"#include <iostream.h>   #include  <conio.h>   struct TS   {  char ht[25];   float t,l,h,td;   };  TS  ts;   TS  &f()   {  return ts;   }  void main()   {  TS &h=f();  // h tham chi ếu đến biến ts   cout << "" \n Ho ten: ""  ;   cin.get(h.ht,25) ;   cout << ""Cac diem toan, ly, hoa: "";   cin >> h.t >> h.l >> h.h ;   h.td = h .t + h.l + h.h ;   cout <<  "" \n Ho ten: "" <<  ts.ht;   cout <<  "" \n Tong diem: ""  <<  ts.td;   getch();   }  Ví dụ 3 trình b ầy một h àm tr ả về bí danh của một phần tử mảng cấu  to àn bộ.",LTHDT_PhamVanAt.pdf - Sentence 271
272,Hàm s ẽ kiểm tra xem chỉ số mảng có v ượt ra ngo ài mi ền quy định hay không.,LTHDT_PhamVanAt.pdf - Sentence 272
273,Sau đ ó dùng hàm  này đ ể truy nhập đến các phần tử mảng cấu trúc.,LTHDT_PhamVanAt.pdf - Sentence 273
274,"#include <iostream.h>   #include <conio.h>   #include <stdlib.h>   struct TS  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          32                                         tenshi3003@gmail.com  {  char ht[25];   float t,l,h,td;   };  TS *ts;   void cap_phat_bo_nho_nhapsl(int n)   {  ts = new TS[n+1] ;   if (ts==NULL)   {  cout << ""Loi  cap phat bo nho "" ;   exit(1);   }  for (int i=1;i<=n;++i)   {  TS &h=ts[i];   cout << "" \nThi sinh thu "" << i ;   cout << "" \n Ho ten: ""  ;   cin.ignore(1);   cin.get(h.ht,25) ;   cout << ""Cac diem toan, ly, hoa: "";   cin >> h.t >> h.l >> h.h ;   h.td = h.t + h.l + h.h ;   }  }  TS  &f(int i, int n) // Cho bi danh ts[i]   {  if (i<1 || i>n)   {  cout << ""Chi so mang khong hop le "" ;   xit(1);   }  return ts[i];   }  void main()   {  int n, i ;   cout << "" \n So thi sinh : ""  ;   cin >> n;   cap_phat_bo_nho_nhapsl(n);   while (1)   {  cout << "" \nCan xem thi sinh  thu may: "" ;  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          33                                         tenshi3003@gmail.com  cout << "" \nChon so tu 1 den "" << n << "" (bam sai ket thuc CT) "";   cin >> i;   TS &h=f(i,n);   cout <<  "" \n Ho ten: "" <<  h.ht;   cout <<  "" \n Tong diem: ""  <<  h.td;   }  }    4.",LTHDT_PhamVanAt.pdf - Sentence 274
275,Đối có giá trị mặc định   4.1.,LTHDT_PhamVanAt.pdf - Sentence 275
276,Th ế nào là đ ối mặc định   Một trong các khả năng  mạnh của C++ l à nó cho phép xây d ựng h àm v ới các đối có giá trị mặc  định.,LTHDT_PhamVanAt.pdf - Sentence 276
277,Thông th ường số tham số trong lời gọi h àm ph ải bằng số đối của h àm.,LTHDT_PhamVanAt.pdf - Sentence 277
278,M ỗi đối sẽ đ ược khởi  gán giá tr ị theo tham số t ương ứng của nó.,LTHDT_PhamVanAt.pdf - Sentence 278
279,Trong C++ cho phép tạo giá trị mặc định cho các đ ối.,LTHDT_PhamVanAt.pdf - Sentence 279
280,Các đ ối này có th ể có hoặc không có tham số t ương ứng trong lời gọi h àm.,LTHDT_PhamVanAt.pdf - Sentence 280
281,"Khi không có tham s ố  tương ứng, đối đ ược khởi gán bởi giá trị mặc định.",LTHDT_PhamVanAt.pdf - Sentence 281
282,Ví dụ hàm delay v ới đối số mặc định đ ược viết theo một trong 2 cách sau:   Cách 1  (Không khai báo nguyên m ẫu):    void delay(int n=1000)   {  for (int i=0 ; i<n ; ++i)   ;  }  Cách 2  (Có  khai báo nguyên m ẫu):    void delay(int n=1000) ;   void delay(int n)   {  for (int i=0 ; i<n ; ++i)   ;  }  Cách dùng:   + Cung c ấp giá trị cho đối n (Có tham số trong lời gọi h àm)  delay(5000) ;  // Đối n = 5000   + Sử dụng giá trị mặc định của đối (Không có tham số trong lời gọi)   delay() ; // Đ ối n = 1000   4.2.,LTHDT_PhamVanAt.pdf - Sentence 282
283,Quy t ắc xây dựng h àm v ới đối mặc định   + Các đ ối mặc định cần phải l à các đ ối cuối c ùng tính t ừ trái sang phải.,LTHDT_PhamVanAt.pdf - Sentence 283
284,"Giả sử có 5 đối theo thứ  tự từ trái sang ph ải là  d1, d2, d3, d4, d5   Khi đó:   nếu một đối mặc định th ì phải là d5 Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          34                                         tenshi3003@gmail.com  nếu hai đối mặc định th ì phải là d4, d5   nếu ba đối mặc định th ì phải là d3, d4, d5   ...",LTHDT_PhamVanAt.pdf - Sentence 284
285,"Các ví d ụ sai:   d3 và d5 m ặc định   (khi đó d4 cũng phải mặc định)   d3 và d4 m ặc định   ( khi đó d5 c ũng phải mặc định)   + Khi xây d ựng h àm, n ếu sử dụng khai báo nguy ên m ẫu, th ì các đối mặc định cần đ ược khởi gán  trong nguyên m ẫu, ví dụ:   // Kh ởi gán giá trị cho 3 đối mặc định d3, d4 v à d5)   void f(int d1, float d2, char *d3=”HA NOI”,                int d4 = 100, double d5=3.14) ;   void f(int d1, float d2, char *d3, int d4, double d5)   {  // Các câu l ệnh trong thân h àm  }  Không đư ợc khởi gán lại cho các đối mặc định trong d òng đầu của định nghĩa h àm.",LTHDT_PhamVanAt.pdf - Sentence 285
286,N ếu vi phạm  điều này thì Ch ương tr ình d ịch sẽ thông b áo lỗi.,LTHDT_PhamVanAt.pdf - Sentence 286
287,"+ Khi xây d ựng h àm, n ếu không khai báo nguy ên m ẫu, th ì các đối mặc định đ ược khởi gán trong  dòng đầu của định nghĩa h àm, ví d ụ:  // Kh ởi gán giá trị cho 3 đối mặc định d3, d4 v à d5)   void f(int d1, float d2, char *d3=”HA NOI”,                int d4 = 100, double d5=3.14)   {  // Các câu l ệnh trong thân h àm  }  + Giá tr ị dùng đ ể khởi gán cho đối mặc đinh   Có th ể dùng các h ằng, các biến to àn bộ, các h àm đ ể khởi gán cho đối mặc định, ví dụ:   int MAX = 10000;   void f(int n, int m = MAX, int xmax = getmaxx(),   int ymax = getmaxy() ) ;   4.3.",LTHDT_PhamVanAt.pdf - Sentence 287
288,Cách s ử dụng h àm có đ ối mặc định   Lời gọi h àm c ần viết theo quy định sau:   Các tham s ố thiếu vắng trong lời gọi h àm ph ải tương ứng với các đối mặc định cuối c ùng (tính t ừ  trái sang ph ải).,LTHDT_PhamVanAt.pdf - Sentence 288
289,Nói cách khác: Đ ã dùng giá tr ị mặc định c ho m ột đối (tất nhi ên ph ải là đối mặc định) th ì cũng  phải sử dụng giá trị mặc định cho các đối c òn lại.,LTHDT_PhamVanAt.pdf - Sentence 289
290,"Ví dụ với h àm có 3 đ ối mặc định:   void f(int d1, float d2, char *d3=”HA NOI”,   int d4 = 100, double d5=3.14) ;  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          35                                         tenshi3003@gmail.com  Thì các l ời gọi sau l à đúng:   f(3,3.4,”ABC” ,10,1.0) ;  // Đ ầy đủ tham số   f(3,3.4,”ABC”) ;             // Thi ếu 2 tham số cuối   f(3,3.4) ;                        // Thi ếu 3 tham số cuối   Các l ời gọi sau l à sai:   f(3)  ;                  // Thi ếu tham số cho đối không mặc định d2   f(3,3.4, ,10) ;      //  Đã dùng giá tr ị mặc định cho d3, th ì cũng                                  //  ph ải dùng giá tr ị mặc định cho d4 v à d5  4.4.",LTHDT_PhamVanAt.pdf - Sentence 290
291,Các ví d ụ  Hàm ht (bên dư ới) d ùng đ ể hiển thị chuỗi ký tự dc tr ên n dòng màn hình.,LTHDT_PhamVanAt.pdf - Sentence 291
292,Các đối dc v à n đ ều có  giá tr ị mặc định.,LTHDT_PhamVanAt.pdf - Sentence 292
293,"#include <conio.h>   #include <iostream.h>   void ht(char *dc=""HA NOI"",int n=10) ;   void ht(char *dc , int n )   {  for (int i=0;i<n;++i)   cout << "" \n"" << dc;   }  void main()   {  ht();   // In dòng ch ữ “HA NOI” tr ên 10 dòng   ht(""ABC"",3);  // In dòng ch ữ “ABC” tr ên 3 dòng   ht(""DEF "");    // In dòng ch ữ “DEF” tr ên 10 dòng   getch();   }  Ví dụ dưới đây tr ình b ầy hàm hi ển thị một chuỗi str tr ên màn hình đồ hoạ, tại vị trí (x,y) v à có  mầu m.",LTHDT_PhamVanAt.pdf - Sentence 293
294,"Các đối x, y v à m là m ặc định.",LTHDT_PhamVanAt.pdf - Sentence 294
295,"D ùng các hàm getmaxx() và getmaxy() đ ể khởi gán cho x, y.",LTHDT_PhamVanAt.pdf - Sentence 295
296,Dùng h ằng RED gán cho m.,LTHDT_PhamVanAt.pdf - Sentence 296
297,"#include <conio.h>   #include <graphics.h>   void hiendc(char *str, int x=getmaxx()/2,    int y = getmaxy()/2, int m=RED);   void hiendc(char *str, int x,int y, int m)   {  int mau_ht = getcolor(); // Luu mau hien tai   setcolor(m);   outtextxy(x,y,str) ;   setcolor(mau_ht);  // Khoi phuc mau hien tai  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          36                                         tenshi3003@gmail.com  }  void main()   {  int mh=0, mode=0;   initgraph(&mh,&mode,"""");   setbkcolor(BLUE);   hiendc(""HELLO"");  // HELLO m ầu đỏ giữa m àn hình   hiendc(""CHUC MUNG"",1,1);  // CHUC MUNG m ầu đỏ tại vị   // trí (1,1)   hiendc(""CHAO"",1,400 ,YELLOW); // CHAO m ầu vàng t ại vị   // trí (1,400)   getch();   }  Ví dụ dưới đây tr ình b ầy hàm tính tích phân xác đ ịnh gồm 3 đối: f l à hàm c ần tính tích phân, a  và b là các c ận dưới và trên (a<b).",LTHDT_PhamVanAt.pdf - Sentence 297
298,"C ả 3 đối f, a v à b đ ều mặc định.",LTHDT_PhamVanAt.pdf - Sentence 298
299,"Giá trị mặc định của con trỏ h àm  f là đ ịa chỉ của h àm bp (bình ph ương), c ủa a bằng 0, của b bằng 1.",LTHDT_PhamVanAt.pdf - Sentence 299
300,"#include <conio.h>   #include <iostream.h>   #include <iomanip.h>   #include <math.h>   double bp(double x);   double tp( double (*f)(double)=bp,double a=0.0, double b=1.0) ;   double bp(double x)   {  return x*x;   }  double tp(double (*f)(double), double a, double b )   {  int n=1000;   double s=0.0, h=(b -a)/n;  for (int i=0; i<n ; ++i)   s+= f(a+i*h + h) + f(a+i*h ) ;   return s*h/2;   }  void main()   {  clrscr();   cout << setiosflags(ios::showpoint) << setprecision(2);   cout << "" \nTich phan tu 0 den 1 cua x*x= "" << tp() ;   cout << "" \nTich phan tu 0 den 1 cua exp(x)= "" << tp(exp);  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          37                                         tenshi3003@gmail.com  cout << "" \nTich phan tu 0 den PI/2 cua sin(x) "" <<   tp(sin,0,3.14/2);   getch();   }  5.",LTHDT_PhamVanAt.pdf - Sentence 300
301,Các hàm tr ực tuyến (inline)   5.1.,LTHDT_PhamVanAt.pdf - Sentence 301
302,"Ưu, như ợc điểm của h àm  Việc tổ chức ch ương tr ình thành các hàm có 2 ưu đi ểm r õ rệt :  Thứ nhất l à chia chương tr ình  thành các đơn v ị độc lập, l àm cho chương tr ình được tổ chức một cách khoa học dễ kiểm soát dễ  phát hi ện lỗi, dễ phát triển, mở rộng.",LTHDT_PhamVanAt.pdf - Sentence 302
303,"Thứ hai l à giảm đ ược kích th ước ch ương tr ình, vì m ỗi đoạn ch ương tr ình th ực hiện nhiệm vụ của  hàm đư ợc thay bằng một lời gọi h àm.",LTHDT_PhamVanAt.pdf - Sentence 303
304,"Tuy nhiên hàm c ũng có nh ược điểm l à làm ch ậm tốc độ ch ương tr ình do ph ải thực hiện một số  thao tác có tính t hủ tục mỗi khi gọi h àm như: C ấp phát v ùng nh ớ cho các đối v à biến cục bộ, truyền  dữ liệu của các tham số cho các đối, giải phóng v ùng nh ớ trước khi thoát khỏi h àm.",LTHDT_PhamVanAt.pdf - Sentence 304
305,Các hàm tr ực tuyến trong C++ cho khả năng khắc phục đ ược nh ược điểm nói tr ên.,LTHDT_PhamVanAt.pdf - Sentence 305
306,5.2.,LTHDT_PhamVanAt.pdf - Sentence 306
307,Các hàm t rực tuyến   Để biến một h àm thành tr ực tuyến ta viết th êm từ khoá   inline   vào trư ớc khai báo nguy ên m ẫu hàm.,LTHDT_PhamVanAt.pdf - Sentence 307
308,N ếu không d ùng nguyên m ẫu th ì viết từ khoá n ày trư ớc dòng  đầu tiên của định nghĩa h àm.,LTHDT_PhamVanAt.pdf - Sentence 308
309,"Ví d ụ:  inline float  f(int n, float x);   float f(int n, float x )  {  // Các câu l ệnh trong thân h àm  }   hoặc  inline float f(int n, float x)   {  // Các câu l ệnh trong thân h àm  }   Chú ý:  Trong m ọi trường hợp, từ khoá inline phải xuất hiện tr ước các lời gọi h àm thì Trình biên  dịch mới biết cần xử lý h àm theo ki ểu inline.",LTHDT_PhamVanAt.pdf - Sentence 309
310,"Ví dụ hàm f trong chương tr ình sau s ẽ không phải l à hàm tr ực tuyến v ì từ khoá inline viết sau lời  gọi hàm:  #include <conio.h>   #include <iostream.h>   void main()   {  int  s ;   s =  f(5,6);  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          38                                         tenshi3003@gmail.com  cout << s ;   getch();   }  inline int f(int a, int b)   {  return a*b;   }  Chú ý:  Trong C++ , n ếu hàm đư ợc xây dựng sau lời gọi h àm thì b ắt buộc phải  khai báo nguy ên  mẫu hàm trư ớc lời gọi.",LTHDT_PhamVanAt.pdf - Sentence 310
311,"Trong ví dụ tr ên, Trình biên d ịch C++ sẽ bắt lỗi v ì thiếu khai báo nguy ên  mẫu hàm f .",LTHDT_PhamVanAt.pdf - Sentence 311
312,5.3.,LTHDT_PhamVanAt.pdf - Sentence 312
313,"Cách biên d ịch h àm tr ực tuyến   Chương tr ình d ịch xử lý các hàm inline như các macro (đư ợc định nghĩa trong lệnh #define),  nghĩa là nó s ẽ thay mỗi lời gọi h àm b ằng một đoạn ch ương tr ình th ực hiện nhiệm vụ của h àm.",LTHDT_PhamVanAt.pdf - Sentence 313
314,"Cách  này làm cho chương tr ình dài ra, nh ưng t ốc độ ch ương tr ình tăng lên do không ph ải thực hiện các  thao tác có tính th ủ tục khi gọi h àm.",LTHDT_PhamVanAt.pdf - Sentence 314
315,5.4.,LTHDT_PhamVanAt.pdf - Sentence 315
316,"So sánh macro và hàm tr ực tuyến   Dùng macro và hàm tr ực tuyến đều dẫn đến hiệu quả t ương t ự, tuy nhi ên ngư ời ta thích d ùng  hàm tr ực tuyến h ơn, v ì cách này đảm bảo tính cấu trúc của ch ương tr ình, d ễ sử dụng v à tránh được  các sai sót l ặt vặt th ường gặp khi d ùng #define (như thi ếu các dấu ngoặc, dấu chấm phẩy)   5.5.",LTHDT_PhamVanAt.pdf - Sentence 316
317,Khi nào thì  nên dùng hàm tr ực tuyến   Phương án dùng hàm tr ực tuyến rút ngắn đ ược thời gian chạy máy nh ưng l ại làm tăng kh ối  lượng bộ nhớ ch ương tr ình (nh ất là đối với các h àm tr ực tuyến có nhiều câu lệnh).,LTHDT_PhamVanAt.pdf - Sentence 317
318,V ì vậy chỉ n ên  dùng phương án tr ực tuyến đối với các h àm nh ỏ.,LTHDT_PhamVanAt.pdf - Sentence 318
319,5.6.,LTHDT_PhamVanAt.pdf - Sentence 319
320,S ự hạn chế của Tr ình biên d ịch  Không ph ải khi gặp từ khoá inline l à Trình biên d ịch nhất thiết phải xử lý h àm theo ki ểu trực  tuyến.,LTHDT_PhamVanAt.pdf - Sentence 320
321,Chú ý  rằng từ khoá inline chỉ l à một sự gợi ý cho Tr ình biên d ịch chứ không phải l à một mệnh  lệnh bắt buộc.,LTHDT_PhamVanAt.pdf - Sentence 321
322,"Có m ột số h àm mà các Trình biên d ịch th ường không xử lý theo cách inline nh ư các hàm ch ứa  biến static, h àm ch ứa các lệnh chu tr ình ho ặc lệnh goto hoặc lệ nh switch, hàm đ ệ quy.",LTHDT_PhamVanAt.pdf - Sentence 322
323,Trong tr ường  hợp này từ khoá inline lẽ dĩ nhi ên bị bỏ qua.,LTHDT_PhamVanAt.pdf - Sentence 323
324,Thậm chí từ khoá inline vẫn bị bỏ qua ngay cả đối với các h àm không có nh ững hạn chế n êu trên  nếu nh ư Trình biên d ịch thấy cần thiết (ví dụ đ ã có quá nhi ều hàm inline làm cho  bộ nhớ ch ương  trình quá l ớn)  Ví dụ: Chương tr ình sau s ử dụng h àm inline tính chu vi và di ện tích của h ình ch ữ nhật:   Phương án 1:  Không khai báo nguyên m ẫu.,LTHDT_PhamVanAt.pdf - Sentence 324
325,Khi đó h àm dtcvhcn ph ải đặt tr ên hàm main.,LTHDT_PhamVanAt.pdf - Sentence 325
326,"#include <conio.h>   #include <iostream.h>   inline void  dt cvhcn(int a, int b, int &dt, int &cv)   {  dt=a*b;   cv=2*(a+b);  58 Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          39                                         tenshi3003@gmail.com  }  void main()   {  int a[20],b[20],cv[20],dt[20],n;   cout << "" \n So hinh chu hat: "" ;   cin >> n;   for (int i=1;i<=n;++i)   {  cout << "" \nNhap 2 canh cua hinh chu nhat thu "" <<i<< "": "";   cin >> a[i] >>  b[i]  ;  dtcvhcn(a[i],b[i],dt[i],cv[i]);   }  clrscr();   for (i=1;i<=n;++i)   {  cout << "" \n Hinh chu nhat thu "" << i << "" : "";   cout << "" \nDo dai 2 canh= "" << a[i] << "" va "" << b[i] ;   cout << "" \nDien tich= "" << dt[i] ;   cout << "" \nChu vi= "" << cv[i] ;   }  getch();   }  Phương án 2:  Sử dụng khai báo nguy ên m ẫu.",LTHDT_PhamVanAt.pdf - Sentence 326
327,Khi đó từ khoá inline đặt tr ước nguy ên m ẫu.,LTHDT_PhamVanAt.pdf - Sentence 327
328,Chú ý:  Không đư ợc đặt inline tr ước định nghĩa h àm.,LTHDT_PhamVanAt.pdf - Sentence 328
329,"Trong chương tr ình d ưới đây nếu đặt inline  trước định nghĩa h àm thì h ậu quả nh ư sau: Chương tr ình v ẫn dịch thông, nh ưng khi ch ạy th ì chương  trình b ị quẩn, không thoát đ ược.",LTHDT_PhamVanAt.pdf - Sentence 329
330,"#include <conio.h>   #include <iostream.h>   inline void  dtcvhcn(int a, int b, int &dt, int &cv) ;   void main()   {  int a[20],b[20],cv[20],dt[20],n;   cout << "" \n So hinh chu hat: "" ;   cin >> n;   for (int i=1;i<= n;++i)   {  cout << "" \nNhap 2 canh cua hinh chu nhat thu "" <<i<< "": "";   cin >> a[i] >>  b[i] ;   dtcvhcn(a[i],b[i],dt[i],cv[i]);   }  clrscr();  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          40                                         tenshi3003@gmail.com  for (i=1;i<=n;++i)   {  cout << "" \n Hinh chu nhat thu "" << i << "" : "";   cout << "" \nDo dai 2 canh= "" << a[i] << "" va "" << b[i]  ;  cout << "" \nDien tich= "" << dt[i] ;   cout << "" \nChu vi= "" << cv[i] ;   }  getch();   }  void  dtcvhcn(int a, int b, int &dt, int &cv)   {  dt=a*b;   cv=2*(a+b);   }  6.",LTHDT_PhamVanAt.pdf - Sentence 330
331,Định nghĩa chồng các h àm (Overloading)   6.1.,LTHDT_PhamVanAt.pdf - Sentence 331
332,Khái ni ệm về định nghĩa chồng   Định nghĩa chồng (hay c òn gọi sự tải bội) các h àm là dùng cùng m ột tên để định nghĩa các h àm  khác nhau.,LTHDT_PhamVanAt.pdf - Sentence 332
333,Đây là m ột mở rộng rất có ý nghĩa của C++.,LTHDT_PhamVanAt.pdf - Sentence 333
334,"Như đ ã biết, trong C v à các ngôn  ngữ khác (nh ư PASCAL, FOXPRO,...) m ỗi hàm đ ều phải có  một tên phân bi ệt.",LTHDT_PhamVanAt.pdf - Sentence 334
335,"Đôi khi đây l à một sự hạn chế lớn, v ì phải dùng nhi ều hàm khác nhau đ ể thực  hiện cùng m ột công việc.",LTHDT_PhamVanAt.pdf - Sentence 335
336,"Ví dụ để lấy giá trị tuyệt đối trong C cần d ùng t ới 3 h àm khác nhau:   int abs(int i);  // L ấy giá trị tuyệt đối giá trị kiểu int   longt labs(longt l);  // L ấy giá trị tuyệt đối giá trị kiểu long   double fabs(double d); // L ấy giá trị tuyệt đối giá trị kiểu double   Nhờ khả năng định nghĩa chồng, trong C++ có thể d ùng chung m ột tên cho c ả 3 hàm trên như  sau:  int abs(int i) ;   // L ấy giá trị tuyệt đối giá trị kiểu int   longt abs(longt l) ;   // L ấy giá trị tuyệt đối giá trị kiểu long   double abs(double d) ; // L ấy giá trị tuyệt đối giá trị kiểu double   6.2.",LTHDT_PhamVanAt.pdf - Sentence 336
337,"Yêu c ầu về các h àm đ ịnh nghĩa chồng   Khi dùng cùng m ột tên để định nghĩa nhiều h àm, Trình biên d ịch C++ sẽ dựa v ào sự khác nhau  về tập đối của các h àm này đ ể đổi t ên các hàm.",LTHDT_PhamVanAt.pdf - Sentence 337
338,"Như v ậy, sau khi bi ên dịch mỗi h àm s ẽ có một t ên  khác nhau.",LTHDT_PhamVanAt.pdf - Sentence 338
339,Từ đó cho thấy: các h àm đư ợc định nghĩa tr ùng tên ph ải có tậ p đối khác nhau (về số l ượng hoặc  kiểu).,LTHDT_PhamVanAt.pdf - Sentence 339
340,Nếu 2 h àm hoàn toàn trùng tên và trùng đ ối th ì Trình biên d ịch sẽ không có cách n ào phân  biệt được.,LTHDT_PhamVanAt.pdf - Sentence 340
341,Ngay cả khi 2 h àm này có ki ểu khác nhau th ì Trình biên d ịch vẫn báo lỗi.,LTHDT_PhamVanAt.pdf - Sentence 341
342,"Ví dụ sau xây  dựng 2 h àm cùng có tên là f và cùng có m ột đối nguy ên a, nhưng ki ểu hàm khác nhau.",LTHDT_PhamVanAt.pdf - Sentence 342
343,"Hàm th ứ  nhất kiểu nguy ên (tr ả về a*a), h àm th ứ hai kiểu void (in giá trị a).",LTHDT_PhamVanAt.pdf - Sentence 343
344,"Ch ương tr ình s ẽ bị thông báo lỗi  khi biên d ịch (bạn h ãy th ử xem sao)   #include <conio.h>   #include <iostream.h>   int f(int a);  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          41                                         tenshi3003@gmail.com  void f(int a);   int f(int a)   {  return a*a;   }   void f(int a)   {  cout << "" \n "" << a ;   }  void main()   {  int b=f(5);   f(b);  getch();   }  6.3.",LTHDT_PhamVanAt.pdf - Sentence 344
345,"S ử dụng các h àm đ ịnh nghĩa chồng   Khi g ặp một lời gọi, Tr ình biên d ịch sẽ căn cứ v ào số lượng v à kiểu của các tham số để gọi hàm  có đúng tên và đúng b ộ đối số t ương ứng.",LTHDT_PhamVanAt.pdf - Sentence 345
346,"Ví dụ:   abs(123); // Tham s ố kiểu int, gọi h àm int abs(int i) ;   abs(123L); // Tham s ố kiểu long, gọi h àm long abs(long l);   abs(3.14); //Tham s ố kiểu double, gọi h àm double abs(double d);   Khi không có hàm nào có bộ đối c ùng ki ểu với bộ tham số (trong lời gọi), th ì Trình biên d ịch sẽ  chọn hàm nào có b ộ đối gần kiểu nhất (phép chuyển kiểu dễ d àng nh ất).",LTHDT_PhamVanAt.pdf - Sentence 346
347,"Ví dụ:   abs(‘A’) ;    // Tham s ố kiểu char, gọi h àm int abs(int i) ;   abs(3.14F); // Tham s ố kiểu float, gọi h àm dou ble abs(double d);   6.4.",LTHDT_PhamVanAt.pdf - Sentence 347
348,"Nên s ử dụng phép định nghĩa chồng các h àm như th ế nào  Như đ ã nói ở trên, khi xây d ựng cũng nh ư sử dụng các h àm trùng tên, Trình biên d ịch C++ đ ã  phải suy đoán v à giải quyết nhiều tr ường hợp khá nhập nhằng.",LTHDT_PhamVanAt.pdf - Sentence 348
349,"V ì vậy không n ên lạm dụng quá  đáng kh ả năng định nghĩa chồng, v ì điều đó l àm cho chương tr ình khó ki ểm soát v à dễ dẫn đến sai  sót.",LTHDT_PhamVanAt.pdf - Sentence 349
350,Vi ệc định nghĩa chồng sẽ hiệu quả h ơn nếu được sử dụng theo các lời khuy ên sau:   + Ch ỉ nên định nghĩa chồng các h àm th ực hiện những công việc nh ư nhau n hưng trên các đ ối  tượng có kiểu khác nhau.,LTHDT_PhamVanAt.pdf - Sentence 350
351,"Ví dụ trong ch ương tr ình c ần xây dựng các h àm: c ộng 2 ma trận vuông  kiểu double, cộng 2 ma trận vuông kiểu int, cộng 2 ma trân chữ nhật kiểu double, cộng 2 ma trận  chữ nhật kiểu int, th ì 4 hàm trên nên định nghĩa chồng (đặt c ùng tên).",LTHDT_PhamVanAt.pdf - Sentence 351
352,+ Nên dùng các phép chuy ển kiểu (nếu cần) để bộ tham số trong lời gọi ho àn toàn trùng ki ểu với  bộ đối số của một h àm đư ợc định nghĩa chồng.,LTHDT_PhamVanAt.pdf - Sentence 352
353,V ì như thế mới tránh đ ược sự nhập nhằng cho Tr ình  biên d ịch v à Trình biên d ịch sẽ chọn đúng h àm cần gọi.,LTHDT_PhamVanAt.pdf - Sentence 353
354,6.5.,LTHDT_PhamVanAt.pdf - Sentence 354
355,"L ấy địa chỉ các h àm trùng tên   Giả sử có 4 h àm đ ều có t ên là tinh_max đư ợc khai báo nh ư sau:   int tinh_max(int a, int b, int c) ;   // Max c ủa 3 số nguy ên  double tinh_max(double a, double b, double c); // Max c ủa 3 số // thực  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          42                                         tenshi3003@gmail.com  int tinh_max(int  *a, int n) ;  // Max c ủa một dẫy số nguy ên  double tinh_max(double *a, int n) ;  //Max c ủa một dẫy số thực   Vấn đề đặt ra l à làm th ế nào lấy được địa chỉ của mỗi h àm.",LTHDT_PhamVanAt.pdf - Sentence 355
356,"Câu tr ả lời nh ư sau:   Để lấy địa chỉ của một h àm, ta khai báo m ột con trỏ h àm có ki ểu và bộ đối nh ư hàm c ần lấy địa  chỉ.",LTHDT_PhamVanAt.pdf - Sentence 356
357,Sau đó gán t ên hàm cho con tr ỏ hàm.,LTHDT_PhamVanAt.pdf - Sentence 357
358,"Ví d ụ:  int  (*f1)(int , int, int );   f1 = tinh_max ;            // L ấy địa chỉ của h àm th ứ nhất   double   (*f2)(double , double, double);   f2 = tinh_max ;            // L ấy địa chỉ của h àm th ứ hai  int  (*f3)(int *, int  );   f3 = tinh_max ;            // L ấy địa chỉ của h àm th ứ ba  double  (*f4)(double *, int  );   f4 = tinh_max ;            // L ấy địa chỉ của h àm th ứ tư   6.6.",LTHDT_PhamVanAt.pdf - Sentence 358
359,Các ví d ụ  Ví d ụ 1: Chương tr ình gi ải bài toán tìm max c ủa một dẫy số nguy ên và max c ủa một dẫy số  thực.,LTHDT_PhamVanAt.pdf - Sentence 359
360,Trong ch ươmg tr ình có 6 hàm.,LTHDT_PhamVanAt.pdf - Sentence 360
361,Hai hàm dùng để nhập dẫy số nguy ên và d ẫy số thực có t ên  chung là nhapds.,LTHDT_PhamVanAt.pdf - Sentence 361
362,"B ốn hàm: tính max 2 s ố nguy ên, tính max 2 s ố thực, tính max của dẫy số nguy ên,  tính max c ủa dẫy số thực đ ược đặt chung một tên là max.",LTHDT_PhamVanAt.pdf - Sentence 362
363,"#include <conio.h>   #include <iostream.h>   #include <iomanip.h>   void nhapds(int *x, int n);   void nhapds(double *x, int n);   int max(int x, int y);   double max(double x, double y);   int max(int *x, int n);   double max(double *x, int n);   void nhapds(in t *x, int n)   {  for (int i=1;i<=n;++i)   {  cout << ""Phan tu "" << i << ""  =  "" ;   cin >> x[i] ;   }  }  void nhapds(double *x, int n)   {  for (int i=1;i<=n;++i)   {  cout << ""Phan tu "" << i << ""  =  "" ;   cin >> x[i] ;   }  } Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          43                                         tenshi3003@gmail.com  int max(int x, int y)   {  return x>y?x:y ;   }  double   max(double  x, double y)   {  return x>y?x:y ;   }  int max(int *x, int n)   {  int s=x[1];   for (int i=2;i<=n;++i)   s = max(s,x[i]);   return s;   }  double max(double *x, int n)   {  double s=x[1];   for (int i=2;i<=n;++i)   s = max(s,x[i]);   return s;   }  void main()   {  int a[2 0] , n , ni, nd, maxi ;   double x[20] , maxd ;   clrscr();   cout << "" \nSo phan tu nguyen ni = "" ;   cin >> ni ;   cout << ""Nhap day so nguyen \n "" ;  nhapds(a,ni);   cout << "" \nSo phan tu thuc nd = "" ;   cin >> nd ;   cout << ""Nhap day so thuc \n "" ;  nhapds(x,nd);   maxi = m ax(a,ni);   maxd = max(x,nd);   cout << "" \nMax cua day nguyen = "" << maxi ;   cout << "" \nMax cua day thuc   = "" << maxd ;   getch();  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          44                                         tenshi3003@gmail.com  }  Ví dụ 2:   Chương tr ình sau th ực hiện phép nhân ma trận:   D =  A*B*C   trong đó A, B là các ma tr ận vuông, C l à ma tr ận chữ nhật.",LTHDT_PhamVanAt.pdf - Sentence 363
364,"Tro ng chương tr ình có 3 c ặp hàm  trùng  tên đ ể thực hiện 3 nhiệm vụ (nh ưng trên 2 đ ối tượng khác nhau l à ma tr ận vuông v à chữ nhật):  Nhập ma trận, nhân 2 ma trận v à in ma trân.",LTHDT_PhamVanAt.pdf - Sentence 364
365,"#include <conio.h>   #include <iostream.h>   #include <iomanip.h>   typedef int MT[20][20 ];  void nhapmt(MT a,char *ten, int m, int n);   void inmt(MT a,char *ten, int m, int n);   void nhanmt(MT a,MT b, MT c, int m, int n, int p);   void nhapmt(MT a,char *ten, int n);   void inmt(MT a,char *ten, int n);   void nhanmt(MT a,MT b, MT c, int n);   void nhapmt (MT a, char *ten, int m, int n)   {  for (int i=1;i<=m;++i)   for (int j=1;j<=n;++j)   {  cout << "" \n"" << ten <<""["" << i << "","" << j << ""]= "" ;   cin >> a[i][j];   }  }  void nhapmt(MT a,char *ten, int n)   {  nhapmt(a,ten,n,n) ;   }  void inmt(MT a,char *ten, int m, int n)   {  cout << "" \nMa tran: "" << ten;   for (int i=1;i<=m;++i)   {  cout << "" \n"" ;  for (int j=1;j<=n;++j)   cout << setw(6) <<  a[i][j];   }  }  void inmt(MT a,char *ten, int n)  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          45                                         tenshi3003@gmail.com  {  inmt(a,ten,n,n) ;   }  void nhanmt(MT a,MT b, MT c, int m, int n, int p)   {  for (int i=1;i<=m;++i)   for (int j=1;j<=p;++j)   {  c[i][j]=0;   for (int k=1;k<=n;++k)   c[i][j] += a[i][k] * b[k][j];   }  }  void nhanmt(MT a,MT b, MT c, int n)   {  nhanmt(a,b,c,n,n, n) ;   }  void main()   {  MT a,b,c,d; // d= abc   MT  u;   clrscr();   nhapmt(a,""A"",2);   nhapmt(b,""B"",2);   nhapmt(c,""C"" ,2,3);   nhanmt(a,b,u,2);   nhanmt(u,c,d,2,2,3);   inmt(a,""A"",2);   inmt(b,""B"",2);   inmt(u,""U = A*B"",2);   inmt(c,""C"",2,3);   inmt(d,""D = U*C"",2,3);   getch();   }  7.",LTHDT_PhamVanAt.pdf - Sentence 365
366,Định nghĩa chồng các toán tử   7.1.,LTHDT_PhamVanAt.pdf - Sentence 366
367,Các phép toán trong C và C++   Trong C và C++ có khá nhi ều các phép toán dùng đ ể thực hiện các thao tác tr ên các ki ểu dữ liệu  chuẩn.,LTHDT_PhamVanAt.pdf - Sentence 367
368,"Ví dụ các phép số học: +  -  *  /    áp d ụng cho các kiểu dữ liệu nguy ên, th ực.",LTHDT_PhamVanAt.pdf - Sentence 368
369,Phép lấy phần  dư % áp d ụng đối với kiểu nguy ên.,LTHDT_PhamVanAt.pdf - Sentence 369
370,7.2.,LTHDT_PhamVanAt.pdf - Sentence 370
371,"Th ực hiện các phép toán tr ên các ki ểu dữ liệu không chuẩn trong  C  Việc thực hiện các phép toán tr ên các đ ối tượng tự định nghĩa (nh ư mảng, cấu trúc) l à nhu c ầu  bắt buộc của thực tế.",LTHDT_PhamVanAt.pdf - Sentence 371
372,"Chẳng hạn cần thực hiện các phép số học tr ên số phức, tr ên phân s ố, trên đa Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          46                                         tenshi3003@gmail.com  thức, tr ên véc tơ, trên ma tr ận.",LTHDT_PhamVanAt.pdf - Sentence 372
373,"Để đáp ứng y êu cầu này, ta s ử dụng các h àm trong C.",LTHDT_PhamVanAt.pdf - Sentence 373
374,"Ví d ụ sau đây  là một ch ương tr ình C g ồm các h àm nh ập phân số, in phân số v à thực hiện các phép cộng trừ nhân  chia phân s ố.",LTHDT_PhamVanAt.pdf - Sentence 374
375,"Ch ương tr ình s ẽ nhập 5 phân số: p, q, z, u, v v à tính phân s ố s theo công thức:   s = (p – q*z)/(u + v)   #includ e <conio.h>   #include <stdio.h>   #include <math.h>   typedef struct   {  int a,b;   } PS;   void nhap(PS *p);   void in(PS p);   int uscln(int x, int y);   PS rutgon(PS p);   PS cong(PS p1, PS p2);   PS tru(PS p1, PS p2);   PS nhan(PS p1, PS p2);   PS chia(PS p1, PS p2);   void nhap (PS *p)   {  int t, m;   printf("" \nTu va mau: "");   scanf(""%d%d"", &t, &m);   p->a = t; p ->b = m;   }  void in(PS p)   {  printf(""  %d/%d"",p.a,p.b);   }  int uscln(int x, int y)   {  x=abs(x); y=abs(y);   if (x*y==0) return 1;   while (x!=y)   if (x>y) x -=y;  else  y -=x;  return x;   }  PS rutgon(PS p)   { Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          47                                         tenshi3003@gmail.com  PS q;   int x;   x=uscln(p.a,p.b);   q.a = p.a / x ;   q.b = p.b / x ;   return q;   }  PS cong(PS p1, PS p2)   {  PS q;   q.a = p1.a*p2.b + p2.a*p1.b;   q.b = p1.b * p2.b ;   return rutgon(q);   }  PS tru(PS p1, PS p2)   {  PS q;   q.a = p1.a*p2.b - p2.a*p1.b;   q.b = p 1.b * p2.b ;   return rutgon(q);   }  PS nhan(PS p1, PS p2)   {  PS q;   q.a = p1.a * p2.a ;   q.b = p1.b * p2.b ;   return rutgon(q);   }  PS chia(PS p1, PS p2)   {  PS q;   q.a = p1.a * p2.b ;   q.b = p1.b * p2.a ;   return rutgon(q);   }  void main()   {  PS p, q, z, u, v ;   PS tu,mau,  s; Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          48                                         tenshi3003@gmail.com  printf("" \n Nhap phan so p: ""); nhap(&p);   printf("" \n Nhap phan so q: "");nhap(&q);   printf("" \n Nhap phan so z: "");nhap(&z);   printf("" \n Nhap phan so u: "");nhap(&u);   printf("" \n Nhap phan so v: "");nhap(&v);   tu = nhan(q,z);   tu = tru(p,tu)  ;   mau = cong(u,v) ;   s = chia(tu,mau);   printf(“ \n Phan so s = “);  in(s);   getch();   }  Nhận xét:  Việc sử dụng các h àm đ ể thực hiện các phép tính không đ ược tự nhi ên và t ỏ ra d ài  dòng.",LTHDT_PhamVanAt.pdf - Sentence 375
376,Ví d ụ để thực hiện một công thức   s = (p - q*z)/(u + v)   phải dùng 2 bi ến trung gian v à 4 l ời gọi hàm.,LTHDT_PhamVanAt.pdf - Sentence 376
377,"Câu h ỏi đặt ra l à có cách nào đ ể chỉ cần viết đúng  công th ức toán học, m à vẫn nhận đ ược kết quả mong muốn hay không?",LTHDT_PhamVanAt.pdf - Sentence 377
378,"Trong C++ có th ể đáp ứng đ ược mong muốn n ày bằng cách sử dụng các phép toán chuẩn của nó  cho các ki ểu dữ liệu tự định nghĩa (mảng , cấu trúc, ...).",LTHDT_PhamVanAt.pdf - Sentence 378
379,"Nói cách khác C++ cho phép d ùng các phép  toán đ ể định nghĩa các h àm, mà ta thư ờng gọi l à định nghĩa chồng các toán tử (hay c òn gọi: Sự tải  bội các toán tử).",LTHDT_PhamVanAt.pdf - Sentence 379
380,7.3.,LTHDT_PhamVanAt.pdf - Sentence 380
381,"Cách đ ịnh nghĩa chồng các toán tử   7.3.1.Tên hàm toán t ử:  Gồm từ khoá operat or và  tên phép toán, ví d ụ:  operator+         (đ ịnh nghĩa chồng phép +)   operator -          (định nghĩa chồng phép -)  7.3.2.",LTHDT_PhamVanAt.pdf - Sentence 381
382,Các đ ối của h àm toán t ử:  a.,LTHDT_PhamVanAt.pdf - Sentence 382
383,"Với các phép toán có 2 toán hạng , thì hàm toán t ử cần có 2 đối.",LTHDT_PhamVanAt.pdf - Sentence 383
384,"Đối thứ nhất ứng với toán  hạng thứ nhất , đối thứ hai ứng với toán hạng thứ hai.",LTHDT_PhamVanAt.pdf - Sentence 384
385,"Do vậy, với các phép toán không giao hoán  (như phép -) thì  th ứ tự đối l à rất quan trọng.",LTHDT_PhamVanAt.pdf - Sentence 385
386,"Ví dụ các hàm toán t ử cộng , trừ phân số đ ược khai báo nh ư sau:   struct  PS   {  int a;    // T ử số  int b;   // M ẫu số   } ;     PS   operator+(PS p1, PS p2);   //  p1 + p2   PS   operator -(PS p1, PS p2);    // p1 - p2  PS   operator*(PS p1, PS p2);   //  p1 * p2   PS   operator/(PS p1, PS p2);    // p1 / p2   b.",LTHDT_PhamVanAt.pdf - Sentence 386
387,"Với các phép toán có một toán hạng,  thì hàm toán t ử có một đối.",LTHDT_PhamVanAt.pdf - Sentence 387
388,Ví dụ h àm toán t ử đổi dấu  ma tr ận (đổi dấu tất cả các phần tử của ma trận) đ ược khai báo nh ư sau:  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          49                                         tenshi3003@gmail.com  struct   MT   {  double a[20][20] ;  // M ảng chứa các phần tử ma trận   int m ;  // S ố hàng ma tr ận  int n  ;  // S ố cột ma trân   } ;  MT  operator -(MT x) ;   7.3.3.,LTHDT_PhamVanAt.pdf - Sentence 388
389,Thân c ủa h àm toán t ử: Viết nh ư thân c ủa hàm thông thư ờng.,LTHDT_PhamVanAt.pdf - Sentence 389
390,Ví dụ h àm đ ổi dấu ma trận  có th ể được định nghĩa nh ư sau:   struct  MT   {  double a[20][20] ;  // M ảng chứa các phần tử ma trận   int m ;  // S ố hàng ma tr ận  int n  ;  // S ố cột ma trân   } ;  MT  operator -(MT x)   {  MT   y;   for (int i=1; i<= m ;++i)   for (int j=1; j<= n ;++j)   y[i][j] = - x[i][j] ;   return y;   }  7.4.,LTHDT_PhamVanAt.pdf - Sentence 390
391,Cách dùng hàm toán t ử  Có 2 cách dùng:   Cách 1:  Dùng như m ột hàm thông thư ờng bằng cách viết lời gọi.,LTHDT_PhamVanAt.pdf - Sentence 391
392,"Ví dụ:  PS  p, q, u, v ;   u = operator+(p, q) ;   // u = p + q   v = o perator -(p, q) ;   // v = p - q  Cách 2:  Dùng như phép toán c ủa C++ .",LTHDT_PhamVanAt.pdf - Sentence 392
393,"Ví dụ:  PS  p, q, u, v ;   u = p +  q  ;   // u = p + q   v = p -  q  ;    // v = p - q  Chú ý: Khi dùng các hàm toán t ử như phép toán c ủa C++ ta có thể kết hợp nhiều phép toán để  viết các cô ng th ức phức tạp.",LTHDT_PhamVanAt.pdf - Sentence 393
394,Cũng cho phép d ùng d ấu ngoặc tr òn để quy định thứ tự thực hiện các  phép tính.,LTHDT_PhamVanAt.pdf - Sentence 394
395,Th ứ tự ưu tiên c ủa các phép tính vẫn tuân theo các quy tắc ban đầu của C++ .,LTHDT_PhamVanAt.pdf - Sentence 395
396,"Chẳng hạn  các phép * và / có th ứ ưu tiên cao hơn so v ới các phép + v à -   Ví dụ: Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          50                                         tenshi3003@gmail.com  PS  p, q, u, v, s1, s2 ;   s1 =  p*q - u/v ;  // s1 = (p*q)   s2 = (p - q)/(u + v) ; // s2 = (p - q)/(u + v)   § 8.",LTHDT_PhamVanAt.pdf - Sentence 396
397,"Các ví  d ụ về định nghĩa chồng toán tử   Ví dụ 1: Trong ví d ụ này ngoài vi ệc sử dụng các h àm toán t ử để thực hiện 4 phép tính tr ên phân  số, còn định nghĩa chồng các phép toán << v à >> đ ể xuất v à nhập phân số (xem chi tiết trong  chương 7).",LTHDT_PhamVanAt.pdf - Sentence 397
398,Hàm  operator<< có 2 đ ối kiểu ostream& v à PS (Phân s ố).,LTHDT_PhamVanAt.pdf - Sentence 398
399,H àm tr ả về giá trị kiểu ostream&.,LTHDT_PhamVanAt.pdf - Sentence 399
400,"Hàm đư ợc khai báo nh ư sau:   ostream& operator<< (ostream& os, PS p);   Tượng tự  hàm operator>> đư ợc khai báo nh ư sau:   istream&  operator>> (istream&  is,PS &p);   Dưới đây sẽ chỉ ra cách xây dựng v à sử dụng các h àm toán t ử.",LTHDT_PhamVanAt.pdf - Sentence 400
401,"Chúng ta cũng sẽ thấy việc sử  dụng các h àm toán t ử rất tự nhi ên, ng ắn gọn v à tiện lợi.",LTHDT_PhamVanAt.pdf - Sentence 401
402,"Chương tr ình d ưới đây có nội dung nh ư chương tr ình trong §6.2, nhưng thay các hàm b ằng các  hàm toán t ử.",LTHDT_PhamVanAt.pdf - Sentence 402
403,"#include <conio.h>   #include <iostream.h>   #include <math.h>   typedef struct   {  int a,b;   } PS;   ostream& operator<< (ostream& os, PS p);   istream&  operator>> (istream&  is,PS &p);   int uscln(int x, int y);   PS rutgon(PS p);   PS operator+(PS p1, PS p2);   PS operator -(PS p1, PS p2);   PS operator*(PS p1, PS p2);   PS operator/(PS p1, PS p2);   ostream& operator<< (ostream& os, PS p)   {  os << p.a << '/' << p.b ;   return os;   }  istream&  operator>> (i stream&  is,PS &p)   {  cout << ""Nhap tu va mau: "" ;   is >> p.a >> p.b ;   return is;  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          51                                         tenshi3003@gmail.com  }  int uscln(int x, int y)   {  x=abs(x); y=abs(y);   if (x*y==0) return 1;   while (x!=y)   if (x>y) x -=y;  else    y -=x;  return x;   }  PS rutgon(PS p)   {  PS q;   int x;   x=uscln(p.a,p.b);   q.a = p.a / x ;   q.b = p.b / x ;   return q;   }  PS operator+(PS p1, PS p2)   {  PS q;   q.a = p1.a*p2.b + p2.a*p1.b;   q.b = p1.b * p2.b ;   return rutgon(q);   }  PS operator -(PS p1, PS p2)   {  PS q;   q.a = p1.a*p2.b - p2.a*p1.b;   q.b = p1.b * p2.b ;   return rutgon(q);   }  PS oper ator*(PS p1, PS p2)   {  PS q;   q.a = p1.a * p2.a ;   q.b = p1.b * p2.b ;   return rutgon(q);   }  PS operator/(PS p1, PS p2)   {  PS q;  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          52                                         tenshi3003@gmail.com  q.a = p1.a * p2.b ;   q.b = p1.b * p2.a ;   return rutgon(q);   }  void main()   {  PS p, q, z, u, v ;   PS  s;   cout <<"" \nNhap cac PS p, q, z, u,  v:\n "" ;  cin >> p >> q >> z >> u >> v ;   s = (p - q*z) / (u + v) ;   cout << "" \n Phan so s = "" << s;   getch();   }  Ví dụ 2: Chương tr ình đưa vào các hàm toán t ử:  operator -    có m ột đối d ùng đ ể đảo dấu một đa thức   operator+   có 2 đ ối dùng đ ể cộng 2 đa thức   operator -    có 2 đ ối dùng đ ể trừ 2 đa thức   operator*    có 2 đ ối dùng đ ể nhân 2 đa thức   operator^    có 2 đ ối dùng đ ể tính giá đa thức tại x   operator<<  có 2 đ ối dùng đ ể in đa thức   operator>>  có 2 đ ối dùng đ ể nhập đa thức   Chương tr ình s ẽ nhập 4 đa thức: p, q, r, s.",LTHDT_PhamVanAt.pdf - Sentence 403
404,"Sau đó tính đa th ức:  f = -(p+q)*(r -s)  Cuối cùng tính giá tr ị f(x), với x l à một số thực nhập từ b àn phím.",LTHDT_PhamVanAt.pdf - Sentence 404
405,"#include <conio.h>   #include <iostream.h>   #include <math.h>   struct  DT   {  double a[20]; // Mang chua cac he so da thuc a0, a1,...",LTHDT_PhamVanAt.pdf - Sentence 405
406,"int n ; // Ba c da thuc   } ;  ostream& operator<< (ostream& os, DT d);   istream&  operator>> (istream&  is,DT &d);   DT operator -(const DT& d);   DT operator+(DT d1, DT d2);   DT operator -(DT d1, DT d2);   DT operator*(DT d1, DT d2);   double operator^(DT d, double x); // Tinh gia t ri da thuc  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          53                                         tenshi3003@gmail.com  ostream& operator<< (ostream& os, DT d)   {  os << "" - Cac he so (tu ao): "" ;   for (int i=0 ; i<= d.n ; ++i)   os <<  d.a[i] <<"" "" ;   return os;   }  istream&  operator>> (istream&  is, DT &d)   {  cout << "" - Bac da thuc: "" ;   cin >> d.n;   cout << ""Nhap cac h e so da thuc: \n"" ;  for (int i=0 ; i<= d.n ; ++i)   {  cout << ""He so bac "" << i << "" = ""  ;   is >> d.a[i] ;   }  return is;   }  DT operator -(const DT& d)   {  DT p;   p.n = d.n;   for (int i=0 ; i<=d.n ; ++i)   p.a[i] = -d.a[i];   return p;   }  DT operator+(DT d1, DT d2)   {  DT d ;  int k,i;   k = d1.n > d2.n ?",LTHDT_PhamVanAt.pdf - Sentence 406
407,"d1.n : d2.n ;   for (i=0; i<=k ; ++i)   if (i<=d1.n && i<=d2.n)   d.a[i] = d1.a[i] + d2.a[i];   else if (i<=d1.n)   d.a[i] = d1.a[i];   else  d.a[i] = d2.a[i];   i=k;  while (i>0 && d.a[i]==0.0) --i;  d.n = i;   return d ;  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          54                                         tenshi3003@gmail.com  }  DT operator -(DT d1, D T d2)   {  return (d1 + ( -d2));   }  DT operator*(DT d1, DT d2)   {  DT d;   int k, i, j;   k = d.n = d1.n + d2.n ;   for (i=0; i<=k; ++i) d.a[i] = 0;   for (i=0 ; i<= d1.n ; ++i)   for (j=0 ; j<= d2.n ; ++j)   d.a[i+j] += d1.a[i]*d2.a[j] ;   return d;   }  double operator^(DT d, d ouble x)   {  double s=0.0 , t=1.0;   for (int i=0 ; i<= d.n ; ++i)   {  s += d.a[i]*t;   t *= x;   }  return s;   }  void main()   {  DT p,q,r,s,f;   double x,g;   clrscr();   cout <<"" \nNhap da thuc P "" ; cin >> p;   cout <<"" \nNhap da thuc Q "" ; cin >> q;   cout <<"" \nNhap da thuc R ""  ; cin >> r;   cout <<"" \nNhap da thuc S "" ; cin >> s;   cout << "" \nNhap so thuc x: "" ; cin >> x;   f = -(p+q)*(r -s);  g = f^x;   cout << "" \nDa thuc f "" << f ;  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          55                                         tenshi3003@gmail.com  cout  << "" \n x = "" << x;   cout << "" \nf(x) = "" << g;   getch();   }  § 9.",LTHDT_PhamVanAt.pdf - Sentence 407
408,Các bài toán v ề ma trận v à véc tơ   Tron g mục này sẽ xét các ma trận thực vuông cấp n v à các véc tơ th ực cấp n.,LTHDT_PhamVanAt.pdf - Sentence 408
409,"Chúng đ ược biểu  diễn thông qua các kiểu cấu trúc MT v à VT:   struct  MT   {  double a[20][20] ;  // Mang a ch ứa các phần tử ma trận   int  n ;                    // C ấp ma trận   } ;  struct VT   {  double b[20]; // Mang chua cac phan tu cua vec to   int n ; // Cap vec to   } ;  Để xử lý ma trận v à véc tơ, chúng ta xây d ựng 9 h àm toán t ử:   ostream& operator<< (ostream& os, const MT& x); // In ma tr ận  ostream& operator<< (ostream& os, const VT& v);  // In  véc tơ   istream&  operator>> (istream&  is,MT& x);         // Nh ập ma trận   istream&  operator>> (istream&  is, VT &v);         // Nh ập véc t ơ   MT operator+(const MT& x1, const MT& x2);   // C ộng 2 ma trận   MT operator -(const MT& x1, const MT& x2);     // Tr ừ 2 ma trận   MT operator*(const MT& x1, const MT& x2);   // Nhân 2 ma tr ận  VT operator*(const MT& x, const VT& v); // Nhân ma tr ận véc t ơ  MT operator!(MT x);                                   // Ngh ịch đảo ma trận   Thuật toán cho 8 h àm toán t ử đầu t ương đ ối quen thu ộc không có g ì phải bàn.",LTHDT_PhamVanAt.pdf - Sentence 409
410,"Đ ể nghịch đảo ma  trận có nhiều cách, ở đây chúng ta  d ùng phương pháp Jordance như sau.",LTHDT_PhamVanAt.pdf - Sentence 410
411,Gi ả sử cần nghịch đảo ma  trận x cấp n.,LTHDT_PhamVanAt.pdf - Sentence 411
412,Ta d ùng thêm ma tr ận đơn vị y.,LTHDT_PhamVanAt.pdf - Sentence 412
413,Sau đó thực hiện đồng thời các phép tính tr ên cả x v à y  sao cho x  trở thành đơn v ị.,LTHDT_PhamVanAt.pdf - Sentence 413
414,Kết quả y chính l à ngh ịch đảo của x.,LTHDT_PhamVanAt.pdf - Sentence 414
415,Thuật toán đ ược tiến h ành trên n  bước.,LTHDT_PhamVanAt.pdf - Sentence 415
416,"Nội dung của b ước k (k = 1,...,n) nh ư sau:   Tìm ch ỉ số r  ( k <= r <= n) sao cho   abs(x[r,k]) = max { abs(x[i,k]  v ới  i = k,...,n }   Nếu abs(x[r,k]) = 0 th ì ma tr ận không có ngh ịch đảo v à thu ật toán kết thúc giữa chừng.",LTHDT_PhamVanAt.pdf - Sentence 416
417,Hoán v ị hàng k v ới hàng r trong c ả 2 ma trận x v à y.,LTHDT_PhamVanAt.pdf - Sentence 417
418,"Chia hàng k c ủa cả x v à y cho tg = x[k,k]  (m ục đích l àm cho x[k,k] = 1).",LTHDT_PhamVanAt.pdf - Sentence 418
419,"Biến đổi để cột k của x tr ơ thành véc tơ đơn v ị bằng cách l àm cho các ph ần tử x[i,k]  = 0 (với i  khác k).",LTHDT_PhamVanAt.pdf - Sentence 419
420,"Mu ốn vậy ta thực hiện các phép tính sau tr ên cả x v à y:  (hàng i)  =  (hàng i) - x[i,k]*(hàng k) , v ới mọi i khác k  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          56                                         tenshi3003@gmail.com  Nội dung ch ương tr ình là nh ập 4 ma trận X, Y, R, S v à véc tơ u.",LTHDT_PhamVanAt.pdf - Sentence 420
421,"Sau đó tính véc tơ v theo công  thức:  v = (( X + Y)*(R - S))-1u            Như s ẽ thấy trong h àm main() dư ới đây, nhờ các h àm toán t ử mà câu l ệnh tính v đ ược viết gần  giống nh ư công th ức toán học n êu trên.",LTHDT_PhamVanAt.pdf - Sentence 421
422,/* Chương tr ình */   #include <conio.h>   #include <iostream.h>   #include <iomanip.h>   #include <math.,LTHDT_PhamVanAt.pdf - Sentence 422
423,"h>  struct  MT   {  double a[20][20]; // Mang chua cac phan tu ma tran   int n ; // Cap ma tran   } ;  struct VT   {  double b[20]; // Mang chua cac phan tu cua vec to   int n ; // Cap vec to   } ;  ostream& operator<< (ostream& os, const MT& x);   ostream& operator<< (ostre am& os, const VT& v);   istream&  operator>> (istream&  is,MT& x);   istream&  operator>> (istream&  is, VT &v);   MT operator+(const MT& x1, const MT& x2);   MT operator -(const MT& x1, const MT& x2);   MT operator*(const MT& x1, const MT& x2);   VT operator*(const MT & x, const VT& v);   MT operator!(MT x); // Tinh ma tran nghich dao   ostream& operator<< (ostream& os, const MT& x)   {  os << setprecision(2) << setiosflags(ios::showpoint);   for (int i=1 ; i<= x.n ; ++i)   {  os << "" \n"" ;  for (int j=1; j<=x.n; ++j)   os << setw(6) < < x.a[i][j] ;   }  os << "" \n"" ;  return os;  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          57                                         tenshi3003@gmail.com  }   ostream& operator<< (ostream& os, const VT& v)   {  os << setprecision(2) << setiosflags(ios::showpoint);   for (int i=1 ; i<= v.n ; ++i)   os << setw(6) << v.b[i] ;   os << "" \n"" ;  return os;   }  istream&  operator>> (istrea m&  is, MT& x)   {  cout << "" - Cap ma tran: "" ;   is >> x.n;   cout << ""Nhap cac phan tu : \n"" ;  for (int i=1 ; i<= x.n ; ++i)   for (int j=1; j<=x.n; ++j)   {  cout << ""PT hang "" << i << "" cot "" << j << "" = "" ;   is >> x.a[i][j] ;   }  return is;   }  istream&  operator>> (i stream&  is, VT& v)   {  cout << "" - Cap vec to: "" ;   is >> v.n;   cout << ""Nhap cac phan tu : \n"" ;  for (int i=1 ; i<= v.n ; ++i)   {  cout << ""Phan tu thu "" << i <<  "" = "" ;   is >> v.b[i] ;   }  return is;   }  MT operator+(const MT& x1, const MT& x2)   {  if (x1.n!=x2.n)   {  cout << "" \nKhong thuc hien duoc phep cong vi 2 MT khong cung cap"";   getch();   return x1;   }  else Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          58                                         tenshi3003@gmail.com  {  MT x;   int i, j, n;   n = x.n = x1.n ;   for (i=1; i<=n; ++i)   for (j=1; j<=n ;++j)   x.a[i][j] = x1.a[i][j] + x2.a[i][j] ;   return x;   }  }  MT operator -(const MT& x1, co nst MT& x2)   {  if (x1.n!=x2.n)   {  cout << "" \nKhong thuc hien duoc phep tru vi 2 MT khong cung cap"";   getch();   return x1;   }  else  {  MT x;   int i, j, n;   n = x.n = x1.n;   for (i=1; i<=n; ++i)   for (j=1; j<=n ;++j)   x.a[i][j] = x1.a[i][j] - x2.a[i][j] ;   return x;   }  }  MT operator*(const MT& x1, const MT& x2)   {  if (x1.n!=x2.n)   {  cout << "" \nKhong thuc hien duoc phep nhan vi 2 MT khong cung cap"";   getch();   return x1;   }  else  {  MT x;   int n, i, j,k;  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          59                                         tenshi3003@gmail.com  n = x.n = x1.n;   for (i=1; i<=n; ++i)   for (j=1; j<=n ;++j)   {  x.a[i][j] = 0.0 ;   for (k=1 ; k<=n; ++k)   x.a[i][j] += x1.a[i][k]*x2.a[k][j] ;   }  return x;   }  }  VT operator*(const MT& x, const VT& v)   {  if (x.n != v.n)   {  cout << "" \n Cap ma tran khac cap vec to, phep nhan vo nghia"";   getch();   return v;   }  else  {  VT u; int  n;   n = u.n = v.n ;   for (int i=1; i <=n ; ++i)   {  u.b[i] = 0;   for (int j=1; j<=n; ++j)   u.b[i] += x.a[i][j]*v.b[j];   }  return u;   }  }  MT operator!(MT x)   {  MT y;   int i,j,k,r,n;   double tg;   n = y.n = x.n ;   for (i=1 ; i<=n ; ++i)  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          60                                         tenshi3003@gmail.com  for (j=1 ; j<=n ; ++j)   if (i==j) y.a[i][j] = 1;   else y.a [i][j] = 0;   for (k=1; k<=n; ++k)   {  r=k;  for (i=k+1; i<=n; ++i)   if (abs(x.a[i][k]) > abs(x.a[r][k]) ) r = i;   if (abs(x.a[r][k]) < 1.0E -8)  {  cout << "" \n Ma tran suy bien, khong co nghich dao"" ;   getch();   return x;   }  /* Hoan vi hang r va hang k */   for (j=1 ; j <=n ; ++j)   {  tg = x.a[k][j];   x.a[k][j] = x.a[r][j];   x.a[r][j] = tg;   tg = y.a[k][j];   y.a[k][j] = y.a[r][j];   y.a[r][j] = tg;   }  /* Chia hang k cho a[k,k] */   tg = x.a[k][k] ;   for (j=1 ; j<=n ; ++j)   {  x.a[k][j] /= tg;   y.a[k][j] /= tg;   }  /* Khu cot k : lam cho a [i,k] = 0 voi i != k */   for (int i=1; i<= n ; ++i)   if (i != k)   {  tg = x.a[i][k] ;   for (j=1 ; j<=n ; ++j)   {  x.a[i][j] -= tg*x.a[k][j] ;  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          61                                         tenshi3003@gmail.com  y.a[i][j] -= tg*y.a[k][j] ;   }  }  }  return y;   }  void main()   {  MT x,y,r,s;   VT u,v;   clrscr();   cout <<"" \nNhap ma tran X "" ; ci n >> x;   cout <<"" \nNhap ma tran Y "" ; cin >> y;   cout <<"" \nNhap ma tran R "" ; cin >> r;   cout <<"" \nNhap ma tran S "" ; cin >> s;   cout <<"" \nNhap vec to u "" ; cin >> u;   v = !((x+y)*(r -s))*u ;   cout << "" \nVec to v = xu  "" << v ;   getch();   }                                         Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          62                                         tenshi3003@gmail.com  Chương 3   Khái ni ệm về lớp   Như đ ã nói ở trên, lớp là khái ni ệm trung tâm của lập tr ình h ướng đối t ượng, nó l à sự mở rộng  của các khái niệm cấu trúc (struct) của C v à bản ghi (record) của PASCAL.",LTHDT_PhamVanAt.pdf - Sentence 423
424,"Ngo ài các thành ph ần  dữ liệu (nh ư cấu trúc), lớp c òn ch ứa các thành ph ần hàm , còn g ọi là phương th ức (method) hay  hàm thành viên (member function).",LTHDT_PhamVanAt.pdf - Sentence 424
425,"C ũng giống nh ư cấu trúc, lớp có thể xem nh ư một kiểu dữ liệu.",LTHDT_PhamVanAt.pdf - Sentence 425
426,"Vì vậy lớp c òn gọi là kiểu đối t ượng v à lớp được dùng đ ể khai báo các biến, mảng đối t ượng (nh ư  thể dùng ki ểu int để khai báo các biến mảng nguy ên).",LTHDT_PhamVanAt.pdf - Sentence 426
427,"Như v ậy từ một lớp có thể tạo ra (bằng cách  khai báo) nhi ều đối t ượng (biến, mảng) khác nhau.",LTHDT_PhamVanAt.pdf - Sentence 427
428,Mỗi đối t ượng có v ùng nh ớ riêng c ủa m ình.,LTHDT_PhamVanAt.pdf - Sentence 428
429,Vì  vậy cũng có thể quan niệm lớp l à tập hợp các đối t ượng c ùng ki ểu.,LTHDT_PhamVanAt.pdf - Sentence 429
430,"Chương nà y sẽ trình b ầy cách định nghĩa lớp, cách xây dựng ph ương th ức, giải thích về phạm vi  truy nh ập, s ư dụng các th ành ph ần của lớp, cách khai báo biến, mảng cấu trúc,  lời gọi tới các  phương th ức.",LTHDT_PhamVanAt.pdf - Sentence 430
431,Bài 1.,LTHDT_PhamVanAt.pdf - Sentence 431
432,Định nghĩa lớp   1.,LTHDT_PhamVanAt.pdf - Sentence 432
433,"Lớp được định nghĩa theo mẫu:   class  t ên_lớp  {  // Khai báo các thành ph ần dữ liệu (thuộc tính)   // Khai báo các phương th ức  } ;  // Định nghĩa (xây dựng) các ph ương th ức  Chú ý:    Thuộc tính của lớp có thể l à các bi ến, mảng, con trỏ có kiểu chuẩn (int, float, char, char*,  long,...) ho ặc kiểu ngo ài chu ẩn đã định nghĩa tr ước (cấu trúc, hợp, lớp, ...) .",LTHDT_PhamVanAt.pdf - Sentence 433
434,"Thuộc tính của lớp  không th ể có kiểu của chính lớp đó, nh ưng có th ể  là kiểu con trỏ lớp n ày, ví d ụ:  class   A   {  A     x ;     // Không cho phép, vì x có ki ểu lớp A   A     *p ;   // Cho phép , vì p là con tr ỏ kiểu lớp A   ...",LTHDT_PhamVanAt.pdf - Sentence 434
435,}    ;  2.,LTHDT_PhamVanAt.pdf - Sentence 435
436,Khi  báo các thành ph ần của lớp (thuộc tính v à phương th ức) có thể d ùng các t ừ khoá private  và public đ ể quy định phạm vi sử dụng của các th ành ph ần.,LTHDT_PhamVanAt.pdf - Sentence 436
437,Nếu không quy định cụ thể (không  dùng các t ừ khoá private v à public) thì C++ hi ểu đó l à private.,LTHDT_PhamVanAt.pdf - Sentence 437
438,Các thành ph ần private (ri êng) ch ỉ được sử dụng b ên trong l ớp (trong thân của các ph ương th ức  của lớp).,LTHDT_PhamVanAt.pdf - Sentence 438
439,Các h àm không ph ải là phương th ức của lớp  không đ ược phép sử dụng các th ành ph ần  này.,LTHDT_PhamVanAt.pdf - Sentence 439
440,Các thành ph ần public (công cộng) đ ược phép s ử dụng ở cả b ên trong và bên ngoài l ớp.,LTHDT_PhamVanAt.pdf - Sentence 440
441,3.,LTHDT_PhamVanAt.pdf - Sentence 441
442,"Các thành ph ần dữ liệu th ường (nh ưng không b ắt buộc) khai báo l à private đ ể bảo đảm tính  giấu kín, bảo vệ an to àn dữ liệu của lớp, không cho phép các h àm bên ngoài xâm nh ập vào dữ liệu  của lớp.",LTHDT_PhamVanAt.pdf - Sentence 442
443,4.,LTHDT_PhamVanAt.pdf - Sentence 443
444,Các phương thức th ường khai báo l à public đ ể chúng có thể đ ược gọi tới (sử dụng) từ các h àm  khác trong chương tr ình.,LTHDT_PhamVanAt.pdf - Sentence 444
445,Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          63                                         tenshi3003@gmail.com  5.,LTHDT_PhamVanAt.pdf - Sentence 445
446,Các phương th ức có thể đ ược xây dựng b ên ngoài ho ặc bên trong đ ịnh nghĩa lớp.,LTHDT_PhamVanAt.pdf - Sentence 446
447,"Thông  thường, các ph ương th ức ngắn đ ược viết b ên trong đ ịnh nghĩa lớp , còn các ph ương th ức dài thì vi ết  bên ngoài đ ịnh nghĩa lớp.",LTHDT_PhamVanAt.pdf - Sentence 447
448,6.,LTHDT_PhamVanAt.pdf - Sentence 448
449,Trong thân phương th ức của một lớp (giả sử lớp A) có thể sử dụng:   + Các thu ộc tính của lớp A   + Các phương th ức của lớp A   + Các hàm t ự lập trong ch ương tr ình.,LTHDT_PhamVanAt.pdf - Sentence 449
450,Vì ph ạm vi sử dụng của h àm là toàn  chương tr ình.,LTHDT_PhamVanAt.pdf - Sentence 450
451,7.,LTHDT_PhamVanAt.pdf - Sentence 451
452,Giá tr ị trả về của ph ương th ức có thể có kiểu bất kỳ (chuẩn v à ngoài chu ẩn)  Ví dụ sau s ẽ minh hoạ các điều nói tr ên.,LTHDT_PhamVanAt.pdf - Sentence 452
453,Chúng ta s ẽ định nghĩa lớp để mô tả v à xử lý các điểm  trên màn hình đồ hoạ.,LTHDT_PhamVanAt.pdf - Sentence 453
454,Lớp đ ược đăt t ên là DIEM.,LTHDT_PhamVanAt.pdf - Sentence 454
455,"+ Các thu ộc tính củ a lớp gồm:   int  x ;   // hoành đ ộ  (cột)   int  y ;   // tung đ ộ    (h àng)  int  m ;  // m ầu  + Các phương th ức:  Nhập dữ liệu một điểm   Hiển thị một điểm   ẩn một điểm   Lớp điểm đ ược xây dựng nh ư sau:   class DIEM   {  private:   int x, y, m ;   public:   void nhapsl() ;   void  hien() ;   void  an()   {  putpixel(x, y, getbkcolor());   }  } ;  void DIEM::nhap()   {  cout  << “ \nNhập ho ành đ ộ (cột) v à tung đ ộ (hàng) c ủa điểm: “          cin  >> x  >> y ;   cout  << “ \nNhập m ã mầu của điểm: “          cin  >> m ;   }  void  DIEM::hien()   {  int mau_ ht ; Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          64                                         tenshi3003@gmail.com  mau_ht = getcolor();   putpixel(x, y, m);   setcolor(mau_ht);   }   Qua ví d ụ trên có th ể rút ra một số điều cần nhớ sau:   + Trong c ả 3 ph ương th ức (d ù viết trong hay viết ngo ài định nghĩa lớp) đều đ ược phép truy nhập  đến các thuộc tính x, y v à m c ủa lớp.",LTHDT_PhamVanAt.pdf - Sentence 455
456,+ Các phương th ức viết b ên trong đ ịnh nghĩa lớp (nh ư phương th ức an() ) đ ược viết nh ư một  hàm thông thư ờng.,LTHDT_PhamVanAt.pdf - Sentence 456
457,"+ Khi xây d ựng các ph ương th ức bên ngoài l ớp, cần d ùng thêm tên l ớp và toán t ử phạm vi ::  đặt  ngay trư ớc tên phương ph ức để quy định r õ đây là phương thức của lớp n ào.",LTHDT_PhamVanAt.pdf - Sentence 457
458,Bài 2.,LTHDT_PhamVanAt.pdf - Sentence 458
459,"Bi ến, mảng đối t ượng  Như đ ã nói ở trên, m ột lớp (sau khi định nghĩa) có thể xem nh ư một kiểu đối t ượng v à có th ể  dùng đ ể khai báo các biến, mảng đối t ượng.",LTHDT_PhamVanAt.pdf - Sentence 459
460,"Cách khai báo biến, mảng đối t ượng cũng giống nh ư  khai báo bi ến, mảng các k iểu khác (nh ư int, float, c ấu trúc, hợp, ...), theo mẫu sau:   Tên_l ớp  danh sách đối ;   Tên_l ớp  danh sách mảng ;   Ví dụ sử dụng lớp DIEM ở §1, có th ể khai báo các biến, mảng DIEM nh ư sau:   DIEM   d1, d2, d3 ;  // Khai báo 3 bi ến đối t ượng d1, d2, d3   DIEM   d[ 20] ;  // Khai báo m ảng đối t ượng d gồm 20 phần tử   Mỗi đối t ượng sau khi khai báo sẽ đ ược cấp phát một v ùng nh ớ riêng đ ể chứa các thuộc tính của  chúng.",LTHDT_PhamVanAt.pdf - Sentence 460
461,Chú ý r ằng sẽ không có v ùng nh ớ riêng đ ể chứa các ph ương th ức cho mỗi đối t ượng.,LTHDT_PhamVanAt.pdf - Sentence 461
462,Các  phương th ức sẽ đ ược sử dụng chung cho tất cả các đối t ượng c ùng l ớp.,LTHDT_PhamVanAt.pdf - Sentence 462
463,Nh ư vậy về bộ nhớ đ ược  cấp phát th ì đối tượng giống cấu trúc.,LTHDT_PhamVanAt.pdf - Sentence 463
464,"Trong tr ương h ợp này:  sizeof(d1) = sizeof(d2) = sizeof(d3) = 3*sizeof(int) = 6   sizeof(d) = 20*6 = 120   Thuộc tính của đối t ượng:   Trong ví d ụ trên, mỗi đối t ượng d1, d2, d3 v à mỗi phần tử d[i] đều có 3 thuộc tính l à x, y, m.",LTHDT_PhamVanAt.pdf - Sentence 464
465,"Chú ý là m ỗi thuộc đều thuộc về một đối t ượng, v ì vậy không thể viết t ên thu ộc một cách ri êng r ẽ  mà bao gi ờ cũng phải có t ên đối tượng đi k èm, gi ống nh ư cách vi ết trong cấu trúc  của C hay bản ghi  của PASCAL.",LTHDT_PhamVanAt.pdf - Sentence 465
466,"Nói cách khác, cách viết thuộc tính của đối t ượng nh ư sau:   tên_đ ối_tượng.T ên_thu ộc_tính   Với các đối t ượng d1, d2, d3 v à mảng d, có thể viết nh ư sau:   d1.x    // Thu ộc tính x của đối t ượng d1   d2.x    // Thu ộc tính x của đối t ượng d2   d3.y    // Thu ộc tính y của đối t ượng d3   d[2].m  // Thu ộc tính m của phần tử d[2]   d1.x = 100 ; // Gán 100 cho d1.x   d2.y = d1.x;  // Gán d1.x cho d2.y   Sử dụng các ph ương th ức Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          65                                         tenshi3003@gmail.com  Cũng giống nh ư hàm, m ột ph ương th ức được sử dụng thông qua lời gọi.",LTHDT_PhamVanAt.pdf - Sentence 466
467,Tuy nhi ên trong l ời gọi  phương th ức bao giờ cũng phải có t ên đối tượng  để chỉ r õ phương th ức thực hiện tr ên các thu ộc  tính c ủa đối t ượng n ào.,LTHDT_PhamVanAt.pdf - Sentence 467
468,"Ví d ụ lời gọi:   d1.nhapsl();   sẽ thực hiện nhập số liệu v ào các thành ph ần d1.x, d1.y v à d1.m   Câu l ệnh  d[3].nhapsl() ;   sẽ thực hiện nhập số liệu v ào các thành ph ần d[3].x, d[3].y v à d[3].m   Chúng ta s ẽ minh hoạ các điều nói tr ên bằng một ch ương tr ình đơn gi ản sử dụng lớp DIEM để  nhập 3 điểm, hiện rồi ẩn các điểm vừa nhập.",LTHDT_PhamVanAt.pdf - Sentence 468
469,Trong ch ương tr ình đưa vào hàm kd_do_hoa() dùng đ ể  khởi động hệ đồ hoạ.,LTHDT_PhamVanAt.pdf - Sentence 469
470,"#include <conio.h>   #include <iostream.h>   #include <graphics.h>   class DIEM   {  private:   int x, y, m ;   public:   void nhapsl();   void an()   {  putpixel(x,y,getbkcolor());   }  void hien();   };  void DIEM::nhapsl()   {  cout << "" \nNhap hoanh do (cot) va t ung do (hang) cua diem: "" ;   cin >> x >> y ;   cout << "" \nNhap ma mau cua diem: "" ;   cin >> m  ;   }  void DIEM::hien()   {  int mau_ht;   mau_ht = getcolor() ;   putpixel(x,y,m);   setcolor(mau_ht);   }  void kd_do_hoa()  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          66                                         tenshi3003@gmail.com  {  int mh, mode ;   mh=mode=0;   initgraph(&mh, &mode, """" );  }  void main()   {  DIEM d1, d2, d3 ;   d1.nhapsl();   d2.nhapsl();   d3.nhapsl();   kd_do_hoa();   setbkcolor(BLACK);   d1.hien();   d2.hien();   d3.hien();   getch();   d1.an();   d2.an();   d3.an();   getch();   closegraph();   }  Bài 3.",LTHDT_PhamVanAt.pdf - Sentence 470
471,"Con tr ỏ đối t ượng  Con tr ỏ đối t ượng d ùng đ ể chứa địa chỉ của biến, mảng đối t ượng.",LTHDT_PhamVanAt.pdf - Sentence 471
472,"Nó đ ược khai báo nh ư sau:   Tên_l ớp   *con trỏ ;   Ví dụ dùng l ớp DIEM có thể khai báo:   DIEM   *p1 , *p2, *p3 ; // khai báo 3 con tr ỏ p1, p2, p3   DIEM d1, d2 ;  // Khai báo 2 đ ối tượng d1, d2   DIEM  d[20] ;  // Khai báo m ảng đối t ượng  và có th ể thực hiện các câu lệnh:   p1 =  &d2 ; // p1 ch ứa địa chỉ của d2 , hay p1 trỏ tới d2   p2 = d ;       // p2 tr ỏ tới đầu mảng d   p3 = new DIEM // T ạo một đối t ượng v à chứa địa chỉ của nó   // vào p3   Để sử dụng thuộc tính của đối t ượng thông qua con trỏ, ta viết nh ư sau:   Tên_con_tr ỏ->Tên_thu ộc_tính   Chú ý:  Nếu con trỏ chứa địa chỉ đầu của mảng, có thể d ùng con tr ỏ như tên m ảng.",LTHDT_PhamVanAt.pdf - Sentence 472
473,Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          67                                         tenshi3003@gmail.com  Như v ậy sau khi thực hiện các câu lệnh tr ên thì:   p1->x   và d2.x là như nhau   p2[i].y  và  d[i].y là như nhau   Tóm l ại ta có quy tắc sau   Quy t ắc sử dụng thuộc tính:  Để sử dụng một thuộc tính của đối t ượng ta phải d ùng phép .,LTHDT_PhamVanAt.pdf - Sentence 473
474,ho ặc  phép -> .,LTHDT_PhamVanAt.pdf - Sentence 474
475,"Trong chương tr ình, không cho phép vi ết tên thu ộc tính một cách đ ơn độc m à phải đi k èm  tên đ ối tượng hoặc t ên con tr ỏ theo các mẫu sau:   Tên_đ ối_tượng.T ên_thu ộc_tính   Tên_con_tr ỏ->Tên_thu ộc_tính   Tên_m ảng_đối_t ượng[chỉ_số].T ên_thu ộc_tính   Tên_con_tr ỏ[chỉ_số].T ên_thu ộc_tính   Chương tr ình d ưới đây cũng sử dụng lớp DIEM (trong §1) để nhập một dẫy điểm, hiển t hị và ẩn  các đi ểm vừa nhập.",LTHDT_PhamVanAt.pdf - Sentence 475
476,Ch ương tr ình dùng m ột con trỏ kiểu DIEM v à dùng toán t ử new để tạo ra một  dẫy đối t ượng.,LTHDT_PhamVanAt.pdf - Sentence 476
477,"#include <conio.h>   #include <iostream.h>   #include <graphics.h>   class DIEM   {  private:   int x, y, m ;   public:   void nhapsl();   void an()   {  putpi xel(x,y,getbkcolor());   }  void hien();   };  void DIEM::nhapsl()   {  cout <<"" \nNhap hoanh do (cot) va tung do (hang) cua diem:"" ;   cin >> x >> y ;   cout << "" \nNhap ma mau cua diem: "" ;   cin >> m  ;   }  void DIEM::hien()   {  int mau_ht;   mau_ht = getcolor() ;   putpixel(x ,y,m);  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          68                                         tenshi3003@gmail.com  setcolor(mau_ht);   }  void kd_do_hoa()   {  int mh, mode ;   mh=mode=0;   initgraph(&mh, &mode, """");   }  void main()   {  DIEM *p;   int i, n;   cout << ""So diem: "" ;   cin >> n;   p = new DIEM[n+1];   for (i=1; i<=n; ++i)   p[i].nhapsl();   kd_do_hoa();   for (i=1; i<=n; ++i)   p[i].hien();   getch();   for (i=1; i<=n; ++i)   p[i].an();   getch();   closegraph();   }  Bài 4.",LTHDT_PhamVanAt.pdf - Sentence 477
478,"Đối của ph ương th ức, con trỏ this   4.1.",LTHDT_PhamVanAt.pdf - Sentence 478
479,"Con tr ỏ this l à đối thứ nhất của ph ương th ức  Chúng ta hãy xem l ại ph ương th ức nhapsl của lớp DIEM   void DIEM::nhapsl()   {  cout <<"" \nNhap hoanh do (cot) va tung do (hang) cua diem:"" ;   cin >> x >> y ;   cout << "" \nNhap ma mau cua diem: "" ;   cin >> m  ;   }  Rõ ràng trong ph ương th ức này chúng ta s ử dụng t ên các thu ộc tính x, y v à m m ột cách đ ơn độc.",LTHDT_PhamVanAt.pdf - Sentence 479
480,Điều này có v ẻ như mâu thu ẫn với quy tắc sử d ụng thuộc tính n êu trong m ục trước.,LTHDT_PhamVanAt.pdf - Sentence 480
481,Song sự thể nh ư  sau:  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          69                                         tenshi3003@gmail.com  C++ s ử dụng con trỏ đặc biệt this trong các phương th ức.,LTHDT_PhamVanAt.pdf - Sentence 481
482,Các thuộc tính viết trong ph ương th ức  được hiểu l à thu ộc một đối t ượng do con trỏ this trỏ tới.,LTHDT_PhamVanAt.pdf - Sentence 482
483,"Nh ư vậy ph ương th ức nhapsl() có thể viết  một cách tư ờng minh nh ư sau:   void DIEM::nhapsl()   {  cout << "" \nNhap hoanh do (cot) va tung do (hang) cua diem:"" ;   cin >> this ->x >>  this ->y ;  cout << "" \nNhap ma mau cua diem: "" ;   cin >> this ->m  ;   }  Từ góc độ h àm s ố có thể kết luận rằng: Ph ương th ức bao giờ c ũng có ít nhất một đối l à con tr ỏ  this và nó luôn luôn là đ ối đầu ti ên của ph ương th ức.",LTHDT_PhamVanAt.pdf - Sentence 483
484,4.2.,LTHDT_PhamVanAt.pdf - Sentence 484
485,Tham s ố ứng với đối con trỏ this   Xét m ột lời gọi tới ph ương th ức nhapsl() :   DIEM  d1;   d1.nhapsl() ;    Trong trư ờng hợp n ày tham s ố truyền cho con trỏ this chính l à địa chỉ của d1:   this = &d1   Do đó:   this->x  chính là  d1.x   this->y  chính là  d1.y   this->m  chính là  d1.m   Như v ậy câu lệnh   d1.nhapsl() ;   sẽ nhập dữ liệu cho các thuộc tính của đối t ượng d1.,LTHDT_PhamVanAt.pdf - Sentence 485
486,Từ đó có thể rút ra kết luận sau:   Tham s ố truyền cho đối con trỏ this chính là đ ịa chỉ của đối t ượng đi k èm v ới ph ương th ức trong  lời gọi ph ương th ức.,LTHDT_PhamVanAt.pdf - Sentence 486
487,4.3.,LTHDT_PhamVanAt.pdf - Sentence 487
488,"Các đ ối khác của ph ương th ức  Ngoài đ ối đặc biệt this (đối n ày không xu ất hiện một cách t ường minh), ph ương th ức còn có các  đối khác đ ược khai báo nh ư trong các hàm.",LTHDT_PhamVanAt.pdf - Sentence 488
489,Đối của ph ương th ức có thể có kiểu bất kỳ (chuẩn v à  ngoài chu ẩn).,LTHDT_PhamVanAt.pdf - Sentence 489
490,"Ví dụ để xây dựng ph ương th ức vẽ đ ường thẳng qua 2 điểm ta cần đ ưa vào 3 đ ối: Hai đối l à 2  biến kiểu DIEM, đối thứ ba kiểu nguy ên xác đ ịnh m ã mầu.",LTHDT_PhamVanAt.pdf - Sentence 490
491,"V ì  đã có đối ngầm định this l à đối thứ  nhất, nên ch ỉ cần khai báo th êm 2 đ ối.",LTHDT_PhamVanAt.pdf - Sentence 491
492,"Ph ương th ức có thể viết nh ư sau:   void  DIEM::doan_thang(DIEM  d2, int mau)   {  int mau_ht;   mau_ht = getcolor();   setcolor(mau);   line(this ->x,this ->y,d2.x,d2.y);  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          70                                         tenshi3003@gmail.com  setcolor(mau_ht);   }  Chương tr ình sau minh ho ạ các ph ương th ức có nhi ều đối.",LTHDT_PhamVanAt.pdf - Sentence 492
493,"Ta vẫn d ùng l ớp DIEM nh ưng có m ột  số thay đổi:   + Bỏ thuộc tính m (mầu)   + Bỏ các ph ương th ức hien v à an  +Đưa vào 4 phương th ức mới:      ve_ doan_thang  (V ẽ đoạn thẳng qua 2 điểm)      ve_tam_giac  (V ẽ tam giác qua 3 điểm)     do_dai  (Tính đ ộ dài của đoạn thẳng qua 2 điểm)     chu_vi  (Tính chu vi tam giác qua 3 đi ểm)  Chương tr ình còn minh ho ạ:  + Việc ph ương th ức này sử dụng ph ương th ức khác (ph ương th ức ve_tam_giac sử dụng ph ương  thức ve_doan_thang, ph ương th ức chu_vi sử dụng ph ương th ức do_dai)   + Sử dụng con trỏ this trong thân các ph ương th ức ve_tam_giac v à chu_vi   Nội dung ch ương tr ình là nh ập 3 điểm, vẽ tam giác có đỉnh l à 3 đi ểm vừa nhập sau đó tính chu vi  tam giác.",LTHDT_PhamVanAt.pdf - Sentence 493
494,"#include <conio.h>   #include <iostream.h>   #include <graphics.h>   #include <math.h>   #include <stdio.h>   class DIEM   {  private:   int x, y ;   public:   void nhapsl();   void ve_doan_thang(DIEM d2, int mau) ;   void ve_tam_giac(DIEM d2, DIEM d3,int mau) ;   double do_dai(DIEM d2)   {  DIEM d1 = *this ;   return sqrt( pow(d1.x - d2.x,2) +    pow(d1.y - d2.y,2)  ) ;  }  double chu_vi(DIEM d2, DIEM d3);   };  void DIEM::nhapsl()   {  cout <<"" \nNhap hoanh do (cot) va tung do (hang) cua diem:"" ;   cin >> x >> y ;   }  void kd_do_hoa()  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          71                                         tenshi3003@gmail.com  {  int mh, mode ;   mh=mode=0;   initgraph(&mh, &mode, """");   }  void DIEM::ve_doan_thang(DIEM d2, int  mau)   {  setcolor(mau);   line(this ->x,this ->y,d2.x,d2.y);   }  void DIEM::ve_tam_giac(DIEM d2, DIEM d3,int mau)   {   (*this).ve_doan_thang(d2,mau);   d2.ve_doan_thang(d3,mau);   d3.ve_doan_thang(*this,mau);   }  double DIEM::chu_vi(DIEM d2, DIEM d3)   {  double s;   s= (*thi s).do_dai(d2) + d2.do_dai(d3) + d3.do_dai(*this) ;   return s;     }  void main()   {  DIEM d1, d2, d3;   char tb_cv[20] ;   d1.nhapsl();   d2.nhapsl();   d3.nhapsl();   kd_do_hoa();   d1.ve_tam_giac(d2,d3,15);   double s = d1.chu_vi(d2,d3);   sprintf(tb_cv,""Chu vi = %0.2f"", s);   outtextxy(10,10,tb_cv);   getch();   closegraph();   }  Một số nhận xét về đối của ph ương th ức và lời gọi ph ương th ức  + Quan sát nguyên m ẫu ph ương th ức:  void ve_doan_thang(DIEM d2, int mau) ;   sẽ thấy ph ương th ức có 3 đối:  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          72                                         tenshi3003@gmail.com  Đối thứ nhât l à một đối t ượng DIEM do thi s trỏ tới  Đối thứ hai l à đối tượng DIEM d2   Đối thứ ba l à biến nguy ên mau   Nội dung ph ương th ức là vẽ một đoạn thẳng đi qua các điểm *this v à d2 theo mã m ầu mau.",LTHDT_PhamVanAt.pdf - Sentence 494
495,"Xem  thân c ủa ph ương s ẽ thấy đ ược nội dung n ày:  void DIEM::ve_doan_thang(DIEM d2, int mau)   {  setcolor(mau);   line(this ->x,this ->y,d2.x,d2.y);   }  Tuy nhiên trong trương h ợp này, vai trò c ủa this không cao lắm, v ì nó được đưa vào ch ỉ cốt l àm  rõ đối thứ nhất.",LTHDT_PhamVanAt.pdf - Sentence 495
496,Trong thân ph ương th ức có thể bỏ từ khoá this vẫn đ ược.,LTHDT_PhamVanAt.pdf - Sentence 496
497,"+ Vai trò c ủa this trở n ên quan tr ọng tron g phương th ức ve_tam_giac:   void ve_tam_giac(DIEM d2, DIEM d3,int mau) ;   Phương th ức này có 4 đ ối là:   this  tr ỏ tới một đối t ượng kiểu DIEM   d2    m ột đối t ượng kiểu DIEM   d3    m ột đối t ượng kiểu DIEM   mau   m ột biến nguy ên  Nội dung ph ương th ức là vẽ 3 cạnh:   cạnh 1 đi qua    *this  v à  d2   cạnh 2 đi qua     d2 v à d3  cạnh 3 đi qua      d3 v à  *this    Các c ạnh tr ên đư ợc vẽ nhờ sử dụng ph ương th ức ve_doan_thang:   Vẽ cạnh 1 d ùng l ệnh:   (*this).ve_doan_thang(d2,mau) ;   Vẽ cạnh 2 d ùng l ệnh:   d2.ve_doan_thang(d3,mau) ;  Vẽ cạnh 3 d ùng l ệnh:   d3.ve_doan_thang(*this,mau);   Trong trư ờng n ày rõ ràng vai trò c ủa this rất quan trọng.",LTHDT_PhamVanAt.pdf - Sentence 497
498,"Nếu không d ùng nó thì công vi ệc trơ  nên khó khăn, dài d òng và khó hi ểu hơn.",LTHDT_PhamVanAt.pdf - Sentence 498
499,"Chúng ta h ãy so sánh 2 ph ương án:   Phương án dùng this trong phương t hức ve_tam_giac:   void DIEM::ve_tam_giac(DIEM d2, DIEM d3,int mau)   {  (*this).ve_doan_thang(d2,mau);   d2.ve_doan_thang(d3,mau);   d3.ve_doan_thang(*this,mau);   }  Phương án không dùng this trong phương th ức ve_tam_giac:   void DIEM::ve_tam_giac(DIEM d2, DIEM d3,int  mau)   {  DIEM d1;  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          73                                         tenshi3003@gmail.com  d1.x = x;   d1.y = y;   d1.ve_doan_thang(d2,mau);   d2.ve_doan_thang(d3,mau);   d3.ve_doan_thang(d1,mau);   }  Bài 5.",LTHDT_PhamVanAt.pdf - Sentence 499
500,Nói thêm v ề kiểu ph ương th ức và kiểu đối của ph ương th ức  5.1.,LTHDT_PhamVanAt.pdf - Sentence 500
501,"Ki ểu ph ương th ức  Phương th ức có thể không có giá trị trả về (kiểu void ) hoặc có thể trả về một giá trị có kiểu bất  kỳ, kể cả giá trị kiểu đối t ượng, con trỏ đối t ượng, tham chiếu đối t ượng.",LTHDT_PhamVanAt.pdf - Sentence 501
502,5.2.,LTHDT_PhamVanAt.pdf - Sentence 502
503,"Đ ối của ph ương th ức   Đối của ph ương th ức (cũng giống nh ư đối của h àm)  có th ể có kiểu bất kỳ:    + Ki ểu dữ liệu chuẩn nh ư int, float , char,...",LTHDT_PhamVanAt.pdf - Sentence 503
504,.,LTHDT_PhamVanAt.pdf - Sentence 504
505,"Con tr ỏ hoặc tham chiếu đến kiểu dữ liệu chuẩn  như int*, float*, char*, int&, float&, char&,...",LTHDT_PhamVanAt.pdf - Sentence 505
506,"+ Các ki ểu ngo ài chu ẩn đã định nghĩa tr ước nh ư đối tượng, cấu trúc, hợp, enum,...",LTHDT_PhamVanAt.pdf - Sentence 506
507,.,LTHDT_PhamVanAt.pdf - Sentence 507
508,Con trỏ  hoặc tham chiếu đến các kiểu ngo ài chu ẩn này.,LTHDT_PhamVanAt.pdf - Sentence 508
509,"+ Kiểu đối tượng của chính ph ương th ức, con trỏ hoặc tham chiếu đến kiểu đối t ượng n ày.",LTHDT_PhamVanAt.pdf - Sentence 509
510,5.3.,LTHDT_PhamVanAt.pdf - Sentence 510
511,Các ví d ụ  Ví dụ 1 minh hoạ:      + Thu ộc tính (th ành ph ần dữ liệu) của lớp có thể l à đối tượng của lớp khác đ ã định nghĩa b ên  trên.,LTHDT_PhamVanAt.pdf - Sentence 511
512,+ Phương th ức có giá trị trả về kiể u đối tượng v à con tr ỏ đối t ượng.,LTHDT_PhamVanAt.pdf - Sentence 512
513,"Nội dung ch ương tr ình là nh ập một dẫy h ình ch ữ nhật, sau đó t ìm hình ch ữ nhật có max diện tích  và hình ch ữ nhật có max chu vi.",LTHDT_PhamVanAt.pdf - Sentence 513
514,"Chương tr ình được tổ chức th ành 2 l ớp:  + Lớp HINH_CN gồm:   - Các thu ộc tính:  d v à r (chi ều dài và chi ều rộng)   - Các phương th ức  void  nhapsl() ;  // Nh ập chiều d ài, rộng  int dien_tich();  // Tính di ện tích   int chu_vi() ;    // Tính chu vi   + Lớp  DAY_HINH_CN gồm   - Các thu ộc tính:   int  n ;  //s ố hình ch ữ nhật của dẫy   HINH_CN  *h; //Con tr ỏ tới dẫy đ ối tượng của lớp HINH_CN        - Các phương th ức  void nhapsl();         // Nh ập một dẫy h ình ch ữ nhật   HINH_CN hinh_dt_max() ; //Tr ả về h ình ch ữ nhật có   // diện tích max  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          74                                         tenshi3003@gmail.com  HINH_CN *hinh_cv_max() ; // Tr ả về con trỏ tới HCN có   // chu vi max   #include <conio.h>   #include <iostream.h>   class HINH_CN   {  private:   int d, r;  // chieu dai va chieu rong   public:   void nhapsl()   {  cout << "" \nNhap chieu dai va chieu rong: "" ;   cin >> d >> r ;   }  void in()   {  cout << "" \nchieu dai = "" << d ;   cout << "" chieu rong= "" << r;   }  int di en_tich()   {  return d*r;   }  int chu_vi()   {  return 2*(d+r);   }  } ;  class DAY_HINH_CN   {  private:   int n; // So hinh ch nhat   HINH_CN *h;   public:   void nhapsl();   HINH_CN hinh_dt_max() ;   HINH_CN *hinh_cv_max() ;   } ;  void DAY_HINH_CN::nhapsl()   {  cout << ""So hinh CN =  "" ; Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          75                                         tenshi3003@gmail.com  cin >> n;   h = new HINH_CN[n+1];   for (int i=1;i<=n;++i)   h[i].nhapsl();   }  HINH_CN DAY_HINH_CN::hinh_dt_max()   {  HINH_CN hdtmax;   hdtmax = h[1];   for (int i=2; i<=n; ++i)   if (h[i].dien_tich() > hdtmax.dien_tich() )   hdtmax = h[i];   return hdtmax;   }  HINH_CN  * DAY_HINH_CN::hinh_cv_max()   {  int imax = 1;   for (int i=2; i<=n; ++i)   if (h[i].chu_vi() > h[imax].chu_vi() )   imax = i ;   return (h+imax);   }  void main()   {  DAY_HINH_CN d;   HINH_CN hdtmax;   d.nhapsl();   hdtmax = d.hinh_dt_max();   hdtmax.in() ;   HINH_CN *hcvmax=d.hinh _cv_max();   hcvmax ->in() ;   getch();   }  Ví dụ 2 minh hoạ:      + Thu ộc tính (th ành ph ần dữ liệu) của lớp có thể l à đối tượng của lớp khác đ ã định nghĩa b ên  trên.",LTHDT_PhamVanAt.pdf - Sentence 514
515,"+ Phương th ức có giá trị trả về kiểu đối t ượng   + Vai trò c ủa con trỏ this (xem ph ương th ức maxdt  của lớp TAM_GIAC)   + Phương th ức tĩnh (xem ph ương th ức tao_tg của lớp TAM_GIAC)  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          76                                         tenshi3003@gmail.com  Nội dung ch ương tr ình là nh ập một dẫy các điểm, sau đó t ìm tam giác l ớn nhất (về diện tích) có  đỉnh là các đi ểm vừa nhập.",LTHDT_PhamVanAt.pdf - Sentence 515
516,"Chương tr ình được tổ chức th ành 2 l ớp:  + Lớp DIEM gồm:   - Các thu ộc tính:  x v à y (to ạ độ của điểm)   - Các phương th ức  void  nhapsl() ;  // Nh ập x, y   void in() ;          // In to ạ độ     double do_dai(DIEM d2) ; // Tính đ ộ dài đo ạn thẳng qua   // 2 đi ểm (điểm ẩn xác định bởi this v à điểm d2)   + Lớp TAM_GIAC gồm:   - Các thu ộc tính:                   DIEM d1,d2,d3; // 3 đ ỉnh của tam giác       - Các phương th ức:  void nhapsl(); // Nh ập toạ độ 3 đỉnh   void in();        // In to ạ độ 3 đỉnh           // Tạo một đối t ượng TAM_GIAC từ 3 đối t ượng DIEM   static TAM_GIAC tao_tg(DIEM e1, DIEM e2, DIEM e3)   double dien_tich() ;  // Tính di ện tích   // Tìm tam giác có di ện tích max trong 2 tam giác *this v à t2  TAM_GIAC  maxdt(TAM_GIAC t2);   + Các v ấn đề đáng chú ý trong ch ương tr ình là:   - Phương thưc t ĩnh tao_tg (sẽ giải thích b ên dư ới)  - Phương thưc maxdt   + Thu ật toán l à:   - Duyệt qua các tổ hợp 3 điểm.",LTHDT_PhamVanAt.pdf - Sentence 516
517,"- Dùng phương th ức tao_tg để lập tam giác từ 3 điểm        - Dùng phương th ức maxdt  để chọn tam giác có diện tích lớn h ơn trong 2 tam giác: tam giác  vừa tạo v à tam giác có di ện tích max (tro ng số các tam giác đ ã tạo)  #include <conio.h>   #include <iostream.h>   #include <math.h>   class DIEM   {  private:   double x,y;  // Toa do cua diem   public:   void nhapsl()   {  cout << "" Toa do x, y: "" ;  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          77                                         tenshi3003@gmail.com  cin >> x >> y ;   }  void in()   {  cout << "" x = "" << x << "" y = "" << y;  }  double do_dai(DIEM d2)   {  return sqrt(pow(x -d2.x,2) + pow(y -d2.y,2) );   }  } ;  class TAM_GIAC   {  private:   DIEM d1,d2,d3; // 3 dinh tam giac   public:   void nhapsl();   void in();   static TAM_GIAC tao_tg(DIEM e1, DIEM e2, DIEM e3)   {  TAM_GIAC t;   t.d1=e1; t.d2 = e 2; t.d3=e3;   return t;   }  double dien_tich() ;   TAM_GIAC  maxdt(TAM_GIAC t2);   } ;  void TAM_GIAC::nhapsl()   {  cout << "" \nDinh 1 - "" ;  d1.nhapsl();   cout << "" \nDinh 2 - "" ;  d2.nhapsl();   cout << "" \nDinh 3 - "" ;  d3.nhapsl();   }  void TAM_GIAC::in()   {  cout << "" \nDinh 1:  "" ;  d1.in();  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          78                                         tenshi3003@gmail.com  cout << "" \nDinh 2:  "" ;  d2.in();   cout << "" \nDinh 3:  "" ;  d3.in();   }  double TAM_GIAC::dien_tich()   {  double a,b,c,p,s;   a=d1.do_dai(d2);   b=d2.do_dai(d3);   c=d3.do_dai(d1);   p=(a+b+c)/2;   return sqrt(p*(p -a)*(p -b)*(p -c));  }  TAM_GIAC  TAM_GIAC: :maxdt(TAM_GIAC t2)   {  if (this ->dien_tich() > t2.dien_tich())   return *this ;   else  return t2;   }  void main()   {  DIEM d[50];   int n, i ;   clrscr();   cout << "" \n So diem= "";   cin >> n;   for (i=1; i<=n; ++i)   {  cout << "" \nNhap diem "" << i << "" - "" ;  d[i].nhapsl();   }  int j, k ;   TAM_GIAC tmax, t;   tmax = TAM_GIAC::tao_tg(d[1],d[2],d[3]);   for (i=1;i<=n -2;++i)   for (j=i+1;j<=n -1;++j)   for (k=j+1;k<=n;++k)   {  t=TAM_GIAC::tao_tg(d[i],d[j],d[k]);   tmax = tmax.maxdt(t);   } Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          79                                         tenshi3003@gmail.com  cout << "" \n\nTam giac co dien tich lon nhat: "" ;   tmax.in();   cout << "" \nDien tich  = "" << tmax.dien_tich();   getch();   }  Chú ý 1:   Để tạo một đối t ượng TAM_GIAC từ 3 đối t ượng DIEM ta đ ã dùng ph ương th ức tĩnh:   static TAM_GIAC tao_tg(DIEM e1, DIEM e2, DIEM e3)   {  TAM_GIAC t;   t.d1=e1; t.d2 = e2; t.d3=e3;   return t;   }  Phương th ức tĩnh (sẽ nói th êm trong các m ục bên dư ới) có các đặc điểm sa u:  + Nó gi ống ph ương th ức thông th ường ở chỗ: Trong thân của nó có thể truy nhập tới các th ành  phần của lớp (cụ thể l à lớp TAM_GIAC).",LTHDT_PhamVanAt.pdf - Sentence 517
518,+ Nó khác phương th ức thông th ường ở chỗ:   - Không có đ ối ngầm định xác định bởi con trỏ this (nh ư phương th ức thông th ường).,LTHDT_PhamVanAt.pdf - Sentence 518
519,Như  vậy ph ương th ức tao_tg có đúng 3 đối.,LTHDT_PhamVanAt.pdf - Sentence 519
520,"- Nó không g ắn với một đối t ượng  cụ thể n ào của lớp, n ên trong l ời gọi tới ph ương th ức ảo có  thể dùng tên l ớp, ví dụ (xem h àm main):   t=TAM_GIAC::tao_tg(d[i],d[j],d[k]);   Chú ý 2:   Không th ể thay ph ương th ức tĩn h tao_tg b ằng h àm, vì trong thân hàm không được truy  xuất đến các thuộc tính của lớp TAM_GIAC.",LTHDT_PhamVanAt.pdf - Sentence 520
521,Tuy nhi ên có m ột giải pháp khác l à dùng khái ni ệm  hàm b ạn (friend).,LTHDT_PhamVanAt.pdf - Sentence 521
522,H àm b ạn của một lớp có quyền truy nhập đến các thuộc tính của lớp.,LTHDT_PhamVanAt.pdf - Sentence 522
523,Trong ví dụ  3 dưới đây ta sẽ xây dựng h àm tao_tg như m ột hàm b ạn của lớp TAM_GIAC.,LTHDT_PhamVanAt.pdf - Sentence 523
524,"Chú ý 3:  còn m ột giải pháp nữa l à dùng hàm t ạo (constructor) sẽ tr ình b ầy trong các ch ương sau:   Chương tr ình d ưới đây có nội dung giống nh ư ví d ụ 2, nh ưng thay phương th ức tĩnh tao_tg bằng  hàm b ạn tao_tg.",LTHDT_PhamVanAt.pdf - Sentence 524
525,Ví dụ 3: Minh ho ạ cách d ùng hàm b ạn.,LTHDT_PhamVanAt.pdf - Sentence 525
526,Nội dung ch ương tr ình gi ống nh ư trong ví d ụ 2.,LTHDT_PhamVanAt.pdf - Sentence 526
527,"#include <conio.h>   #include <iostream.h>   #include <math.h>   class DIEM   {  private:   double x,y;  // Toa do cua diem   public:   void nhapsl()   {  cout << "" Toa do x, y: "" ;   cin >> x >> y ;   }  void in()  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          80                                         tenshi3003@gmail.com  {  cout << "" x = "" << x << "" y = "" << y;   }  double do_dai(DIEM d2)   {  return sqrt(pow(x -d2.x,2) + pow(y -d2.y,2) );   }  } ;  class TAM_GIAC   {  private:   DIEM d1,d2,d3; // 3 dinh tam giac   public:   void nhapsl();   void in();   friend  TAM_GIAC tao_tg(DIEM e1, DIEM e2, DIEM e3)   {  TAM_GIAC t;   t.d1=e1; t.d2 = e2; t.d3=e3;   return t;   }  double dien_tich() ;   TAM_GIAC  maxdt(TAM_GIAC t2);   } ;  void TAM_GIAC::nhapsl()   {  cout << "" \nDinh 1 - "" ;  d1.nhapsl();   cout << "" \nDinh 2 - "" ;  d2.nhapsl();   cout << "" \nDinh 3 - "" ;  d3.nhapsl();   }  void TAM_GIAC::in()   {  cout << "" \nDinh 1:  "" ;  d1.in();   cout << "" \nDinh 2:  "" ;  d2.in();   cout << "" \nDinh 3:  "" ;  d3.in();   } Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          81                                         tenshi3003@gmail.com  double TAM_GIAC::dien_tich()   {  double a,b,c,p,s;   a=d1.do_dai(d2);   b=d2.do_dai(d3);   c=d3.do_ dai(d1);   p=(a+b+c)/2;   return sqrt(p*(p -a)*(p -b)*(p -c));  }  TAM_GIAC  TAM_GIAC::maxdt(TAM_GIAC t2)   {  if (this ->dien_tich() > t2.dien_tich())   return *this ;   else  return t2;   }  void main()   {  DIEM d[50];   int n, i ;   clrscr();   cout << "" \n So diem= "";   cin >> n;   for (i=1; i<=n; ++i)   {  cout << "" \nNhap diem "" << i << "" - "" ;  d[i].nhapsl();   }  int j, k ;   TAM_GIAC tmax, t;   tmax = tao_tg(d[1],d[2],d[3]);   for (i=1;i<=n -2;++i)   for (j=i+1;j<=n -1;++j)   for (k=j+1;k<=n;++k)   {  t=tao_tg(d[i],d[j],d[k]);   tmax = tmax.maxdt(t);   }  cout << "" \n\nTam giac co dien tich lon nhat: "" ;   tmax.in();  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          82                                         tenshi3003@gmail.com  cout << "" \nDien tich  = "" << tmax.dien_tich();   getch();   }     Chú ý:  Hàm b ạn có thể xây dựng b ên trong đ ịnh nghĩa lớp (nh ư chương tr ình trên) ho ặc có thể  khai báo bên trong và xây d ựng b ên ngoài đ ịnh n ghĩa lớp nh ư sau:   class TAM_GIAC   {  private:   DIEM d1,d2,d3; // 3 dinh tam giac   public:   void nhapsl();   void in();   friend  TAM_GIAC tao_tg(DIEM e1,DIEM e2,DIEM e3);   double dien_tich() ;   TAM_GIAC  maxdt(TAM_GIAC t2);   } ;  TAM_GIAC tao_tg(DIEM e1, DIEM e2, DIEM e3)  {  TAM_GIAC t;   t.d1=e1; t.d2 = e2; t.d3=e3;   return t;   }  Nhận xét:  Không cho phép dùng t ừ khoá friend khi xây dựng h àm (bên ngoài l ớp)  Bài 6.",LTHDT_PhamVanAt.pdf - Sentence 527
528,"Hàm, hàm b ạn  6.1.",LTHDT_PhamVanAt.pdf - Sentence 528
529,"Hàm có các tính ch ất sau:   + Ph ạm vi của h àm là toàn b ộ chương tr ình, vì v ậy hàm có th ể được gọ i tới từ bất kỳ chỗ n ào.",LTHDT_PhamVanAt.pdf - Sentence 529
530,Như vây trong các phương th ức có thể sử dụng h àm.,LTHDT_PhamVanAt.pdf - Sentence 530
531,"+ Đối của h àm có th ể là các đ ối tượng, tuy nhi ên có m ột hạn chế l à trong thân hàm không cho  phép truy nh ập tới thuộc tính của các đối n ày.",LTHDT_PhamVanAt.pdf - Sentence 531
532,"Ví d ụ giả  sử  đ ã định nghĩa lớp:   class D IEM  {  private:   double x,y;  // Toa do cua diem   public:   void nhapsl()   {  cout << "" Toa do x, y: "" ;   cin >> x >> y ;  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          83                                         tenshi3003@gmail.com  }  void in()   {  cout << "" x = "" << x << "" y = "" << y;   }  };  Dùng l ớp DIEM, ta xây dựng h àm tính đ ộ dài của đoạn thẳng đi qua 2 điểm nh ư sau:   doub le do_dai(DIEM d1, DIEM d2)   {  return sqrt(pow(d1.x -d2.x,2) + pow(d1.y -d2.y,2));   }  Hàm này s ẽ bị báo lỗi khi dịch, v ì trong thân hàm không cho phép s ử dụng các thuộc tính d1.x,  d1.y, d2.x, d2.y c ủa các đối t ượng d1 v à d2 thu ộc lớp DIEM.",LTHDT_PhamVanAt.pdf - Sentence 532
533,"+ Ph ạm vi sử dụng củ a các phương th ức (public) l à toàn chương tr ình, vì v ậy trong thân h àm có  thể gọi tới các ph ương th ức.",LTHDT_PhamVanAt.pdf - Sentence 533
534,"Ví dụ giả  sử đ ã định nghĩa lớp:     class DIEM   {  private:   double x,y;  // Toa do cua diem   public:   void nhapsl()   {  cout << "" Toa do x, y: "" ;   cin >> x >> y ;  }  void in()   {  cout << "" x = "" << x << "" y = "" << y;   }  double do_dai(DIEM d2)   {  return sqrt(pow(x -d2.x,2) + pow(y -d2.y,2) );   }  } ;  Khi đó b ằng cách d ùng phương th ức do_dai, ta có thể viết h àm tính di ện tích tam giác có đỉnh l à  các đ ối tượng d1, d2, d3 của  lớp DIEM nh ư sau:   double dt_tg(DIEM d1, DIEM d2, DIEM d3)   {  double a,b,c,p,s;  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          84                                         tenshi3003@gmail.com  a=d1.do_dai(d2);   b=d2.do_dai(d3);   c=d3.do_dai(d1);   p=(a+b+c)/2;   return sqrt(p*(p -a)*(p -b)*(p -c));  }  Bằng cách d ùng hàm dt_tg, có th ể tổ chức lại ch ương tr ình tìm tam giác có di ện tích l ớn nhất (ở  mục trên) m ột cách đ ơn gi ản hơn( b ỏ đi lớp TAM_GIAC) nh ư ví d ụ sau.",LTHDT_PhamVanAt.pdf - Sentence 534
535,"Ví dụ 1:   #include <conio.h>   #include <iostream.h>   #include <math.h>   class DIEM   {  private:   double x,y;  // Toa do cua diem   public:   void nhapsl()   {  cout << "" Toa do x, y:  "" ;  cin >> x >> y ;   }  void in()   {  cout << "" x = "" << x << "" y = "" << y;   }  double do_dai(DIEM d2)   {  return sqrt(pow(x -d2.x,2) + pow(y -d2.y,2) );   }  } ;  double dt_tg(DIEM d1, DIEM d2, DIEM d3)   {  double a,b,c,p,s;   a=d1.do_dai(d2);   b=d2.do_dai(d3);   c=d3.do_dai (d1);   p=(a+b+c)/2;   return sqrt(p*(p -a)*(p -b)*(p -c));  }  void main()  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          85                                         tenshi3003@gmail.com  {  DIEM d[50];   int n, i,j,k,imax,jmax,kmax ;   clrscr();   cout << "" \n So diem= "";   cin >> n;   for (i=1; i<=n; ++i)   {  cout << "" \nNhap diem "" << i << "" - "" ;  d[i].nhapsl();   }  imax=1; jmax=2; kmax=3 ;  for (i=1;i<=n -2;++i)   for (j=i+1;j<=n -1;++j)   for (k=j+1;k<=n;++k)   if (dt_tg(d[i],d[j],d[k]) > dt_tg(d[imax],d[jmax],d[kmax]))   {  imax = i ;   jmax = j;   kmax = k;   }  cout << "" \n\nTam giac co dien tich lon nhat: "" ;   cout << "" \nDinh 1 - ""; d[imax].in();   cout << ""\nDinh 2 - ""; d[jmax].in();   cout << "" \nDinh 3 - ""; d[kmax].in();   cout << "" \nDien tich  = "" << dt_tg(d[imax],d[jmax],d[kmax]) ;   getch();   }  Nhận xét:  Chương tr ình trên làm vi ệc trên m ảng d kiểu DIEM.",LTHDT_PhamVanAt.pdf - Sentence 535
536,Bây giờ nếu ta d ùng m ảng ngo ài  thì từ số thứ tự sẽ suy ra  phần tử của mảng.,LTHDT_PhamVanAt.pdf - Sentence 536
537,"Nh ư vây hàm   double dt_tg(DIEM d1, DIEM d2, DIEM d3);   có 3 đ ối kiểu DIEM có thể thay bằng h àm có 3 đ ối nguy ên:  double dt_tg(int i, int j, int k);   để tính diện tích tam giác có đỉnh l à d[i], d[j] và d[k] .",LTHDT_PhamVanAt.pdf - Sentence 537
538,ý t ưởng n ày đư ợc thể hiện trong ví dụ sau.,LTHDT_PhamVanAt.pdf - Sentence 538
539,Ví dụ 2:  Chương tr ình dùng m ảng đối t ượng ngo ài.,LTHDT_PhamVanAt.pdf - Sentence 539
540,Chú ý:   Khai báo m ảng đối t ượng phải đặt sau định nghĩa kiểu đối t ượng (định nghĩa lớp).,LTHDT_PhamVanAt.pdf - Sentence 540
541,"#include <conio.h>   #include <iostream.h>   #include <math.h>   double dt_tg(int i, int j, int k);  // Khai báo  hàm dt_tg   class DIEM   {  private:  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          86                                         tenshi3003@gmail.com  double x,y;  // Toa do cua diem   public:   void nhapsl();   void in();   double do_dai(DIEM d2);   } ;  // Chú ý: Khai báo m ảng kiểu DIEM phải đặt sau định nghĩa   // lớp DIEM   DIEM d[50];   void DIEM::nhapsl()   {  cout << "" Toa do x, y: ""  ;  cin >> x >> y ;   }  void DIEM::in()   {  cout << "" x = "" << x << "" y = "" << y;   }  double DIEM::do_dai(DIEM d2)   {  return sqrt(pow(x -d2.x,2) + pow(y -d2.y,2) );   }  double dt_tg(int i, int j, int k)   {  double a,b,c,p,s;   a=d[i].do_dai(d[j]);   b=d[j].do_dai(d[k]);   c=d[k].do_dai(d[i]);   p=(a+b+c)/2;   return sqrt(p*(p -a)*(p -b)*(p -c));  }  void main()   {  int n, i,j,k,imax,jmax,kmax ;   clrscr();   cout << "" \n So diem= "";   cin >> n;   for (i=1; i<=n; ++i)   {  cout << "" \nNhap diem "" << i << "" - "" ;  d[i].nhapsl();  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          87                                         tenshi3003@gmail.com  }  imax=1; jmax=2; kmax=3 ;  for (i=1;i<=n -2;++i)   for (j=i+1;j<=n -1;++j)   for (k=j+1;k<=n;++k)   if (dt_tg(i,j,k) > dt_tg(imax,jmax,kmax))   {  imax = i ;   jmax = j;   kmax = k;   }  cout << "" \n\nTam giac co dien tich lon nhat: "" ;   cout << "" \nDinh 1 - ""; d[imax].in();   cout << "" \nDinh 2 - ""; d[j max].in();   cout << "" \nDinh 3 - ""; d[kmax].in();   cout << "" \nDien tich  = "" << dt_tg(imax,jmax,kmax);   getch();   }  6.2.",LTHDT_PhamVanAt.pdf - Sentence 541
542,Hàm b ạn (friend function)   6.2.1.,LTHDT_PhamVanAt.pdf - Sentence 542
543,"Đ ể một h àm tr ở thành b ạn của một lớp, có 2 cách viết:   Cách 1:   Dùng t ừ khoá friend để khai báo h àm trong l ớp và xây d ựng h àm bên ngoài như các  hàm thông thư ờng (không d ùng t ừ khoá friend).",LTHDT_PhamVanAt.pdf - Sentence 543
544,Mẫu viết nh ư sau:   class A   {  private:   // Khai báo các thu ộc tính   public:   ...,LTHDT_PhamVanAt.pdf - Sentence 544
545,// Khai báo các  hàm b ạn của lớp A   friend  void  f1(...);   friend   double  f2(...);   friend   A  f 3(...) ;   ...,LTHDT_PhamVanAt.pdf - Sentence 545
546,"} ;  // Xây d ựng các h àm f1, f2, f3   void f1(...)   {  ...",LTHDT_PhamVanAt.pdf - Sentence 546
547,} Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          88                                         tenshi3003@gmail.com  double  f2(...)   {  ...,LTHDT_PhamVanAt.pdf - Sentence 547
548,}  A  f3(...)   {  ...,LTHDT_PhamVanAt.pdf - Sentence 548
549,}  Cách 2:  Dùng t ừ khoá friend để xây dựng h àm trong đ ịnh nghĩa lớp.,LTHDT_PhamVanAt.pdf - Sentence 549
550,Mẫu viết nh ư sau:   class A   {  private:   // Khai báo các thu ộc tính   public:   ...,LTHDT_PhamVanAt.pdf - Sentence 550
551,// Xây d ựng các  h àm b ạn của lớp A   void f1(...)   {  ...,LTHDT_PhamVanAt.pdf - Sentence 551
552,}  double  f2(...)   {  ...,LTHDT_PhamVanAt.pdf - Sentence 552
553,}  A  f3(...)   {  ...,LTHDT_PhamVanAt.pdf - Sentence 553
554,}  ...,LTHDT_PhamVanAt.pdf - Sentence 554
555,} ;  6.2.2.,LTHDT_PhamVanAt.pdf - Sentence 555
556,Tính ch ất của h àm b ạn  Trong thân hàm b ạn của một lớp có thể truy nhập tới các thuộc tính của các đối t ượng thuộc lớp  này.,LTHDT_PhamVanAt.pdf - Sentence 556
557,Đây là s ự khác nhau du y nhất giữa h àm b ạn và hàm thông thư ờng.,LTHDT_PhamVanAt.pdf - Sentence 557
558,Chú ý rằng h àm b ạn không  phải là phương th ức của lớp.,LTHDT_PhamVanAt.pdf - Sentence 558
559,Ph ương th ức có một đối ẩn (ứng với con trỏ this) v à lời gọi của  phương th ức phải gắn với một đối t ượng n ào đó (đ ịa chỉ đối t ượng n ày đư ợc truyền cho con trỏ  this).,LTHDT_PhamVanAt.pdf - Sentence 559
560,Lời gọi của h àm b ạn giống nh ư lời gọi của h àm thông thư ờng.,LTHDT_PhamVanAt.pdf - Sentence 560
561,"Ví dụ sau sẽ so sánh ph ương th ức, h àm b ạn và hàm t ự do (h àm thông thư ờng).",LTHDT_PhamVanAt.pdf - Sentence 561
562,Xét lớp SP (số  phức).,LTHDT_PhamVanAt.pdf - Sentence 562
563,"H ãy so sánh 3 ph ương án đ ể thực hiện việc cộng 2 số phức:   Phương án 1:  Dùng phương th ức  class SP  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          89                                         tenshi3003@gmail.com  {  private:   double a; // Ph ần thực   double  b; // Ph ần ảo   public:   SP cong(SP u2)   {  SP u:   u.a = this ->a  +  u2.a ;   u.b = this ->b  +  u2.b ;   return u;   }  } ;  Cách dùng   SP  u, u1, u2;   u = u1.cong(u2);   Phương án 2:  Dùng hàm b ạn  class SP   {  private:   double a; // P hần thực   double  b; // Ph ần ảo   public:   friend SP  cong(SP u1, SP u2)   {  SP u:   u.a = u1.a  +  u2.a ;   u.b = u1.b  +  u2.b ;   return u;   }  };  Cách dùng   SP  u, u1, u2;   u = cong(u1, u2);   Phương án 3:  Dùng hàm t ự do  class SP   {  private:  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          90                                         tenshi3003@gmail.com  double a; // Ph ần thực   double   b; // Ph ần ảo   public:   ...",LTHDT_PhamVanAt.pdf - Sentence 563
564,"} ;  SP  cong(SP u1, SP u2)   {  SP u:   u.a = u1.a  +  u2.a ;   u.b = u1.b  +  u2.b ;   return u;   }    Phương án này không đư ợc chấp nhận, Tr ình biên d ịch sẽ báo lỗi v ì trong thân hàm không được  quyền truy xuất đến các thuộc tính ri êng (pr ivate) a, b c ủa các đối t ượng u, u1 v à u2 thu ộc lớp SP.",LTHDT_PhamVanAt.pdf - Sentence 564
565,6.2.3.,LTHDT_PhamVanAt.pdf - Sentence 565
566,M ột hàm có th ể là bạn của nhiều lớp đ ược không?,LTHDT_PhamVanAt.pdf - Sentence 566
567,Câu tr ả lời l à được.,LTHDT_PhamVanAt.pdf - Sentence 567
568,"Khi một h àm là  bạn của nhiều lớp, th ì nó có quy ền truy nhập tới tất cả các thuộc tính của các đối t ượng trong các  lớp này.",LTHDT_PhamVanAt.pdf - Sentence 568
569,"Để làm cho hàm f tr ở thành b ạn của các lớp A, B v à C ta s ử dụng mẫu viết sau:   class    B;  // Khai báo trư ớc lớp A   class    B;  // Khai báo trư ớc lớp B   class    C;  // Khai báo trư ớc lớp C   // Định nghĩa lớp A   class   A   {  // Khai báo f là b ạn của A   friend   void  f(...) ;   } ;  // Định nghĩa lớp B   class   B   {  // Khai báo f là b ạn của B   friend   void  f(...) ;   } ;  // Định nghĩa lớp C   class   C   {  // Khai báo f là b ạn của C   friend   void  f(...) ;   } ;  // Xây d ụng h àm f Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          91                                         tenshi3003@gmail.com  void f(...)   {  ...",LTHDT_PhamVanAt.pdf - Sentence 569
570,}  Chương tr ình sau đây minh ho ạ cách d ùng hàm b ạn (bạn của một lớp v à bạn của nhiều lớp).,LTHDT_PhamVanAt.pdf - Sentence 570
571,"Chương tr ình đưa vào 2 l ớp VT (véc t ơ), MT (ma tr ận) v à 3 hàm b ạn để thực hiện các thao tác tr ên  2 lớp này:  // Hàm b ạn với lớp VT d ùng đ ể in một véc t ơ  friend void in(const VT &x);   // Hàm bạn với lớp MT d ùng đ ể in một ma trận   friend void in(const MT &a);   // Hàm b ạn với cả 2 lớp MT v à VT dùng đ ể nhân ma trận với véc t ơ  friend VT tich(const MT &a,const VT &x);   Nội dung ch ương tr ình là nh ập một ma trận vuông cấp n v à một véc t ơ cấp n, sau đó t hực hiện  phép nhân ma tr ận với véc t ơ vừa nhập.",LTHDT_PhamVanAt.pdf - Sentence 571
572,"// Chương tr ình CT3_09.CPP   #include <conio.h>   #include <iostream.h>   #include <math.h>   class VT;   class MT ;   class VT   {  private:   int n;   double x[20];  // Toa do cua diem   public:   void nhapsl();   friend void in(co nst VT &x);   friend VT tich(const MT &a,const VT &x) ;   } ;  class MT   {  private:   int n;   double a[20][20];   public:   friend VT tich(const MT &a,const VT &x);   friend void in(const MT &a);   void nhapsl();   } ; Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          92                                         tenshi3003@gmail.com  void VT::nhapsl()   {  cout << "" \n Cap vec to = "";   cin >> n  ;  for (int i=1; i<=n ; ++i)   {  cout << "" \nPhan tu thu "" << i << "" = "" ;   cin >> x[i];   }  }  void MT::nhapsl()   {  cout << "" \n Cap ma tran = "";   cin >> n ;   for (int i=1; i<=n ; ++i)   for (int j=1; j<=n; ++j)   {  cout << "" \nPhan tu thu hang ""<< i << "" cot "" << j << "" ="" ;  cin >> a[i][j];   }  }  VT tich(const MT &a,const VT &x)   {  VT y;   int n=a.n;   if (n!=x.n)   return x;   y.n = n;   for (int i=1; i<=n; ++i)   {  y.x[i]=0;   for (int j=1; j<=n; ++j)   y.x[i] += a.a[i][j]*x.x[j];   }  return y;   }  void in(const VT &x)   {  cout << "" \n""; Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          93                                         tenshi3003@gmail.com  for (in t i=1; i<=x.n; ++i)   cout <<  x.x[i] << ""  "";   }  void in(const MT &a)   {  for (int i=1; i<=a.n; ++i)   {  cout << "" \n"" ;  for (int j=1; j<=a.n; ++j)   cout <<  a.a[i][j] << ""  "";   }  }  void main()   {  MT a; VT x,y;   clrscr();   a.nhapsl();   x.nhapsl();   y=tich(a,x);   clrscr() ;  cout << "" \nMa tran A:"";   in(a);   cout << "" \n\nVec to x: "" ;   in(x);   cout << "" \n\nVec y = Ax: "" ;   in(y);   getch();   }      Bài 7.",LTHDT_PhamVanAt.pdf - Sentence 572
573,Ph ạm vi truy xuất   7.1.,LTHDT_PhamVanAt.pdf - Sentence 573
574,Các t ừ khoá private v à public   Các thành ph ần (thuộc tính v à phương th ức) của lớp có thể khai báo l à private ho ặc public theo  mẫu:  private:   // Khai báo các thành ph ần riêng c ủa lớp   public:  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          94                                         tenshi3003@gmail.com  // Khai báo các thành ph ần chung (công cộng)   Chú ý:  Các thành ph ần khai báo mặc định (không d ùng các t ừ khoá private v à public) đư ợc xem  là các thành ph ần private.,LTHDT_PhamVanAt.pdf - Sentence 574
575,7.2.,LTHDT_PhamVanAt.pdf - Sentence 575
576,Các thành  phần ri êng c ủa lớp  chỉ được sử dụng trong phạm vi của lớp (trong thân các  phương th ức của lớp).,LTHDT_PhamVanAt.pdf - Sentence 576
577,Chúng không thể đem ra sử dụng b ên ngoài l ớp.,LTHDT_PhamVanAt.pdf - Sentence 577
578,+ Một thuộc tính private: Thuộc tính n ày (c ủa một đối t ượng n ào đó) ch ỉ có thể đ ược sử dụng  trong thân c ủa các ph ương th ức cùng l ớp.,LTHDT_PhamVanAt.pdf - Sentence 578
579,+ Một ph ương th ức private: Chỉ đ ược sử dụng trong thân của các ph ương th ức cùng l ớp.,LTHDT_PhamVanAt.pdf - Sentence 579
580,Ví d ụ sau minh hoạ cách d ùng phương th ức private.,LTHDT_PhamVanAt.pdf - Sentence 580
581,Xét lớp PS (phân số) với 2 thuộc tính  nguyên là t (t ử) và m (m ẫu).,LTHDT_PhamVanAt.pdf - Sentence 581
582,"Giả sử cần xây dựng các ph ương th ức để thực hiện các phép toán cộng  trừ, nhân, chia phân số.",LTHDT_PhamVanAt.pdf - Sentence 582
583,"Do các phép toán n ày cần dùng trong toàn b ộ chương tr ình, nên các ph ương  thức thực hiện các phép toán cần khai báo l à public.",LTHDT_PhamVanAt.pdf - Sentence 583
584,Đ ể thực hiện các phép tính tr ên phân s ố cần  dùng đ ến phép rút gọn phân số.,LTHDT_PhamVanAt.pdf - Sentence 584
585,Ta có thể d ùng m ột ph ương th ức private  để l àm đi ều này vì vi ệc rút  gọn chỉ d ùng trong n ội bộ lớp.,LTHDT_PhamVanAt.pdf - Sentence 585
586,7.3.,LTHDT_PhamVanAt.pdf - Sentence 586
587,Các thành ph ần công cộng của lớp  có ph ạm vi sử dụng trong to àn chương tr ình.,LTHDT_PhamVanAt.pdf - Sentence 587
588,"Nh ư vậy nếu  một thuộc tính đ ược khai báo l à public, thì nó có th ể được truy nh ập trong thân của bất kỳ h àm nào  trong chương tr ình.",LTHDT_PhamVanAt.pdf - Sentence 588
589,Ví dụ trong §6 đã chỉ ra ph ương án dùng m ột hàm (t ự do) để thực hiện phép cộng 2 số phức nh ư  sau là sai:   Phương án 3:  Dùng hàm t ự do  class SP   {  private:   double a; // Ph ần thực   double  b; // Ph ần ảo  public:   ...,LTHDT_PhamVanAt.pdf - Sentence 589
590,"} ;  SP  cong(SP u1, SP u2)   {  SP u:   u.a = u1.a  +  u2.a ;   u.b = u1.b  +  u2.b ;   return u;   }  Tuy nhiên n ếu sửa chữa bằng cách  khai báo các thuộc tính a v à b là public thì l ại được.",LTHDT_PhamVanAt.pdf - Sentence 590
591,"Nhận xét:  Các thu ộc tính th ường khai báo l à private đ ể đảm bảo  tính d ấu kín, an to àn dữ liệu  của lớp.",LTHDT_PhamVanAt.pdf - Sentence 591
592,Bài 8.,LTHDT_PhamVanAt.pdf - Sentence 592
593,Các phương th ức toán tử   8.1.,LTHDT_PhamVanAt.pdf - Sentence 593
594,"Cách đ ặt tên Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          95                                         tenshi3003@gmail.com  Các phương th ức toán tử đ ược xây dựng nh ư các phương th ức thông th ường, chỉ có khác cách  đặt tên.",LTHDT_PhamVanAt.pdf - Sentence 594
595,"Tên các phương th ức toán tử (cũng giống nh ư hàm toán t ử) được tạo bằ ng cách ghép t ừ  khoá operator v ới một phép toán, ví dụ:   operator+   operator<<   operator>>   8.2.",LTHDT_PhamVanAt.pdf - Sentence 595
596,"Con tr ỏ this   Cũng giống nh ư phương th ức thông th ường, ph ương th ức toán tử có đối đầu ti ên (đ ối không  tường minh) l à con tr ỏ this.",LTHDT_PhamVanAt.pdf - Sentence 596
597,8.3.,LTHDT_PhamVanAt.pdf - Sentence 597
598,"Toán t ử một toán hạng   Các phương th ức toán tử một toán hạng: D ùng ngay con tr ỏ this để biểu thị toán hạng duy nhất  này, nên trong phương th ức sẽ không có đối t ường minh.",LTHDT_PhamVanAt.pdf - Sentence 598
599,"Ví dụ ph ương th ức toán tử - (đổi dấu) một  đối tượng kiểu SP (số phức) có thể viết nh ư sau:   class SP   {  private:   double a; // Ph ần thực   double  b; // Ph ần ảo   public:   SP operator -();  } ;  SP  SP:: operator -()  {  SP  u ;   u.a = - this->a ;  u.b = - this->b ;  return u;   }  Cách dùng:   SP     u, v;   u  =   -v;   8.4.",LTHDT_PhamVanAt.pdf - Sentence 599
600,"Toán t ử hai toán hạng   Các phương th ức toán tử hai toán hạng: Con  trỏ this ứng với toán hạng thứ nhất, n ên trong  phương th ức chỉ cần d ùng m ột đối t ường minh để biểu thị toán hạng thứ hai.",LTHDT_PhamVanAt.pdf - Sentence 600
601,"Ví dụ ph ương th ức  toán t ử + (cộng) hai đối t ượng kiểu SP (số phức) có thể viết nh ư sau:   class SP   {  private:   double a; // Ph ần thực   double  b; // Ph ần ảo  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          96                                         tenshi3003@gmail.com  public:   SP operator+(SP u2);   } ;  SP  SP:: operator+(SP u2)   {  SP  u ;   u.a =  this ->a + u2.a  ;   u.b =  this ->b + u2.b ;   return u;   }  Cách dùng:   SP     p, p, r;   r  =   p + q ;   8.5.",LTHDT_PhamVanAt.pdf - Sentence 601
602,"L ớp DT (Đa thức)   Chương tr ình sau s ẽ định nghĩa lớp DT v à đưa vào các phương th ức, h àm:  + Các thu ộc tính:   int n ; // b ậc đa thức   double *a ; // tr ỏ tới v ùng nh ớ chứa các hệ số đa thức   + Các phương th ức operator+, operator - dùng đ ể đổi dấu các hệ số đa thức   operator+         dùng đ ể cộng 2 đa thức   operator -          dùng đ ể trừ 2 đa thức   operator*         dùng đ ể nhân 2 đa thức   operator^         dùng đ ể tính giá trị đa thức   operator[]         dùng đ ể cho biết bậc v à hệ số của đa thức   + Các hàm b ạn:  operator<<       dùng đ ể in các hệ số đa thức   operator>>       dùng  để nhập các hệ số đa thức   + Hàm (t ự do)   double F(DT p, double x) dùng đ ể tính p(x) -giá tr ị đa thức tại x   + Nói thêm v ề phương th ức chỉ số v à hàm t ự do F   -  Nếu p l à đối tượng của lớp DT, th ì hàm ch ỉ số cho biết:   p[-1] = double(n)   p[i]   =  a[i] , i=0, 1, ..., n  - Hàm t ự do F sẽ d ùng phương th ức chỉ số để xác định n , các hệ số đa thức v à dùng chúng đ ể  tính giá tr ị đa thức.",LTHDT_PhamVanAt.pdf - Sentence 602
603,+ Trong chương tr ình s ử dụng h àm new đ ể cấp phát v ùng nh ớ chứa hệ số đa thức.,LTHDT_PhamVanAt.pdf - Sentence 603
604,"+ Nội dung ch ương tr ình g ồm:  - Nhập, in các đa thức p, q,  r, s  - Tính đa th ức:  f = -(p + q)*(r - s) Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          97                                         tenshi3003@gmail.com  - Nhập các số thực x1 v à x2  - Tính  f(x1) (b ằng cách d ùng phương th ức operator^)   - Tính  f(x2) (b ằng cách d ùng hàm F)   // Chương tr ình CT3_10.CPP   #include <conio.h>   #include <iostream.h>   #include <math.h>   class  D T  {  private:   int n;   // Bac da thuc   double *a; // Tro toi vung nho chua cac he so da thuc   // a0, a1,...",LTHDT_PhamVanAt.pdf - Sentence 604
605,"public:   friend ostream& operator<< (ostream& os,const DT &d);   friend istream&  operator>> (istream&  is,DT &d);   DT operator -();  DT operator+(const DT &d2);   DT operator -(DT d2);   DT operator*(const DT &d2);   double operator^(const double &x); // Tinh gia tri da thuc   double operator[](int i)   {  if(i<0)   return double(n);   else  return a[i];   }  } ;  // Ham tinh gia tri da thuc   double F(DT d,double x)   {  double s=0.",LTHDT_PhamVanAt.pdf - Sentence 605
606,"0 , t=1.0;   int n;   n = int(d[ -1]);  for (int i=0; i<=n; ++i)   {  s += d[i]*t;   t *= x;   }  return s;   }  ostream& operator<< (ostream& os,const DT &d)  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          98                                         tenshi3003@gmail.com  {  os << "" - Cac he so (tu ao): "" ;   for (int i=0 ; i<= d.n ; ++i)   os <<  d.a[i] <<"" "" ;   return os;   }  istream&  oper ator>> (istream&  is,DT &d)   {  cout << "" - Bac da thuc: "" ;   cin >> d.n;   d.a = new double[d.n+1];   cout << ""Nhap cac he so da thuc: \n"" ;  for (int i=0 ; i<= d.n ; ++i)   {  cout << ""He so bac "" << i << "" = ""  ;   is >> d.a[i] ;   }  return is;   }  DT DT::operator -()  {  DT p;  p.n = n;   p.a = new double[n+1];   for (int i=0 ; i<=n ; ++i)   p.a[i] = -a[i];   return p;   }  DT DT::operator+(const DT &d2)   {  DT d;   int k,i;   k = n > d2.n ?",LTHDT_PhamVanAt.pdf - Sentence 606
607,"n : d2.n ;   d.a = new double[k+1];   for (i=0; i<=k ; ++i)   if (i<=n && i<=d2.n)   d.a[i] = a[i] + d2.a[i];   else if (i<=n)   d.a[i] = a[i];   else  d.a[i] = d2.a[i];  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          99                                         tenshi3003@gmail.com  i=k;  while(i>0 && d.a[i]==0.0) --i;  d.n = i;   return d ;   }  DT DT::operator -(DT d2)   {  return (*this + ( -d2));   }  DT DT::operator*(const DT &d2)   {  DT d;   int k, i, j;   k = d.n = n + d2.n ;   d.a = new double[k+ 1];  for (i=0; i<=k; ++i) d.a[i] = 0;   for (i=0 ; i<= n ; ++i)   for (j=0 ; j<= d2.n ; ++j)   d.a[i+j] += a[i]*d2.a[j] ;   return d;   }  double DT::operator^(const double &x)   {  double s=0.0 , t=1.0;   for (int i=0 ; i<= n ; ++i)   {  s += a[i]*t;   t *= x;   }  return s;   }  void main()   {  DT p,q,r,s,f;   double x1,x2,g1,g2;   clrscr();   cout <<"" \nNhap da thuc P "" ; cin >> p;   cout << "" \nDa thuc p "" << p ;   cout <<"" \nNhap da thuc Q "" ; cin >> q;  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          100                                         tenshi3003@gmail.com  cout << "" \nDa thuc q "" << q ;   cout <<"" \nNhap da thuc R "" ; cin >> r;   cout << "" \nDa thuc r "" << r ;   cout <<"" \nNhap da thuc S "" ; cin >> s;   cout << "" \nDa thuc s "" << s ;   f = -(p+q)*(r -s);  cout << "" \nNhap so thuc x1: "" ; cin >> x1;   cout << "" \nNhap so thuc x2: "" ; cin >> x2;   g1 = f^x1;   g2 = F(f,x2);   cout << "" \nDa thuc f "" << f ;   cout  << "" \n f(""<<x1< <"") = "" << g1;   cout  << "" \n f(""<<x2<<"") = "" << g2;   getch();   }     Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          101                                         tenshi3003@gmail.com  Chương 4   Hàm t ạo, h àm hu ỷ và các    vấn đề li ên quan   Chương này tr ình b ầy một số vấn đề có tính chuy ên sâu hơn v ề lớp nh ư:  + Hàm t ạo (constructor)   + Hàm hu ỷ (destructor)   + Toán t ử gán v à hàm t ạo sao chép   + Mối liên quan gi ữa hàm tạo và đối tượng th ành ph ần   + Các thành ph ần tĩnh   + Lớp bạn, h àm b ạn  + Đối tượng hằng   + Phương th ức inline   Bài 1.",LTHDT_PhamVanAt.pdf - Sentence 607
608,Hàm t ạo (constructor)   1.1.,LTHDT_PhamVanAt.pdf - Sentence 608
609,Công d ụng  Hàm t ạo cũng l à một ph ương th ức của lớp (nh ưng khá đ ặc biệt) d ùng đ ể tạo dựng một đối t ượng  mới.,LTHDT_PhamVanAt.pdf - Sentence 609
610,Ch ương tr ình d ịch sẽ cấp phát bộ nhớ  cho đ ối tượng sau đó sẽ gọi đến h àm tạo.,LTHDT_PhamVanAt.pdf - Sentence 610
611,H àm tạo sẽ  khởi gán giá trị cho các thuộc tính của đối t ượng v à có th ể thực hiện một số công việc khác nhằm  chuẩn bị cho đối t ượng mới.,LTHDT_PhamVanAt.pdf - Sentence 611
612,1.2.,LTHDT_PhamVanAt.pdf - Sentence 612
613,Cách vi ết hàm t ạo  1.2.1.,LTHDT_PhamVanAt.pdf - Sentence 613
614,Đi ểm khác của h àm t ạo và các phương th ức thông t hường  Khi vi ết hàm tạo cần để ý 3 sự khác biệt của h àm tạo so với các ph ương th ức khác nh ư sau:   + Tên c ủa hàm tạo: T ên của hàm tạo bắt buộc phải tr ùng v ới tên của lớp.,LTHDT_PhamVanAt.pdf - Sentence 614
615,+ Không khai báo ki ểu cho h àm tạo.,LTHDT_PhamVanAt.pdf - Sentence 615
616,+  Hàm t ạo không có kết quả trả về.,LTHDT_PhamVanAt.pdf - Sentence 616
617,1.2.2.,LTHDT_PhamVanAt.pdf - Sentence 617
618,"S ự giống n hau c ủa hàm t ạo và các phương th ức thông th ường  Ngoài 3 đi ểm khác biệt tr ên, hàm t ạo được viết nh ư các phương th ức khác:   + Hàm t ạo có thể đ ược xây dựng b ên trong ho ặc bên ngoài đ ịnh nghĩa lớp.",LTHDT_PhamVanAt.pdf - Sentence 618
619,+ Hàm t ạo có thể có đối hoặc không có đối.,LTHDT_PhamVanAt.pdf - Sentence 619
620,+ Trong m ột lớp có t hể có nhiều h àm tạo (c ùng tên nhưng khác b ộ đối).,LTHDT_PhamVanAt.pdf - Sentence 620
621,"Ví dụ sau đ ịnh nghĩa lớp DIEM_DH (Điểm đồ hoạ) có 3 thuộc tính:   int x;  // hoành đ ộ (cột) của điểm   int y;  // tung đ ộ (hàng) c ủa điểm   int m;  // m ầu của điểm   và đưa vào 2 hàm t ạo để khởi gán cho các thuộc tính c ủa lớp:   // Hàm t ạo không đối: D ùng các giá tr ị cố định để khởi gán cho   // x, y, m   DIEM_DH() ;   // Hàm t ạo có đối: D ùng các đ ối x1, y1, m1 để khởi gán cho   // x, y, m  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          102                                         tenshi3003@gmail.com  // Đối m1 có giá trị mặc định 15 (mầu trắng)   DIEM_DH(int x1, int y1, int m1=15) ;   class DIEM_DH   {  private:   int x, y, m ;   public:   //Hàm t ạo không đối: khởi gán cho x=0, y=0, m=1   // Hàm này vi ết bên trong đ ịnh nghĩa lớp   DIEM_DH()   {  x=y=0;   m=1;   }    // Hàm t ạo này xây d ựng b ên ngoài đ ịnh nghĩa lớp   DIEM_DH(int x1, int y1, int m1=15) ;   // Các phương th ức khác   } ;  // Xây d ựng h àm tạo bên ngoài đ ịnh nghĩa lớp   DIEM_DH:: DIEM_DH(int x1, int y1, int m1)   {  x=x1; y=y1; m=m1;   }   1.3.",LTHDT_PhamVanAt.pdf - Sentence 621
622,"Dùng hàm t ạo trong khai báo   + Khi đ ã xây d ựng các h àm tạo, ta có thể d ùng chúng trong khai báo đ ể tạo ra một đối t ượng  đồng thời khởi gán cho các thuộc tính của đối t ượng đ ược tạo.",LTHDT_PhamVanAt.pdf - Sentence 622
623,Dựa v ào các tham s ố trong khai báo  mà Trình biên d ịch sẽ biết cần gọi đến h àm tạo nào.,LTHDT_PhamVanAt.pdf - Sentence 623
624,+ Khi khai báo m ột biến đối t ượng có thể sử dụng các tham số để khởi gán cho các thuộc tính  của biến đối tượng.,LTHDT_PhamVanAt.pdf - Sentence 624
625,+ Khi khai báo m ảng đối t ượng không cho phép d ùng các tham s ố để khởi gán.,LTHDT_PhamVanAt.pdf - Sentence 625
626,+ Câu l ệnh khai báo một biến đối t ượng sẽ gọi tới h àm tạo 1 lần   + Câu l ệnh khai báo một mảng n đối t ượng sẽ gọi tới h àm tạo n lần.,LTHDT_PhamVanAt.pdf - Sentence 626
627,Ví dụ:  DIEM_DH d;  // G ọi tới h àm tạo không  đối.,LTHDT_PhamVanAt.pdf - Sentence 627
628,"//  Kết quả d.x=0, d.y=0, d.m=1   DIEM_DH u(200,100,4);  // G ọi tới h àm tạo có đối.",LTHDT_PhamVanAt.pdf - Sentence 628
629,"//  Kết quả u.x=200, u.y=100, d.m=4   DIEM_DH v(300,250);  // G ọi tới h àm tạo có đối.",LTHDT_PhamVanAt.pdf - Sentence 629
630,"//  Kết quả v.x=300, v.y=250, d.m=15   DIEM_DH  p[10] ; // G ọi tới h àm tạo không đối 10 lần  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          103                                         tenshi3003@gmail.com  Chú ý:  Với các h àm có đ ối kiểu lớp, th ì đối chỉ xem l à các tham s ố hình th ức, v ì vậy khai báo  đối (trong d òng đầu của h àm) s ẽ không tạo ra đối t ượng mới v à do đó không g ọi tới các h àm tạo.",LTHDT_PhamVanAt.pdf - Sentence 630
631,1.4.,LTHDT_PhamVanAt.pdf - Sentence 631
632,"Dùng hàm t ạo trong cấp phát bộ nhớ   + Khi c ấp phát bộ nhớ cho một đối t ượng có thể d ùng các tham s ố để khởi gán cho các thuộc tính  của đối t ượng, ví dụ:   DIEM_DH *q =new DIEM_DH(50,40,6);//G ọi tới h àm tạo có đ ối                                            // Kết quả  q ->x=50, q ->y=40, q ->m=6   DIEM_DH   *r = new DIEM_DH ; // G ọi tới h àm tạo không đối                                              // Kết quả  r ->x=0, r ->y= 0, r ->m=1   + Khi c ấp phát bộ nhớ cho một dẫy đối  tượng không cho phép d ùng tham s ố để khởi gán, ví dụ:   int n=20;   DIEM_DH   *s = new DIEM_DH[n] ; // G ọi tới h àm tạo không   // đối 20 lần.",LTHDT_PhamVanAt.pdf - Sentence 632
633,1.5.,LTHDT_PhamVanAt.pdf - Sentence 633
634,"Dùng hàm t ạo để biểu diễn các đối t ượng hằng   + Như đ ã biết, sau khi định nghĩa lớp DIEM_DH th ì có th ể xem lớp n ày như m ột kiểu dữ liệu  như int, double, char, ...",LTHDT_PhamVanAt.pdf - Sentence 634
635,"Với kiểu int chúng ta có các hằng int, nh ư 356.",LTHDT_PhamVanAt.pdf - Sentence 635
636,"Với kiểu double chúng ta có các hằng double, nh ư 98.75   Khái ni ệm hằng kiểu int, hằng kiểu double có thể mở rộng cho hằng kiểu DIEM_DH   + Để biểu diễn một hằng đối tượng (hay c òn gọi: Đối t ượng hằng) chúng ta phải d ùng t ới hàm  tạo.",LTHDT_PhamVanAt.pdf - Sentence 636
637,"Mẫu viết nh ư sau:   Tên_l ớp(danh sách tham số) ;   Ví dụ đối với lớp DIEM_DH nói tr ên, có th ể viết nh ư sau:     DIEM_DH(345,123,8)  // Bi ểu thị một đối t ượng kiểu DIEM_DH                                            // có các thu ộc tính x=345, y=123, m=8   Chú ý:  Có th ể sử dụng một hằng đối t ượng nh ư một đối t ượng.",LTHDT_PhamVanAt.pdf - Sentence 637
638,"Nói cách khác, có thể d ùng h ằng  đối tượng để thực hiện một ph ương th ức, ví dụ nếu viết:   DIEM_DH(345,123,8).in();   thì có ngh ĩa là thực hi ện ph ương th ức in() đối với hằng đối t ượng.",LTHDT_PhamVanAt.pdf - Sentence 638
639,1.6.,LTHDT_PhamVanAt.pdf - Sentence 639
640,"Ví d ụ minh hoạ   Chương tr ình sau đây minh ho ạ cách xây dựng h àm tạo và cách s ử dùng hàm t ạo trong khai báo,  trong c ấp phát bộ nhớ v à trong vi ệc biểu diễn các hằng đối t ượng.",LTHDT_PhamVanAt.pdf - Sentence 640
641,"//CT4_02.CPP   #include <conio.h>   #include <iostream.h>   #include <iomanip.h>   class DIEM_DH   {  private:   int x,y,m;  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          104                                         tenshi3003@gmail.com  public:   // Hàm b ạn dùng đ ể in đối t ượng DIEM_DH   friend void in(DIEM_DH d)   {  cout <<"" \n "" << d.x << "" ""<< d.y<<"" "" << d.m ;   }  // Phương th ức dùng đ ể in đối t ượng DIEM_DH   void in()   {  cout <<"" \n "" << x << "" ""<< y<<"" "" << m ;   }  //Hàm t ạo không đối   DIEM_DH()   {  x=y=0;   m=1;   }  //Hàm t ạo có đối, đối m1 có giá trị mặc định l à 15 (m ầu trắng)   DIEM_DH(int x1,int y1,int m1=15);   };  //Xây d ựng h àm tạo  DIEM_DH::DIEM_DH(int x1,int y1,int m1)   {  x=x1;  y=y1; m=m1;   }  void main()   {  DIEM_DH d1;  // G ọi tới h àm tạo không đối   DIEM_DH d2(200,200,10); // G ọi tới h àm tạo có đối   DIEM_DH *d;   d= new DIEM_DH(300,300); // G ọi tới h àm tạo có đối   clrscr();   in(d1);  //G ọi hàm b ạn in()   d2.in();//G ọi ph ương th ức in()   in(*d); //G ọi hàm b ạn in()   DIEM_DH(2,2,2).in();//G ọi ph ương th ức in()   DIEM_DH t[3];  // 3 l ần gọi h àm tạo không đối   DIEM_DH *q; // G ọi hàm tạo không đối   int n;   cout << "" \nN= "";   cin >> n;  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          105                                         tenshi3003@gmail.com  q=new DIEM_DH[n+1]; // (n+1) l ần gọi h àm tạo không đối   for (int i=0;i<=n ;++i)   q[i]=DIEM_DH(300+i,200+i,8);//(n+1) l ần gọi h àm tạo có đối   for (i=0;i<=n;++i)   q[i].in();     // G ọi ph ương th ức in()   for (i=0;i<=n;++i)   DIEM_DH(300+i,200+i,8).in();// G ọi ph ương th ức in()   getch();   }  Bài 2.",LTHDT_PhamVanAt.pdf - Sentence 641
642,Lớp không có h àm t ạo và hàm t ạo mặc định   Các chương tr ình nêu trong ch ương 3 đ ều không có h àm tạo.,LTHDT_PhamVanAt.pdf - Sentence 642
643,Vậy khi đó các đối t ượng đ ược  hình thành nh ư thế nào ?,LTHDT_PhamVanAt.pdf - Sentence 643
644,2.1.,LTHDT_PhamVanAt.pdf - Sentence 644
645,"N ếu lớp không có h àm t ạo, Chương tr ình d ịch sẽ cung cấp một h àm tạo mặc định không đối  (default).",LTHDT_PhamVanAt.pdf - Sentence 645
646,Hàm này th ực chất không l àm gì c ả.,LTHDT_PhamVanAt.pdf - Sentence 646
647,"Nh ư vậy một đối t ượng tạo ra chỉ đ ược cấp phát bộ  nhớ, còn các thu ộc tính của nó ch ưa đư ợc xác định.",LTHDT_PhamVanAt.pdf - Sentence 647
648,"Chúng ta có thể kiểm chứng điều n ày, b ằng  cách ch ạy ch ương tr ình sau:   //CT4_03.CPP   // Hàm t ạo mặc định   #include <conio.h>   #include <iostream.h>   class DIEM_DH   {  private:   int x,y,m;   public:   // Phuong thuc   void in()   {  cout <<"" \n "" << x << "" ""<< y<<"" "" << m ;   }  };  void main()   {  DIEM_DH d;   d.in();   DIEM_DH *p;   p= new DIEM_DH[10];   clrscr();   d.in();   for (int i=0;i<10;++i)  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          106                                         tenshi3003@gmail.com  (p+i) ->in();   getch();   }  2.2.",LTHDT_PhamVanAt.pdf - Sentence 648
649,"N ếu trong lớp đ ã có ít nhất một h àm t ạo, thì hàm t ạo mặc định sẽ không đ ược phát sinh nữa.",LTHDT_PhamVanAt.pdf - Sentence 649
650,Khi đó m ọi câu lệnh xây dựng đối t ượng mới đều sẽ gọi đến một h àm tạo của lớp.,LTHDT_PhamVanAt.pdf - Sentence 650
651,Nếu không t ìm  thấy hàm tạo cần gọi th ì Chương tr ình d ịch sẽ báo lỗi.,LTHDT_PhamVanAt.pdf - Sentence 651
652,"Điều n ày thư ờng xẩy ra khi chúng ta khôn g  xây d ựng h àm tạo không đối, nh ưng l ại sử dụng các khai báo không tham số nh ư ví d ụ sau:   #include <conio.h>   #include <iostream.h>   class DIEM_DH   {  private:   int x,y,m;   public:   // Phương th ức dùng đ ể in đối t ượng DIEM_DH   void in()   {  cout <<"" \n "" << x << "" ""< < y<<"" "" << m ;   }  //Hàm t ạo có đối   DIEM_DH::DIEM_DH(int x1,int y1,int m1)   {  x=x1; y=y1; m=m1;   }  };  void main()   {  DIEM_DH d1(200,200,10); // G ọi tới h àm tạo có đối   DIEM_DH d2;  // G ọi tới h àm tạo không đối   d2= DIEM_DH(300,300,8); // G ọi tới h àm tạo có đối   d1.in();   d2.in();   getch();   }  Trong các câu l ệnh tr ên, ch ỉ có câu lệnh thứ 2 trong h àm main() là b ị báo lỗi.",LTHDT_PhamVanAt.pdf - Sentence 652
653,"Câu lệnh n ày sẽ gọi  tới hàm tạo không đối, m à hàm này chưa đư ợc xây dựng.",LTHDT_PhamVanAt.pdf - Sentence 653
654,Giải pháp:  Có th ể chọn một trong 2 giải pháp sau:   - Xây d ựng th êm hàm t ạo không đ ối.,LTHDT_PhamVanAt.pdf - Sentence 654
655,"- Gán giá tr ị mặc định cho tất cả các đối x1, y1 v à m1 c ủa hàm tạo đã xây d ựng ở tr ên.",LTHDT_PhamVanAt.pdf - Sentence 655
656,"Theo phương án 2, chương tr ình có th ể sửa nh ư sau:   #include <conio.h>  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          107                                         tenshi3003@gmail.com  #include <iostream.h>   class DIEM_DH   {  private:   int x,y,m;   public:   // Phương th ức dùng đ ể in đối tượng DIEM_DH   void in()   {  cout <<"" \n "" << x << "" ""<< y<<"" "" << m ;   }  //Hàm t ạo có đối , tất cả các đối đều có giá trị mặc định   DIEM_DH::DIEM_DH(int x1=0,int y1=0,int m1=15)   {  x=x1; y=y1; m=m1;   }  };  void main()   {  DIEM_DH d1(200,200,10); // G ọi tới h àm tạo, không d ùng   // tham s ố mặc định   DIEM_DH d2;  // G ọi tới h àm tạo , d ùng 3 tham s ố mặc định   d2= DIEM_DH(300,300); // G ọi tới h àm tạo, d ùng 1 tham s ố  // mặc định   d1.in();   d2.in();   getch();   }  Bài 3.",LTHDT_PhamVanAt.pdf - Sentence 656
657,Lớp đa thức   Chương tr ình d ưới đây l à sự cải tiến ch ương trình trong m ục 8.5 của ch ương 3 b ằng cách đ ưa  vào 2 hàm t ạo:  //Hàm t ạo không đối   DT()   {  this->n=0; this ->a=NULL;   }  //Hàm t ạo có đối   DT(int n1)   {  this->n=n1 ;   this->a = new double[n1+1];   } Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          108                                         tenshi3003@gmail.com  Hàm t ạo có đối sẽ tạo một đối t ượng mới (kiểu DT) gồm 2 thuộc tín h là bi ến nguy ên n và con tr ỏ  a.,LTHDT_PhamVanAt.pdf - Sentence 657
658,Ngoài ra còn c ấp phát bộ v ùng nh ớ (cho a) để chứa các hệ số của đa thức.,LTHDT_PhamVanAt.pdf - Sentence 658
659,"Nếu không xây dựng h àm tạo, m à sử dụng h àm tạo mặc định th ì các đối tượng (kiểu DT) tạo ra  bởi các lệnh khai báo sẽ ch ưa có b ộ nhớ để chứa đa thức.",LTHDT_PhamVanAt.pdf - Sentence 659
660,Như v ậy đối t ượng tạo ra ch ưa hoàn ch ỉnh  và chưa dùng đư ợc.,LTHDT_PhamVanAt.pdf - Sentence 660
661,"Để có một đối t ượng ho àn ch ỉnh phải qua 2 b ước:  + Dùng khai báo đ ể tạo các đối t ượng, ví dụ:   DT d;   + Cấp phát v ùng nh ớ (cho đối t ượng) để chứa đa thức, ví dụ:   d.n =  m;   d.a = new double[m+1] ;   Quy trình này được áp dụng trong các ph ương th ức toán tử của ch ương tr ình trong m ục 8.5  chương 3.",LTHDT_PhamVanAt.pdf - Sentence 661
662,"R õ ràng quy trình này v ừa dài vừa không tiện lợi, lại hay mắc lỗi, v ì người lập tr ình hay  quên không c ấp phát bộ nhớ.",LTHDT_PhamVanAt.pdf - Sentence 662
663,"Việc dùng các hàm t ạo để sản sinh ra các đố i tượng ho àn ch ỉnh tỏ ra tiện lợi h ơn, v ì tránh được  các thao tác ph ụ (nh ư cấp phát bộ nhớ) nằm b ên ngoài khai báo.",LTHDT_PhamVanAt.pdf - Sentence 663
664,"Phương án dùng  hàm t ạo sẽ đ ược  sử dụng trong các ph ương th ức toán tử của ch ương tr ình d ưới đây:   + Nội dung ch ương tr ình g ồm:  - Nhập, in các  đa th ức p, q, r, s   - Tính đa th ức:  f = -(p + q)*(r - s)  - Nhập các số thực x1 v à x2  - Tính  f(x1) (b ằng cách d ùng phương th ức operator^)   - Tính  f(x2) (b ằng cách d ùng hàm F)   // CT4_05.CPP   #include <conio.h>   #include <iostream.h>   #include <math.h>   class  DT  {  private:   int n;   // Bac da thuc   double *a; // Tro toi vung nho chua cac he so da thuc   // a0, a1,...",LTHDT_PhamVanAt.pdf - Sentence 664
665,"public:   DT()   {  this->n=0; this ->a=NULL;   }  DT(int n1)   {  this->n=n1 ;   this->a = new double[n1+1];   }  friend ostream& operator<< (ostream& os,const DT &d ); Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          109                                         tenshi3003@gmail.com  friend istream&  operator>> (istream&  is,DT &d);   DT operator -();  DT operator+(const DT &d2);   DT operator -(DT d2);   DT operator*(const DT &d2);   double operator^(const double &x); // Tinh gia tri da thuc   double operator[](int i)   {  if (i<0)   return double(n );  else  return a[i];   }  } ;  // Ham tinh gia tri da thuc   double F(DT d,double x)   {  double s=0.0 , t=1.0;   int n;   n = int(d[ -1]);  for (int i=0; i<=n; ++i)   {  s += d[i]*t;   t *= x;   }  return s;   }  ostream& operator<< (ostream& os,const DT &d)   {  os << "" - Cac he so (tu ao): "" ;   for (int i=0 ; i<= d.n ; ++i)   os <<  d.a[i] <<"" "" ;   return os;   }  istream&  operator>> (istream&  is,DT &d)   {  if (d.a!=NULL) delete d.a;   cout << "" - Bac da thuc: "" ;   cin >> d.n;   d.a = new double[d.n+1];  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          110                                         tenshi3003@gmail.com  cout << ""Nhap cac he so da thuc: \n"" ;  for (int i=0 ; i<= d.n ; ++i)   {  cout << ""He so bac "" << i << "" = ""  ;   is >> d.a[i] ;   }  return is;   }  DT DT::operator -()  {  DT p(this ->n);  for (int i=0 ; i<=n ; ++i)   p.a[i] = -a[i];   return p;   }  DT DT::operator+(const DT &d2)   {  int k,i;   k = n > d2.n ?",LTHDT_PhamVanAt.pdf - Sentence 665
666,"n : d2.n ;   DT d(k);   for (i=0; i<=k ; ++i)   if (i<=n && i<=d2.n)   d.a[i] = a[i] + d2.a[i];   else if (i<=n)   d.a[i] = a[i];   else  d.a[i] = d2.a[i];   i=k;  while(i>0 && d.a[i]==0.0) --i;  d.n = i;   return d ;   }  DT DT::operator -(DT d2)   {  return (*this + ( -d2));   }  DT DT::operator* (const DT &d2)   {  int k, i, j;  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          111                                         tenshi3003@gmail.com  k =  n + d2.n ;   DT d(k);   for (i=0; i<=k; ++i) d.a[i] = 0;   for (i=0 ; i<= n ; ++i)   for (j=0 ; j<= d2.n ; ++j)   d.a[i+j] += a[i]*d2.a[j] ;   return d;   }  double DT::operator^(const double &x)   {  double s=0.0 , t=1.0;   for (int i=0 ; i <= n ; ++i)   {  s += a[i]*t;   t *= x;   }  return s;   }  void main()   {  DT p,q,r,s,f;   double x1,x2,g1,g2;   clrscr();   cout <<"" \nNhap da thuc P "" ; cin >> p;   cout << "" \nDa thuc p "" << p ;   cout <<"" \nNhap da thuc Q "" ; cin >> q;   cout << "" \nDa thuc q "" << q ;   cout <<"" \nNhap da thuc R "" ; cin >> r;   cout << "" \nDa thuc r "" << r ;   cout <<"" \nNhap da thuc S "" ; cin >> s;   cout << "" \nDa thuc s "" << s ;   f = -(p+q)*(r -s);  cout << "" \nNhap so thuc x1: "" ; cin >> x1;   cout << "" \nNhap so thuc x2: "" ; cin >> x2;   g1 = f^x1;   g2 = F(f,x2);   cout << "" \nDa thuc f "" << f ;   cout  << "" \n f(""<<x1<<"") = "" << g1;   cout  << "" \n f(""<<x2<<"") = "" << g2;   getch();  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          112                                         tenshi3003@gmail.com  }     Bài 4.",LTHDT_PhamVanAt.pdf - Sentence 666
667,Hàm t ạo sao chép (copy constructor)   4.1.,LTHDT_PhamVanAt.pdf - Sentence 667
668,"Hàm t ạo sao chép mặc định   Giả sử đ ã định nghĩa một lớp n ào đó, ví d ụ lớp PS (phân số).",LTHDT_PhamVanAt.pdf - Sentence 668
669,"Khi đó:   + Ta có th ể dùng câu l ệnh khai báo hoặc cấp phát bộ nhớ  để tạo các đối t ượng mới, ví dụ:   PS  p1, p2 ;   PS  *p = new PS ;   + Ta cũng có thể d ùng l ệnh khai báo để tạo một đối t ượng mới từ một đối t ượng đ ã tồn tại, ví dụ:   PS  u;   PS  v(u) ; // T ạo v theo u   ý ngh ĩa của câu lệnh n ày như sau:   - Nếu trong lớp PS ch ưa xây d ựng h àm tạo sao chép, th ì câu l ệnh n ày sẽ gọi tới một h àm tạo sao   chép m ặc định (của C++).",LTHDT_PhamVanAt.pdf - Sentence 669
670,H àm này s ẽ sao chép nội dung từng bit của u v ào các bit tương ứng của  v.,LTHDT_PhamVanAt.pdf - Sentence 670
671,Như v ậy các v ùng nh ớ của u v à v s ẽ có nội dung nh ư nhau.,LTHDT_PhamVanAt.pdf - Sentence 671
672,"R õ ràng trong đa số các tr ường hợp,  nếu lớp không có các thuộc tính kiểu con trỏ hay tham chiếu, th ì việc dùng các hàm t ạo sao chép  mặc định (để tạo ra một đối t ượng mới có nội dung nh ư một đối t ượng cho tr ước) l à đủ và không  cần xây dựng một h àm tạo sao chép mới.",LTHDT_PhamVanAt.pdf - Sentence 672
673,"- Nếu trong lớp PS đ ã có hàm t ạo sao chép (cách viết sẽ nói sau) th ì câu l ệnh:  PS  v(u) ;   sẽ tạo ra đối t ượng mới v, sau đó gọi tới h àm tạo sao chép để khởi gán v theo u.",LTHDT_PhamVanAt.pdf - Sentence 673
674,Ví dụ sau minh ho ạ cách d ùng hàm t ạo sao chép mặc định:   Trong chương tr ình đưa vào l ớp PS (phân số):   + Các thu ộc tính gồm: t (tử số) v à m (m ẫu).,LTHDT_PhamVanAt.pdf - Sentence 674
675,+ Trong l ớp không có ph ương th ức nào c ả mà chỉ có 2 h àm b ạn là các hàm toán t ử nhập (>>) v à  xuất (<<).,LTHDT_PhamVanAt.pdf - Sentence 675
676,+ Nội dung ch ương tr ình là: Dùng l ệnh khai báo để tạo một đối t ương u (ki ểu PS) có nội dung  như đ ối tượng đ ã có d.,LTHDT_PhamVanAt.pdf - Sentence 676
677,"//CT4_06.CPP   // Ham tao sao chep mac dinh   #include <conio.h>   #include  <iostream.h>   class PS   {  private:   int t,m ;   public:   friend ostream& operator<< (ostream& os,const PS &p)   {  os << ""  =  "" << p.t << ""/"" << p.m;   return os;   } Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          113                                         tenshi3003@gmail.com  friend  istream&  operator>> (istream&  is, PS &p)   {  cout << "" -  Nhap tu va mau:  "" ;   is >> p.t >> p.m  ;   return is;   }  };  void main()   {  PS d;   cout << "" \n Nhap PS d""; cin >> d;   cout << "" \n PS d "" << d;   PS u(d);   cout << "" \n PS u "" << u;   getch();   }  4.2.",LTHDT_PhamVanAt.pdf - Sentence 677
678,Cách xây d ựng h àm t ạo sao chép   + Hàm t ạo sao chép sử dụng một đối kiểu tham chiếu đối t ượng để khởi gán cho đối t ượng  mới.,LTHDT_PhamVanAt.pdf - Sentence 678
679,"H àm tạo sao chép đ ược viết theo mẫu:   Tên_l ớp  (const T ên_lớp  & dt)   {  // Các câu l ệnh d ùng các thu ộc tính của đối t ượng dt   // để khởi gán cho c ác thu ộc tính của đối t ượng mới   }  + Ví dụ có th ể xây dựng h àm tạo sao chép cho lớp PS nh ư sau:   class PS   {  private:   int t,m ;   public:   PS (const PS  &p)   {  this->t = p.t ;   this->m = p.m ;   }  ...",LTHDT_PhamVanAt.pdf - Sentence 679
680,} ;  4.3.,LTHDT_PhamVanAt.pdf - Sentence 680
681,Khi nào c ần xây dựng h àm t ạo sao chép   + Nh ận xét:  Hàm t ạo sao chép trong ví dụ tr ên không khác gì hàm t ạo sao chép mặc định.,LTHDT_PhamVanAt.pdf - Sentence 681
682,"Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          114                                         tenshi3003@gmail.com  + Khi l ớp không có các thuộc tính kiểu con trỏ hoặc tham chiếu, th ì dùng hàm t ạo sao chép mặc  định là đủ.",LTHDT_PhamVanAt.pdf - Sentence 682
683,"+ Khi l ớp có các thuộc tính con trỏ hoặc tham chiếu, th ì hàm t ạo sao chép mặc đ ịnh ch ưa đáp  ứng đ ược yêu cầu.",LTHDT_PhamVanAt.pdf - Sentence 683
684,"Ví dụ lớp DT (đa thức) trong §3:  class  DT   {  private:   int n;   // Bac da thuc   double *a; // Tro toi vung nho chua cac he so da thuc   // a0, a1,...",LTHDT_PhamVanAt.pdf - Sentence 684
685,"public:   DT()   {  this->n=0; this ->a=NULL;   }  DT(int n1)   {  this->n=n1 ;   this->a = new double[n1+1];   }  friend ostream& operator<< (ostream& os,const DT &d);   friend istream&  operator>> (istream&  is,DT &d);   ....",LTHDT_PhamVanAt.pdf - Sentence 685
686,"} ;  Bây gi ờ chúng ta h ãy theo rõi xem vi ệc dùng hàm t ạo mặc định trong đoạn ch ương tr ình sau s ẽ  dẫn đến sai lầm nh ư thế nào:  DT   d ;    // Tạo đối t ượng d kiểu DT   cin  >> d ;   /* Nh ập đối t ượng d , gồm: nhập một số nguy ên dương và       gán cho d.n, c ấp phát v ùng nh ớ cho d.a, nhập các hệ số       của đa thức v à chứa vào vùng nh ớ được cấp phát   */  DT  u(d) ;   /* Dùng hàm t ạo mặc định để  xây d ựng đối t ượng u theo d   Kết quả: u.n = d.n v à u.a = d.a.",LTHDT_PhamVanAt.pdf - Sentence 686
687,Như v ậy 2 con trỏ u.a v à  d.a cùng tr ỏ đến một v ùng nh ớ.,LTHDT_PhamVanAt.pdf - Sentence 687
688,"*/  Nhận xét:  Mục đích của ta l à tạo ra một đối t ượng u giống nh ư d, nhưng đ ộc lập với d.",LTHDT_PhamVanAt.pdf - Sentence 688
689,Nghĩa l à  khi d thay đ ổi thì u không b ị ảnh h ưởng gì.,LTHDT_PhamVanAt.pdf - Sentence 689
690,"Th ế nhưng m ục tiêu này không đ ạt được, v ì u và d có Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          115                                         tenshi3003@gmail.com  chung m ột vùng nh ớ chứa hệ số của đa thức, n ên khi s ửa đổi các hệ số của đa thức trong d th ì các  hệ số của đa thức trong u cũng thay đổi theo.",LTHDT_PhamVanAt.pdf - Sentence 690
691,C òn m ột trường hợp nữa cũng dẫn đến lỗi l à khi m ột  trong 2 đối tượng u v à d b ị giải phóng (thu hồi v ùng nh ớ chứa đa thức) th ì đối tượng c òn lại cũng sẽ  không còn vùng nh ớ nữa.,LTHDT_PhamVanAt.pdf - Sentence 691
692,Ví dụ sau sẽ minh hoạ nhận xét tr ên: Khi d thay đ ổi thì u cũng thay đổi v à ngư ợc lại khi u thay  đổi thì d cũng thay đổi  theo.,LTHDT_PhamVanAt.pdf - Sentence 692
693,"//CT4_07.C PP  #include <conio.h>   #include <iostream.h>   #include <math.h>   class  DT   {  private:   int n;   // Bac da thuc   double *a; // Tro toi vung nho chua cac he so da thuc   // a0, a1,...",LTHDT_PhamVanAt.pdf - Sentence 693
694,"public:   DT()   {  this->n=0; this ->a=NULL;   }  DT(int n1)   {  this->n=n1 ;   this->a = ne w double[n1+1];   }  friend ostream& operator<< (ostream& os,const DT &d);   friend istream&  operator>> (istream&  is,DT &d);   } ;  ostream& operator<< (ostream& os,const DT &d)   {  os << "" - Cac he so (tu ao): "" ;   for (int i=0 ; i<= d.n ; ++i)   os <<  d.a[i] <<"" ""  ;  return os;   }  istream&  operator>> (istream&  is,DT &d)   {  if (d.a!=NULL) delete d.a;   cout << "" - Bac da thuc: "" ;   cin >> d.n;   d.a = new double[d.n+1];   cout << ""Nhap cac he so da thuc: \n"" ;  for (int i=0 ; i<= d.n ; ++i)  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          116                                         tenshi3003@gmail.com  {  cout << ""He so bac "" << i << "" = ""  ;  is >> d.a[i] ;   }  return is;   }  void main()   {  DT d;   clrscr();   cout <<"" \nNhap da thuc d "" ; cin >> d;   DT u(d);   cout << "" \nDa thuc d "" << d ;   cout << "" \nDa thuc u "" << u ;   cout <<"" \nNhap da thuc d "" ; cin >> d;   cout << "" \nDa thuc d "" << d ;   cout << "" \nDa thuc u "" << u ;   cout <<"" \nNhap da thuc u "" ; cin >> u;   cout << "" \nDa thuc d "" << d ;   cout << "" \nDa thuc u "" << u ;        getch();   }  4.4.",LTHDT_PhamVanAt.pdf - Sentence 694
695,Ví d ụ về h àm t ạo sao chép   Trong chương tr ình trên đã chỉ rõ: Hàm t ạo sao chép mặc định l à chưa tho ả mãn đối với lớp DT.,LTHDT_PhamVanAt.pdf - Sentence 695
696,Vì vậy cần viết h àm tạo sao chép để xây dựng đối t ượng mới ( ví dụ u) từ một đối t ượng đang tồn  tại (ví dụ d) theo các y êu cầu sau:   + Gán d.n cho u.n   + Cấp phát một v ùng nh ớ cho u.a để có thể chứa đ ược (d.n + 1) hệ số.,LTHDT_PhamVanAt.pdf - Sentence 696
697,"+ Gán các h ệ số chứa trong v ùng nh ớ của d.a sang v ùng nh ớ của u.a   Như vây chúng ta s ẽ tạo đ ược đối t ượng u có nội dung ban đầu giống nh ư d, nhưng đ ộc lập với  d.",LTHDT_PhamVanAt.pdf - Sentence 697
698,"Để đáp ứng các y êu cầu nêu trên, hàm t ạo sao chép cần đ ược xây dựng nh ư sau:   DT::DT(const DT &d)   {  this->n = d.n;   this->a = new doub le[d.n+1];   for (int i=0;i<=d.n;++i)     this->a[i] = d.a[i];   }  Chương tr ình sau s ẽ minh hoạ điều n ày: S ự thay đổi của d không l àm ảnh h ưởng đến u v à ngư ợc  lại sự thay đổi của u không l àm ảnh h ưởng đến d.",LTHDT_PhamVanAt.pdf - Sentence 698
699,"Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          117                                         tenshi3003@gmail.com  //CT4_08.CPP   // Viết hàm tạo sao chép cho lớp DT   #incl ude <conio.h>   #include <iostream.h>   #include <math.h>   class  DT   {  private:   int n;   // Bac da thuc   double *a; // Tro toi vung nho chua cac he so da thuc   // a0, a1,...",LTHDT_PhamVanAt.pdf - Sentence 699
700,"public:   DT()   {  this->n=0; this ->a=NULL;   }  DT(int n1)   {  this->n=n1 ;   this->a = new double [n1+1];   }  DT(const DT &d);   friend ostream& operator<< (ostream& os,const DT &d);   friend istream&  operator>> (istream&  is,DT &d);   } ;  DT::DT(const DT &d)   {  this->n = d.n;   this->a = new double[d.n+1];   for (int i=0;i<=d.n;++i)   this->a[i] = d.a[i];   }  ostream & operator<< (ostream& os,const DT &d)   {  os << "" - Cac he so (tu ao): "" ;   for (int i=0 ; i<= d.n ; ++i)   os <<  d.a[i] <<"" "" ;   return os;   }  istream&  operator>> (istream&  is,DT &d)  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          118                                         tenshi3003@gmail.com  {  if (d.a!=NULL) delete d.a;   cout << "" - Bac da thuc: "" ;   cin >> d.n;   d.a =  new double[d.n+1];   cout << ""Nhap cac he so da thuc: \n"" ;  for (int i=0 ; i<= d.n ; ++i)   {  cout << ""He so bac "" << i << "" = ""  ;   is >> d.a[i] ;   }  return is;   }  void main()   {  DT d;   clrscr();   cout <<"" \nNhap da thuc d "" ; cin >> d;   DT u(d);   cout << "" \nDa thuc d  "" << d ;   cout << "" \nDa thuc u "" << u ;   cout <<"" \nNhap da thuc d "" ; cin >> d;   cout << "" \nDa thuc d "" << d ;   cout << "" \nDa thuc u "" << u ;   cout <<"" \nNhap da thuc u "" ; cin >> u;   cout << "" \nDa thuc d "" << d ;   cout << "" \nDa thuc u "" << u ;   getch();   }    Bài 5.",LTHDT_PhamVanAt.pdf - Sentence 700
701,Hàm hu ỷ (Destructor)   5.1.,LTHDT_PhamVanAt.pdf - Sentence 701
702,Công d ụng của h àm hu ỷ  Hàm hu ỷ là một hàm thành viên c ủa lớp (ph ương th ức) có chức năng ng ược với h àm tạo.,LTHDT_PhamVanAt.pdf - Sentence 702
703,"H àm  huỷ được gọi tr ước khi giải phóng (xoá bỏ) một đối t ượng để thực hiện một số công việc có tính  “dọn dẹp” tr ước khi đối t ượng đ ược huỷ bỏ, ví dụ nh ư giải phóng một v ùng nh ớ mà đối tượng đang  quản lý, xoá đối t ượng khỏi m àn hình n ếu nh ư nó đang hi ển thị, ...",LTHDT_PhamVanAt.pdf - Sentence 703
704,"Việc huỷ bỏ một đối t ượng th ường xẩy ra trong 2 tr ường hợp sau:   + Trong các toán t ử và các hàm gi ải phóng bộ nhớ, nh ư delete,  free,...",LTHDT_PhamVanAt.pdf - Sentence 704
705,"+  Gi ải phóng các biến, mảng cục bộ khi thoát khỏi h àm, phương th ức.",LTHDT_PhamVanAt.pdf - Sentence 705
706,Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          119                                         tenshi3003@gmail.com  5.2.,LTHDT_PhamVanAt.pdf - Sentence 706
707,"Hàm hu ỷ mặc định   Nếu trong lớp không định nghĩa h àm hu ỷ, thì một hàm hu ỷ mặc định không l àm gì c ả được phát  sinh.",LTHDT_PhamVanAt.pdf - Sentence 707
708,"Đ ối với nhiều lớp th ì hàm hu ỷ mặc định l à đủ, và không c ần đưa vào m ột hàm hu ỷ mới.",LTHDT_PhamVanAt.pdf - Sentence 708
709,5.3.,LTHDT_PhamVanAt.pdf - Sentence 709
710,"Quy t ắc viết h àm hu ỷ  Mỗi lớp chỉ có một h àm hu ỷ viết theo các quy tắc sau:   + Kiểu của h àm: Hàm hu ỷ cũng giống nh ư hàm t ạo là hàm không có ki ểu, không có giá trị trả về.",LTHDT_PhamVanAt.pdf - Sentence 710
711,"+ Tên hàm: Tên c ủa hàm hu ỷ gồm một dẫu ng ã (đứng tr ước) và tên l ớp:  ~Tên_l ớp  + Đối: H àm hu ỷ không có đối   Ví dụ có thể xây dựng h àm hu ỷ cho lớp DT (đa thức) ở §3 như sau:   class  DT   {  private:   int n;   // Bac da thuc   double *a; // Tro toi vung nho chua cac he so da thuc   // a0, a1,...",LTHDT_PhamVanAt.pdf - Sentence 711
712,public:   ~DT()   {  this->n=0;   delete this ->a;  }  ...,LTHDT_PhamVanAt.pdf - Sentence 712
713,} ;  5.4.,LTHDT_PhamVanAt.pdf - Sentence 713
714,Vai trò c ủa hàm hu ỷ trong lớp DT   5.4.1.,LTHDT_PhamVanAt.pdf - Sentence 714
715,"Khi ếm khuyết của ch ương tr ình trong  bài 3   Chương tr ình trong §3 định nghĩa lớp DT (đa thức) khá đầy đủ gồm:   + Các hàm t ạo  + Các hàm toán t ử nhập >>, xuất <<   + Các hàm toán t ử thực hiện các phép tính + - *  Tuy nhiên v ẫn còn thi ếu hàm hu ỷ để giải phóng v ùng nh ớ mà đối tượng kiểu DT (cần huỷ) đang  quản lý.",LTHDT_PhamVanAt.pdf - Sentence 715
716,"Chúng ta hãy phân tích các khi ếm khuyết của ch ương tr ình này:   + Khi chương tr ình g ọi tới một ph ương th ức toán tử để thực hiện các phép t ính c ộng, trừ, nhân  đa th ức, th ì một đối t ượng trung gian đ ược tạo ra.",LTHDT_PhamVanAt.pdf - Sentence 716
717,Một v ùng nh ớ được cấp phát v à giao cho nó (đ ối  tượng trung gian) quản lý.,LTHDT_PhamVanAt.pdf - Sentence 717
718,+ Khi th ực hiện xong phép tính sẽ ra khỏi ph ương th ức.,LTHDT_PhamVanAt.pdf - Sentence 718
719,"Đối t ượng trung gian bị xoá, tuy nhi ên  chỉ vùng nh ớ của các thu ộc tính của đối t ượng n ày đư ợc giải phóng.",LTHDT_PhamVanAt.pdf - Sentence 719
720,C òn vùng nh ớ (chứa các hệ số  của đa thức) m à đối tượng trung gian đang quản lý th ì không h ề bị giải phóng.,LTHDT_PhamVanAt.pdf - Sentence 720
721,Nh ư vậy số v ùng  nhớ bị chiếm dụng vô ích sẽ tăng l ên.,LTHDT_PhamVanAt.pdf - Sentence 721
722,Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          120                                         tenshi3003@gmail.com  5.4.2.,LTHDT_PhamVanAt.pdf - Sentence 722
723,Cách kh ắc phục   Nhược điểm tr ên dễ dàng khắc phục bằng cách đ ưa vào l ớp DT h àm hu ỷ viết trong 5.3 (mục  trên).,LTHDT_PhamVanAt.pdf - Sentence 723
724,5.5.,LTHDT_PhamVanAt.pdf - Sentence 724
725,"L ớp h ình tròn đồ hoạ   Chương tr ình d ưới đây gồm:   Lớp HT (h ình tròn) v ới các thuộc tính:   int r;    // Bán kính   int m ; // M ầu hình tròn   int  xhien,yhien;  // V ị trí hiển thị h ình trò n trên màn hình   char *pht;         // Con tr ỏ trỏ tới v ùng nh ớ chứa ảnh h ình tròn   int  hienmh;      // Tr ạng thái hiện (hienmh=1), ẩn (hienmh=0)   Các phương th ức:  + Hàm t ạo không đối   HT();   thực hiện việc gán giá trị bằng 0 cho các thuộc tính của lớp.",LTHDT_PhamVanAt.pdf - Sentence 725
726,"+ Hàm  tạo có đối   HT(int r1,int m1=15);   thực hiện các việc:   - Gán  r1 cho r, m1 cho m   - Cấp phát bộ nhớ cho pht   - Vẽ hình tròn và l ưu ảnh h ình tròn vào vùng nh ớ của pht   + Hàm hu ỷ  ~HT();   thực hiện các việc:   - Xoá hình tròn kh ỏi màn hình (n ếu đang hiển thị)   - Giải phóng b ộ nhớ đ ã cấp cho pht   + Phương th ức  void hien(int x, int y);   có nhi ệm vụ hiển thị h ình tròn t ại (x,y)   + Phương th ức  void an();   có nhi ệm vụ l àm ẩn hình tròn   Các hàm đ ộc lập:   void ktdh();  //Kh ởi tạo đồ hoạ   void ve_bau_troi(); // V ẽ bầu trời đầy sao   void ht_di_dong_xuong(); // V ẽ một cặp 2 h ình tròn di   // chuy ển xuống   void ht_di_dong_len();// V ẽ một cặp 2 h ình tròn di   // chuy ển lên trên   Nội dung ch ương tr ình là t ạo ra các chuyển động xuống v à lên c ủa các h ình tròn.",LTHDT_PhamVanAt.pdf - Sentence 726
727,"Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          121                                         tenshi3003@gmail.com  //CT4_09.CPP   // Lop do hoa   // Ham huy  // Trong ham huy co the goi PT khac   #include <conio.h>   #include <iostream.h>   #include <math.h>   #include <stdlib.h>   #include <graphics.h>   #include <dos.h>   void ktdh();   void ve_bau_troi();   void ht_di_dong_xuong();   void ht_di_dong_len();   int xmax,ymax;   class HT   {  private:   int r,m ;   int xhien,yhien;   char *pht;   int hienmh;   public:   HT();   HT(int r1,int m1=15);   ~HT();   void hien(int x, int y);   void an();   };  HT:: HT()   {  r=m=hienmh=0;   xhien=yhien=0;   pht=NULL;   }    HT::HT(int r1,int m1)   {  r=r1; m=m1; hienmh=0;   xhien= yhien=0;  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          122                                         tenshi3003@gmail.com  if (r<0) r=0;   if (r==0)   {  pht=NULL;   }  else  {  int size; char *pmh;   size = imagesize(0,0,r+r,r+r);   pmh = new char[size];   getimage(0,0,r+r,r+r,pmh);   setcolor(m);   circle(r,r,r);   setfillstyle(1,m);   floodfill(r,r,m);   pht = new char[size];   getimage(0,0,r +r,r+r,pht);   putimage(0,0,pmh,COPY_PUT);   delete pmh;   pmh=NULL;   }  }  void HT::hien(int x, int y)   {  if (pht!=NULL && !hienmh) // chua hien   {  hienmh=1;   xhien=x; yhien=y;   putimage(x,y,pht,XOR_PUT);   }  }  void HT::an()   {  if (hienmh) // dang hien   {  hienmh=0;   putima ge(xhien,yhien,pht,XOR_PUT);   }  }  HT::~HT()   { Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          123                                         tenshi3003@gmail.com  an();   if (pht!=NULL)   {  delete pht;   pht=NULL;   }  }  void ktdh()   {  int mh=0,mode=0;   initgraph(&mh,&mode,"""");   xmax = getmaxx();   ymax = getmaxy();   }    void ve_bau_troi()   {  for (int i=0;i<2000;++i)   putpixel(random(xmax) , random(ymax), 1+random(15));   }  void ht_di_dong_xuong()   {  HT h(50,4);   HT u(60,15);   h.hien(0,0);   u.hien(40,0);   for (int x=0;x<=340;x+=10)   {  h.an();   u.an();   h.hien(x,x);   delay(200);   u.hien(x+40,x);   delay(200);   }  }  void ht_di_dong_len()   {  HT h(50,4);   HT u(60 ,15);  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          124                                         tenshi3003@gmail.com  h.hien(340,340);   u.hien(380,340);   for (int x=340;x>=0;x -=10)   {  h.an();   u.an();   h.hien(x,x);   delay(200);   u.hien(x+40,x);   delay(200);   }  }  void main()   {  ktdh();   ve_bau_troi();   ht_di_dong_xuong();   ht_di_dong_len();   getch();   closegraph();   }  Các nh ận xét:   1.",LTHDT_PhamVanAt.pdf - Sentence 727
728,Trong thân hàm hu ỷ gọi tới ph ương th ức an().,LTHDT_PhamVanAt.pdf - Sentence 728
729,2.,LTHDT_PhamVanAt.pdf - Sentence 729
730,Đi ều gì xẩy ra khi bỏ đi h àm hu ỷ:  + Khi g ọi hàm ht_di_dong_xuong() thì có 2 đối tượng kiểu HT đ ược tạo ra.,LTHDT_PhamVanAt.pdf - Sentence 730
731,Trong thân h àm s ử  dụng các đối t ượng n ày để vẽ các h ình tròn di chuy ển xuống.,LTHDT_PhamVanAt.pdf - Sentence 731
732,Khi thoát khỏi h àm thì 2 đối tượng  (tạo ra ở tr ên) đư ợc giải phóng.,LTHDT_PhamVanAt.pdf - Sentence 732
733,"V ùng nh ớ của các thuộc tính của chúng bị thu hồi, nh ưng vùng nh ớ  cấp phát cho thuộc tính pht ch ưa đư ợc giải phóng v à ảnh của 2 h ình tròn ( ở phía d ưới m àn hình)  vẫn không đ ược cất đi.",LTHDT_PhamVanAt.pdf - Sentence 733
734,+ Điều tương t ự xẩy ra sa u khi ra kh ỏi hàm ht_di_dong_len() : vùng nh ớ cấp phát cho thuộc tính  pht chưa đư ợc giải phóng v à ảnh của 2 h ình tròn ( ở phía tr ên màn hình) v ẫn không đ ược thu dọn.,LTHDT_PhamVanAt.pdf - Sentence 734
735,Bài 6.,LTHDT_PhamVanAt.pdf - Sentence 735
736,Toán t ử gán   6.1.,LTHDT_PhamVanAt.pdf - Sentence 736
737,Toán t ử gán mặc định   Toán t ử gán (cho lớp) l à một trường hợp đặc bi ệt so với các toán tử khác.,LTHDT_PhamVanAt.pdf - Sentence 737
738,"Nếu trong lớp ch ưa  định nghĩa một ph ương th ức toán tử gán th ì Trình biên d ịch sẽ phát sinh một toán tử gán mặc định  để thực hiện câu lệnh gán 2 đối t ượng của lớp, ví du:   HT  h1, h2(100,6);   h1 = h2 ;  // Gán h2 cho h1   Toán t ử gán  mặc định sẽ sẽ sao chép đối t ượng nguồn (h2) v ào đối tượng đích (h1) theo từng bit  một.",LTHDT_PhamVanAt.pdf - Sentence 738
739,Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          125                                         tenshi3003@gmail.com  Trong đa s ố các tr ường hợp khi lớp không có các th ành ph ần con trỏ hay tham chiếu th ì toán t ử  gán m ặc định l à đủ dùng và không c ần định nghĩa một ph ương th ức toán tử gán cho l ớp.,LTHDT_PhamVanAt.pdf - Sentence 739
740,"Nh ưng đ ối  với các lớp có thuộc tính con trỏ nh ư lớp DT (đa thức), lớp HT (h ình tròn) thì toán t ử gán mặc định  không thích h ợp và việc xây dựng toán tử gán l à cần thiết.",LTHDT_PhamVanAt.pdf - Sentence 740
741,6.2.,LTHDT_PhamVanAt.pdf - Sentence 741
742,"Cách vi ết toán tử gán   Cũng giống nh ư các phương th ức khác, ph ương th ức toán t ử gán d ùng đ ối con trỏ this để biểu thị  đối tượng đích v à dùng m ột đối t ường minh để biểu thị đối t ượng nguồn.",LTHDT_PhamVanAt.pdf - Sentence 742
743,"V ì trong thân c ủa toán tử  gán không nên làm vi ệc với bản sao của đối t ượng nguồn, m à phải làm vi ệc trực tiếp với đối t ượng  nguồn, n ên ki ểu đối tường minh nhất thiết phải l à kiểu tham chiếu đối t ượng.",LTHDT_PhamVanAt.pdf - Sentence 743
744,Phương th ức toán tử gán có thể có hoặc không có giá trị trả về.,LTHDT_PhamVanAt.pdf - Sentence 744
745,"Nếu không có giá trị trả về (kiểu  void), thì khi vi ết ch ương tr ình không được phép viết câu lệnh gán li ên tiếp nhiều đối t ượng, n hư:  u = v = k = h ;   Nếu ph ương th ức toán tử gán trả về tham chiếu của đối t ượng nguồn, th ì có th ể dùng toán t ử gán  thể thực hiện các phép gán li ên tiếp nhiều đối t ượng.",LTHDT_PhamVanAt.pdf - Sentence 745
746,"Ví dụ đối với lớp HT (trong mục tr ước), có thể xây dựng toán tử gán nh ư sau:   void  HT: :operator=(const HT &h)   {  r = h.r ; m = h.m ;   xhien = yhien = 0;   hienmh = 0 ;   if (h.pht==NULL)   pht = NULL;   else  {  int size;   size = imagesize(0,0,r+r,r+r);   pht = new char[size];   memcpy(pht,h.pht,size);   }  }  Với toán tử gán n ày, ch ỉ cho phép gán đối t ượng ngu ồn cho một đối t ượng đích.",LTHDT_PhamVanAt.pdf - Sentence 746
747,"Như v ậy câu lệnh sau l à sai:   HT  u, v, h ;   u = v = h ;   Bây gi ờ ta sửa lại toán gán để nó trả về tham chiếu đối t ượng nguồn nh ư sau:   const HT  & HT::operator=(const HT &h)   {  r = h.r ; m = h.m ;   xhien = yhien = 0;   hienmh = 0 ;   if (h.pht==NULL)  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          126                                         tenshi3003@gmail.com  pht = NULL;   else  {  int size;   size = imagesize(0,0,r+r,r+r);   pht = new char[size];   memcpy(pht,h.pht,size);   }  return h ;   }  Với toán tử gán mới n ày, ta có th ể viết câu lệnh để gán đối t ượng nguồn cho nhiều  đối t ượng  đích.",LTHDT_PhamVanAt.pdf - Sentence 747
748,"Như v ậy các câu lệnh sa u là đư ợc:  HT  u, v, h ;   u = v = h ;   6.3.",LTHDT_PhamVanAt.pdf - Sentence 748
749,"Toán t ử gán v à hàm t ạo sao chép   + Toán t ử gán không tạo ra đối t ượng mới, chỉ thực hiện phép gán giữa 2 đối t ượng đ ã tồn tại.",LTHDT_PhamVanAt.pdf - Sentence 749
750,+ Hàm t ạo sao chép đ ược dùng đ ể tạo một đối t ượng mới v à gán n ội dung của một đối t ượng đã  tồn tại cho đối t ượng mới vừa tạo.,LTHDT_PhamVanAt.pdf - Sentence 750
751,"+ Nếu đã xây d ựng toán tử gán m à lại dùng hàm t ạo sao chép mặc định th ì chưa đủ, vì việc khởi  gán trong câu l ệnh khai báo sẽ không gọi tới toán tử gán m à lại gọi tới h àm tạo sao chép.",LTHDT_PhamVanAt.pdf - Sentence 751
752,"+ Như v ậy đối với lớp có thuộc tín h con tr ỏ, thì ngoài hàm t ạo, cần xây dựng th êm:  - Hàm hu ỷ   - Hàm t ạo sao chép   - Phương th ức toán tử gán   Chú ý:   Không ph ải mọi câu lệnh chứa có dấu = đều gọi đến toán tử gán.",LTHDT_PhamVanAt.pdf - Sentence 752
753,Cần phân biệt 3 tr ường  hợp:  1.,LTHDT_PhamVanAt.pdf - Sentence 753
754,"Câu l ệnh new (chứa dấu =) sẽ gọi đến h àm tạo, ví dụ:  HT *h= new HT(50,6); // g ọi đến h àm tạo có đối   2.",LTHDT_PhamVanAt.pdf - Sentence 754
755,"Câu l ệnh khai báo v à khởi gán (d ùng d ấu =) sẽ gọi đến h àm tạo sao chép, ví dụ:       HT k=*h;      // g ọi đến h àm tạo sao chep   3.",LTHDT_PhamVanAt.pdf - Sentence 755
756,"Câu l ệnh gán sẽ gọi đến toán tử gán, ví dụ:   HT u;   u=*h; // g ọi đến ph ương  thức toán tử gán   6.4.",LTHDT_PhamVanAt.pdf - Sentence 756
757,Ví d ụ minh hoạ   Chương tr ình d ưới đây định nghĩa lớp HT (h ình tròn) và minh ho ạ:  + Hàm t ạo và hàm hu ỷ  + Phương th ức toán tử gán có kiểu tham chiếu   + Hàm t ạo sao chép   + Cách dùng con tr ỏ this trong h àm tạo sao chép   +  Cách dùng con tr ỏ  _new_handler đ ể kiểm tra việc cấp phát bộ nhớ.,LTHDT_PhamVanAt.pdf - Sentence 757
758,"Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          127                                         tenshi3003@gmail.com  //CT4_10.CPP   // Lop do hoa   // Ham huy   // toan tu gan - tra ve tham chieu   // Ham tao sao chep   // Trong ham huy co the goi PT khac   #include <conio.h>   #include <iostream.h>   #include <stdlib.h>   #include <graphic s.h>  #include <new.h>   #include <mem.h>   static void kiem_tra_bo_nho() ;   void ktdh();   int xmax,ymax;   void  kiem_tra_bo_nho()   {  outtextxy(1,1,""LOI BO NHO"");   getch();   closegraph();   exit(1);   }  class HT   {  private:   int r,m ;   int xhien,yhien;   char *pht;   int hienmh ;  public:   HT();   HT(int r1,int m1=15);   HT(const HT &h);   ~HT();   void hien(int x, int y);   void an();   const HT &operator=(const HT &h);   };  const HT & HT::operator=(const HT &h)   { Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          128                                         tenshi3003@gmail.com  // outtextxy(1,1,""Gan""); getch();   r = h.r ; m = h.m ;   xhien = yhien = 0;   hienmh =  0 ;  if (h.pht==NULL)   pht = NULL;   else  {  int size;   size = imagesize(0,0,r+r,r+r);   pht = new char[size];   memcpy(pht,h.pht,size);   }  return h;   }  HT::HT(const HT &h)   {  //outtextxy(300,1,""constructor sao chep""); getch();   *this = h;   }  HT:: HT()   {  r=m=hienmh=0;   xhien=yhien=0;   pht=NULL;   }  HT::HT(int r1,int m1)   {  r=r1; m=m1; hienmh=0;   xhien=yhien=0;   if (r<0) r=0;   if (r==0)   {  pht=NULL;   }  else  {  int size; char *pmh;   size = imagesize(0,0,r+r,r+r);   pmh = new char[size];  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          129                                         tenshi3003@gmail.com  getimage(0,0,r+r,r+r,pmh);   setcolor(m);   circle(r,r ,r);  setfillstyle(1,m);   floodfill(r,r,m);   pht = new char[size];   getimage(0,0,r+r,r+r,pht);   putimage(0,0,pmh,COPY_PUT);   delete pmh;   pmh=NULL;   }  }  void HT::hien(int x, int y)   {  if (pht!=NULL && !hienmh) // chua hien   {  hienmh=1;   xhien=x; yhien=y;   putimage(x,y ,pht,XOR_PUT);   }  }  void HT::an()   {  if (hienmh) // dang hien   {  hienmh=0;   putimage(xhien,yhien,pht,XOR_PUT);   }  }  HT::~HT()   {  an();   if (pht!=NULL)   {  delete pht;   pht=NULL;   }  }  void ktdh()   { Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          130                                         tenshi3003@gmail.com  int mh=0,mode=0;   initgraph(&mh,&mode,"""");   xmax = getmaxx();   ymax = get maxy();   }  void main()   {  _new_handler = kiem_tra_bo_nho ;   ktdh();   HT *h= new HT(50,6); // g ọi hàm tạo có đối   h->hien(100,200);   HT k=*h;      // g ọi hàm tạo sao chép   k.hien(200,200);   HT t,v,u;   t = v = u = *h;   // g ọi toán tử  gán   u.hien(300,200);   v.hien(400 ,200);   t.hien(500,200);   getch();   closegraph();   }  6.5.",LTHDT_PhamVanAt.pdf - Sentence 758
759,Vai trò c ủa ph ương th ức toán tử gán   Chương tr ình trên s ẽ vẽ 5 h ình tròn trên màn hình.,LTHDT_PhamVanAt.pdf - Sentence 759
760,Điều gì sẽ xẩy ra nếu bỏ đi ph ương th ức toán  tử gán v à hàm t ạo sao chép?,LTHDT_PhamVanAt.pdf - Sentence 760
761,"+ Nếu bỏ cả hai, th ì chỉ xuất hi ên m ột hình tròn t ại vị trí (100,200).",LTHDT_PhamVanAt.pdf - Sentence 761
762,"+ Nếu bỏ toán tử gán (giữ h àm tạo sao chép) th ì chỉ xuất hiện 2 h ình tròn t ại các vị trí (100,200)  và (200,200).",LTHDT_PhamVanAt.pdf - Sentence 762
763,+ Nếu bỏ h àm tạo sao chép (giữ toán tử gán) th ì xuất hiện 4 h ình tròn.,LTHDT_PhamVanAt.pdf - Sentence 763
764,Bài 7.,LTHDT_PhamVanAt.pdf - Sentence 764
765,"Phân lo ại ph ương th ức, ph ương th ức inline   7.1.",LTHDT_PhamVanAt.pdf - Sentence 765
766,Phân lo ại các ph ương th ức  Có th ể chia ph ương th ức th ành các nhóm:   1.,LTHDT_PhamVanAt.pdf - Sentence 766
767,Các phương th ức thông th ường  2.,LTHDT_PhamVanAt.pdf - Sentence 767
768,"Các phương th ức dùng đ ể xây dựng v à huỷ bỏ đối t ượng gồm:   + Hàm t ạo không đối,   + Hàm t ạo có đối   + Hàm t ạo sao chép   + Hàm hu ỷ  3.",LTHDT_PhamVanAt.pdf - Sentence 768
769,Các phương th ức toán t ử Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          131                                         tenshi3003@gmail.com  7.2.,LTHDT_PhamVanAt.pdf - Sentence 769
770,Con tr ỏ this   Mọi ph ương th ức đều d ùng con tr ỏ this nh ư đối thứ nhất (đối ẩn).,LTHDT_PhamVanAt.pdf - Sentence 770
771,Ngo ài ra trong phương th ức có  thể đưa vào các đ ối tường minh đ ược khai báo nh ư đối của h àm.,LTHDT_PhamVanAt.pdf - Sentence 771
772,"+ Với các ph ương th ức thông th ường, th ì đối ẩn biểu thị đối t ượng chủ thể  trong l ời gọi ph ương  thức.",LTHDT_PhamVanAt.pdf - Sentence 772
773,"+ Với các h àm tạo, th ì đối ẩn biểu thị đối t ượng mới đ ược hình thành.",LTHDT_PhamVanAt.pdf - Sentence 773
774,"+ Với các h àm hu ỷ, thì đối ẩn biểu thị đối t ượng sắp bị huỷ bỏ.",LTHDT_PhamVanAt.pdf - Sentence 774
775,"+ Với các ph ương th ức toán tử, th ì đối ẩn biểu thị toán hạng đối t ượng thứ nhất.",LTHDT_PhamVanAt.pdf - Sentence 775
776,7.3.,LTHDT_PhamVanAt.pdf - Sentence 776
777,Phương t hức inline.,LTHDT_PhamVanAt.pdf - Sentence 777
778,Có 2 cách đ ể biên dịch ph ương th ức theo kiểu inline:   Cách 1:  Xây d ựng ph ương th ức bên trong đ ịnh nghĩa lớp.,LTHDT_PhamVanAt.pdf - Sentence 778
779,Cách 2:  Thêm t ừ khoá inline v ào định nghĩa ph ương th ức (b ên ngoài đ ịnh nghĩa lớp).,LTHDT_PhamVanAt.pdf - Sentence 779
780,"Chú ý  là ch ỉ các ph ương th ức ngắn không chứa các c âu lệnh phức tạp (nh ư chu tr ình, goto,  switch, đ ệ quy) mới có thể tr ơ thành inline.",LTHDT_PhamVanAt.pdf - Sentence 780
781,"N ếu có ý định bi ên dịch theo kiểu inline các ph ương  thức chứa các câu lệnh phức tạp nói tr ên, thì Trình biên d ịch sẽ báo lỗi.",LTHDT_PhamVanAt.pdf - Sentence 781
782,"Trong chương tr ình d ưới đây, tất cả các ph ương  thức của lớp PS (phân số) đều l à phương th ức  inline   //CT4_11.CPP   // Lop PS   // Inline   #include <conio.h>   #include <iostream.h>   class PS   {  private:   int t,m ;   public:   PS()  {  t=0;m=1;   }  PS(int t1, int m1);   void nhap();   void in();   PS operator*=(PS p2)   {  t*=p2.",LTHDT_PhamVanAt.pdf - Sentence 782
783,"t;  m*=p2.m;   return *this;   }  };  inline PS::PS(int t1, int m1)  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          132                                         tenshi3003@gmail.com  {  t=t1;   m=m1;   }  inline void PS::nhap()   {  cout << "" \nNhap tu va mau: "" ;   cin >> t >> m;   }  inline void PS::in()   {  cout << "" \nPS = "" << t << ""/"" << m ;   }  void main()   {  PS q,p,s(3,5);   cout << "" \n Nha p PS p"";   p.nhap();   s.in();   p.in();   q = p*=s;   p.in();   q.in();   getch();   }  Bài 8.",LTHDT_PhamVanAt.pdf - Sentence 783
784,Hàm t ạo và đối tượng th ành ph ần  8.1.,LTHDT_PhamVanAt.pdf - Sentence 784
785,"L ớp bao, lớp th ành ph ần  Một lớp có thuộc tính l à đối tượng của lớp khác gọi l à lớp bao, ví dụ:   class A   {  private:   int a, b;   ...",LTHDT_PhamVanAt.pdf - Sentence 785
786,"} ;  class B   {  private:  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          133                                         tenshi3003@gmail.com  double  x, y, z;   ...",LTHDT_PhamVanAt.pdf - Sentence 786
787,"} ;  class C   {  private:   int m, n;   A  u;   B   p, q;   ...",LTHDT_PhamVanAt.pdf - Sentence 787
788,"} ;  Trong ví d ụ trên thì:   C là l ớp bao   A, B là các l ớp th ành ph ần (của C)   8.2.",LTHDT_PhamVanAt.pdf - Sentence 788
789,Hàm t ạo của lớp bao   + Chú ý là trong các ph ương th ức của lớp bao không cho phép truy nh ập trực tiếp đến các thuộc  tính c ủa các đối t ượng của các lớp th ành ph ần.,LTHDT_PhamVanAt.pdf - Sentence 789
790,"+ Vì v ậy, khi xây dựng h àm tạo của lớp bao, phải s ư dụng các h àm tạo của lớp th ành ph ần để  khởi gán cho các đối t ượng th ành ph ần của lớp bao.",LTHDT_PhamVanAt.pdf - Sentence 790
791,"Ví d ụ khi xây d ựng h àm tạo của l ớp C, cần d ùng các hàm t ạo của lớp A để khởi gán cho đối  tượng th ành ph ần u v à dùng các hàm t ạo của lớp B để khởi gán cho các đối t ượng th ành ph ần p, q.",LTHDT_PhamVanAt.pdf - Sentence 791
792,8.3.,LTHDT_PhamVanAt.pdf - Sentence 792
793,"Cách dùng hàm t ạo của lớp th ành ph ần để xây dựng h àm t ạo của lớp bao   + Để dùng hàm t ạo (của lớp th ành ph ần) khởi gán cho đối t ưọng th ành ph ần của lớp bao, ta sử  dụng mẫu:   tên_đ ối_tượng(danh sách giá trị)   + Các m ẫu tr ên cần viết b ên ngoài thân hàm t ạo, ngay sau d òng đầu tiên.",LTHDT_PhamVanAt.pdf - Sentence 793
794,"Nói m ột cách cụ thể  hơn,  hàm t ạo sẽ có dạng:   tên_l ớp(danh sách đối) : t ên_đ ối_tượng( danh sách giá trị),   ...",LTHDT_PhamVanAt.pdf - Sentence 794
795,"tên_đ ối_tượng( danh sách giá trị)   {  // Các câu l ệnh trong thân h àm tạo  }     Chú ý  là các d ấu ngoặc sau t ên đối tượng luôn luôn phải có, ngay cả khi danh sách giá trị b ên  trong là r ỗng.",LTHDT_PhamVanAt.pdf - Sentence 795
796,+ Danh sách giá tr ị lấy từ danh sác h đối.,LTHDT_PhamVanAt.pdf - Sentence 796
797,"Dựa v ào danh sách giá tr ị, Trình biên d ịch sẽ biết cần  dùng hàm t ạo nào để khởi gán cho đối t ượng.",LTHDT_PhamVanAt.pdf - Sentence 797
798,Nếu danh sách giá trị l à rỗng th ì  hàm t ạo không đối  sẽ được sử dụng.,LTHDT_PhamVanAt.pdf - Sentence 798
799,"Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          134                                         tenshi3003@gmail.com  + Các đ ối tượng muốn khởi gán bằng h àm tạo không đối có thể bỏ qua, không cần p hải liệt k ê  trong hàm t ạo.",LTHDT_PhamVanAt.pdf - Sentence 799
800,"Nói cách khác: Các đối t ượng không đ ược liệt k ê trên dòng đầu hàm tạo của lớp bao,  đều được khởi gán bằng h àm tạo không đối của lớp th ành ph ần.",LTHDT_PhamVanAt.pdf - Sentence 800
801,"Ví dụ:  class A   {  private:   int a, b;   public:   A()  {  a=b=0;   }  A(int a1, int b1)   {  a = a1 ; b = b1;   }    ...",LTHDT_PhamVanAt.pdf - Sentence 801
802,"} ;  class B   {  private:   double  x, y, z;   public:   B()  {  x = y = z = 0.0 ;   }  B(double x1, double y1)   {  x = x1;  y = y1; z = 0.0 ;   }  B(double x1, double y1, double z1)   {  x = x1;  y = y1; z = z1 ;   }  ...",LTHDT_PhamVanAt.pdf - Sentence 802
803,"} ;  class C  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          135                                         tenshi3003@gmail.com  {  private:   int m , n;  A  u, v;   B   p, q, r;   public:   C(int m1, int n1,int a1, int b1, double x1, double y1, double x2, double y2, double z2) :  u(), v(a1,b1), q(x1,y1), r(x2,y2,z2)   {  m = m1 ; n = n1;   }  } ;  Trong hàm t ạo nói tr ên của lớp C, th ì các đối tượng th ành ph ần được khởi gán nh ư sau:   u được khởi gán bằng h àm tạo không đối của lớp A   v được khởi gán bằng h àm tạo 2 đối của lớp A   q được khởi gán bằng h àm tạo 2 đối của lớp B   r được khởi gán bằng h àm tạo 3 đối của lớp B   p (không có m ặt) được khởi gán bằng h àm tạo không đối c ủa lớp B   8.4.",LTHDT_PhamVanAt.pdf - Sentence 803
804,"S ử dụng các ph ương th ức của lớp th ành ph ần  Mặc dù lớp bao có các th ành ph ần đối t ượng, nh ưng trong l ớp bao lại không đ ược phép truy  nhập đến các thuộc tính của các đối t ượng n ày.",LTHDT_PhamVanAt.pdf - Sentence 804
805,"Vì v ậy giải pháp thông th ường l à:  + Trong các l ớp th ành ph ần, x ây dựng sẵn các ph ương th ức để có thể lấy ra các thuộc tính của  lớp.",LTHDT_PhamVanAt.pdf - Sentence 805
806,+ Trong l ớp bao d ùng các phương th ức của lớp th ành ph ần để nhận các thuộc tính của các đối  tượng th ành viên c ần dùng đ ến.,LTHDT_PhamVanAt.pdf - Sentence 806
807,8.5.,LTHDT_PhamVanAt.pdf - Sentence 807
808,Các ví d ụ  Hai chương tr ình d ưới đây minh hoạ các điều đ ã nói  trong các m ục trên.,LTHDT_PhamVanAt.pdf - Sentence 808
809,"Ví dụ 1:  Trong ví d ụ này xét 2 l ớp:   DIEM (Đi ểm) v à DT (Đo ạn thẳng)   Lớp DIEM l à lớp th ành ph ần của lớp DT   //CT4_12.CPP   // Thuoc tinh doi tuong   #include <conio.h>   #include <iostream.h>   class DIEM   {  private:   int x,y ;   public:  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          136                                         tenshi3003@gmail.com  DIEM()   {  x=y=0;   }  DIEM(int x1, int y1)   {  x= x1; y=y1;   }  void in()   {  cout << ""("" << x << "","" << y << "")"" ;   }  } ;  class DT   {  private:   DIEM d1, d2;   int m;   public:   DT() : d1(), d2()   {  m=0;   }  DT(int m1,int x1, int y1, int x2, int y2) : d1(x1,y1), d2(x2,y2)   {  m=m1;   }  DT(in t m1,DIEM t1, DIEM t2)   {  m=m1;   d1 = t1;   d2 = t2;   }  void in()   {  cout << "" \n Diem dau : ""; d1.in();   cout << "" \n Diem cuoi: ""; d2.in();   cout << "" \n Mau : "" << m;   }  }; Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          137                                         tenshi3003@gmail.com  void main()   {  DT  u, v(1,100,100,200,200), s(2,DIEM(300,300),   DIEM(400,400)) ;   clrscr();   u.in();  v.in();   s.in();   getch();   }  Ví dụ 2:  Trong ví d ụ này xét 3 l ớp:   Diem (Đi ểm)   DTron (Đư ờng tr òn)  HTron (Hình tròn)   Lớp DTron có một lớp th ành ph ần là lớp Diem.",LTHDT_PhamVanAt.pdf - Sentence 809
810,Lớp HTron có 2 lớp th ành ph ần là lớp DTron v à lớp Diem.,LTHDT_PhamVanAt.pdf - Sentence 810
811,Trong l ớp DTron đ ưa vào phương th ức vẽ đường tr òn.,LTHDT_PhamVanAt.pdf - Sentence 811
812,Trong l ớp HTron đ ưa vào phương th ức vẽ v à tô m ầu hình tròn.,LTHDT_PhamVanAt.pdf - Sentence 812
813,Khi xây d ựng ph ương th ức của lớp bao cần sử dụng các ph ương th ức của lớp th ành ph ần.,LTHDT_PhamVanAt.pdf - Sentence 813
814,"//CT4_13.CPP   // Thuoc tinh doi tuong   #include <conio.h>   #include <iostream.h>   #include <graphics .h>  class Diem   {  private:   int x,y ;   public:   Diem()   {  x=y=0;   }  Diem(int x1, int y1)   {  x= x1; y=y1;   }  int getx()   {  return x;  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          138                                         tenshi3003@gmail.com  }  int gety()   {  return y;   }  } ;  class DTron   // Duong tron   {  private:   Diem t ; // tam   int  r ;   int m;   public:   DTron()   {  r=m=0;   }  DTro n(int x1,int y1,int r1,int m1): t(x1,y1)   {  m=m1; r=r1;   }  int mau()   {  return m;   }  void ve()   {  setcolor(m);   circle(t.getx(),t.gety(),r);   }  };  class HTron   {  private:   DTron  dt;   Diem d;   int m;   public:   HTron()   {  m=0;  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          139                                         tenshi3003@gmail.com  }  HTron(int x1, int y1, int r1, int m1,   int x, int y, int mt): dt(x1,y1,r1,m1), d(x,y)   {  m = mt;   }  void ve()   {  dt.ve();   setfillstyle(1,m);   floodfill(d.getx(),d.gety(),dt.mau());   }  } ;  void main()   {  int mh=0, mode=0;   initgraph(&mh,&mode,"""");   setbkcolor(1);   DTron dt(100,100,80,6);   HTron ht(300,300,150 ,15,300,300,4);   dt.ve();   ht.ve();   getch();   closegraph();   }    Bài 9.",LTHDT_PhamVanAt.pdf - Sentence 814
815,Các thành ph ần tĩnh   9.1.,LTHDT_PhamVanAt.pdf - Sentence 815
816,"Thành ph ần dữ liệu tĩnh   + Thành ph ần dữ liệu đ ược khai báo bằng từ khoá static gọi l à tĩnh, ví dụ:   class A   {  private:   static   int  ts ;  // Thành ph ần tĩnh   int    x;                 ....",LTHDT_PhamVanAt.pdf - Sentence 816
817,} ;  +  Thành ph ần tĩnh đ ược cấp phát một v ùng nh ớ cố định.,LTHDT_PhamVanAt.pdf - Sentence 817
818,Nó tồn tại ngay cả khi lớp ch ưa có m ột  đối tượng n ào cả.,LTHDT_PhamVanAt.pdf - Sentence 818
819,"+ Thành ph ần tĩnh l à chung cho c ả lớp, nó không phải l à riêng c ủa mỗi đối t ượng.",LTHDT_PhamVanAt.pdf - Sentence 819
820,"Ví dụ xét 2  đối tượng:  A   u,v ; // Khai báo 2 đ ối tượng  thì gi ữa các th ành ph ần x v à ts có s ự khác nhau nh ư sau:   u.x và v.x   có 2 vùng nh ớ khác nhau  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          140                                         tenshi3003@gmail.com  u.ts  và   v.ts  ch ỉ là một, chúng c ùng bi ểu thị một v ùng nh ớ  thành ph ần ts tồn tại ngay khi u v à v chưa khai báo   + Để biểu thị th ành ph ần tĩnh, ta có th ể dùng tên l ớp, ví du: Đối với ts th ì 3 cách vi ết sau l à tương  đương:             A::ts               u.ts               v.ts   + Khai báo và kh ởi gán giá trị cho th ành ph ần tĩnh   Thành ph ần tĩnh sẽ đ ược cấp phát bộ nhớ v à khởi gán giá trị ban đầu b ằng một câu lệnh khai báo  đặt sau định nghĩa lớp (b ên ngoài các hàm, k ể cả h àm main), theo các m ẫu:  int A::ts ;              // Kh ởi gán cho ts giá trị 0   int  A::ts = 1234; // Kh ởi gán cho ts giá trị 1234   Chú ý:  Khi chưa khai báo th ì thành ph ần tĩnh ch ưa tồn tại.",LTHDT_PhamVanAt.pdf - Sentence 820
821,"Ví dụ xét ch ương tr ình sau:   #include <conio.h>   #include <iostream.h>   class HDBH    // Hoá đơn bán hàng   {  private:   char *tenhang ;  // Tên hàng   double tienban ;  // Ti ền bán   static int tshd ;    // T ổng số hoá đ ơn  static double tstienban ; // T ổng s ố tiền bán   public:   static void in()   {  cout <<"" \n"" << tshd;   cout <<"" \n"" << tstienban;   }  } ;  void main()   {  HDBH::in();   getch();   }  Các thành ph ần tĩnh tshd v à tstienban chưa khai báo, nên chưa t ồn tại.",LTHDT_PhamVanAt.pdf - Sentence 821
822,V ì vậy các câu lệnh in giá  trị các th ành ph ần này trong p hương th ức in l à không logic.,LTHDT_PhamVanAt.pdf - Sentence 822
823,"Khi d ịch ch ương tr ình, s ẽ nhận đ ược  các thông báo l ỗi (tại ph ương th ức in) nh ư sau:   Undefined  symbol HDBH::tshd  in module ...",LTHDT_PhamVanAt.pdf - Sentence 823
824,Undefined  symbol HDBH::tstienban  in module ...,LTHDT_PhamVanAt.pdf - Sentence 824
825,"Có th ể sửa ch ương tr ình trên b ằng cách đ ưa vào cá c lệnh khai báo các th ành ph ần tĩnh tshd v à  tstienban như sau:   //CT4_14.CPP  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          141                                         tenshi3003@gmail.com  // thanh phan tinh   // Lop HDBH (hoa don ban hang)   #include <conio.h>   #include <iostream.h>   class HDBH   {  private:   int shd ;   char *tenhang ;   double tienban ;   static int tshd ;   static  double tstienban ;   public:   static void in()   {  cout <<"" \n"" << tshd;   cout <<"" \n"" << tstienban;   }  } ;  int HDBH::tshd=5;   double HDBH::tstienban=20000.0;   void main()   {  HDBH::in();   getch();   }  9.2.",LTHDT_PhamVanAt.pdf - Sentence 825
826,Khi nào c ần sử dụng các th ành ph ần dữ liệu tĩnh   Xét m ột ví dụ về  quản lý các hoá đ ơn bán hàng.,LTHDT_PhamVanAt.pdf - Sentence 826
827,"M ỗi hoá đ ơn có: Tên hàng, s ố tiền bán.",LTHDT_PhamVanAt.pdf - Sentence 827
828,R õ ràng  các thu ộc tính nói tr ên là riêng c ủa mỗi hoá đ ơn.,LTHDT_PhamVanAt.pdf - Sentence 828
829,"M ặt khác nếu chúng ta quan tâm đến tổng số hoá  đơn đ ã bán, t ổng số tiền đ ã bán, thì các thông tin này là chung.",LTHDT_PhamVanAt.pdf - Sentence 829
830,"Vì v ậy khi thiết  kế lớp HDBH (hoá  đơn bán hàng) , th ì ta có th ể đưa vào 4 thành ph ần dữ liệu l à:  tenhang   (tên hàng)   tienban (ti ền bán)   tshd (t ổng số hoá đ ơn)  tstienban  (t ổng số tiền bán)   Các thu ộc tính tenhang v à tienban là riêng c ủa mỗi hoá đ ơn, nên chúng đư ợc chọn l à các thu ộc  tính thông thư ờng.",LTHDT_PhamVanAt.pdf - Sentence 830
831,C òn các thu ộc tính tshd v à tstienban là chung cho c ả lớp n ên chúng đư ợc chọn l à  các thu ộc tính tĩnh.,LTHDT_PhamVanAt.pdf - Sentence 831
832,9.3.,LTHDT_PhamVanAt.pdf - Sentence 832
833,Phương th ức tĩnh   + Có 2 cách vi ết  ph ương th ức tĩnh:  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          142                                         tenshi3003@gmail.com  Cách 1:  Dùng t ừ khoá static đặt tr ước định nghĩa ph ương th ức viết b ên trong đ ịnh nghĩa lớp (nh ư  phương thưc in() ví d ụ cuối của mục 9.1).,LTHDT_PhamVanAt.pdf - Sentence 833
834,"Cách 2:  Nếu ph ương th ức xây dựng b ên ngoài đ ịnh nghĩa lớp, th ì dùng t ừ khoá static đặt tr ước  khai báo phương th ức bên trong đ ịnh nghĩa lớp.",LTHDT_PhamVanAt.pdf - Sentence 834
835,Chú ý không cho phép d ùng t ừ khoá static đặt trước  định nghĩa ph ương th ức viết b ên ngoài đ ịnh nghĩa lóp.,LTHDT_PhamVanAt.pdf - Sentence 835
836,"+ Phương th ức tĩnh l à chung cho c ả lớp, nó không lệ thuộc v ào m ột đối t ượng cụ thể, nó tồn tại  ngay khi l ớp ch ưa có đ ối tượng n ào (xem ví d ụ trong mục 9.1).",LTHDT_PhamVanAt.pdf - Sentence 836
837,"+ Lời gọi ph ương th ức tĩnh:   Có th ể xuất phát từ một đối t ượng n ào đó (như v ẫn dùng khi g ọi các ph ương th ức khác)   Có th ể dùng tên l ớp  Ví dụ xét lớp HDBH trong mục 9.1 v à xét các câu lênh:   HDBH   u, v;   Khi đó đ ể gọi ph ương th ức tĩnh in() có thể d ùng m ột trong các lệnh sau:   u.in();   v.in();   HDB H::in();   + Vì ph ương th ức tĩnh l à độc lập với các đối t ượng, n ên không th ể dùng phương th ức tĩnh để xử  lý dữ liệu của các đối t ượng chủ thể trong lời gọi ph ương th ức tĩnh.",LTHDT_PhamVanAt.pdf - Sentence 837
838,Nói cách khác không cho phép  truy nh ập tới các thuộc tính (tr ư thu ộc tính tĩnh) tron g thân phương th ức tĩnh.,LTHDT_PhamVanAt.pdf - Sentence 838
839,Điều đó cũng đồng  nghĩa với việc không cho phép d ùng con tr ỏ this trong ph ương th ức tĩnh.,LTHDT_PhamVanAt.pdf - Sentence 839
840,"Ví dụ nếu lập ph ương th ức tĩnh in() để in các thuộc tính của lớp HDBH nh ư sau:   class HDBH   {  private:   int shd ;   char *tenhang ;   double tienban  ;  static int tshd ;   static double tstienban ;   public:   static void in()   {  cout <<"" \n"" << tshd;   cout <<"" \n"" << tstienban;   cout <<"" \n"" << tenhang;   cout <<"" \n"" << tienban;   }  } ;   thì sẽ bị lỗi, v ì trong thân ph ương th ức tĩnh không cho phép truy nhập đến các t huộc tính tenhang  và tienban.",LTHDT_PhamVanAt.pdf - Sentence 840
841,9.4.,LTHDT_PhamVanAt.pdf - Sentence 841
842,Ví d ụ minh hoạ việc d ùng phương th ức tĩnh  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          143                                         tenshi3003@gmail.com  Xét bài toán qu ản lý hoá đ ơn bán hàng.,LTHDT_PhamVanAt.pdf - Sentence 842
843,M ỗi hoá đ ơn có 2 d ữ liêu là tên hàng và ti ền bán.,LTHDT_PhamVanAt.pdf - Sentence 843
844,"Sử  dụng h àm tạo để tạo ra các hoá đ ơn, dùng  hàm hu ỷ để bỏ đi (loại đi) các hoá đ ơn không cần lưu  trữ, dùng m ột ph ương th ức để sửa chữa nội dung hoá đ ơn (nh ập lại tiền bán).",LTHDT_PhamVanAt.pdf - Sentence 844
845,"Vấn đề đặt ra l à sau  một số thao tác: Tạo, sửa v à huỷ hoá đ ơn th ì tổng số hoá đ ơn còn lại là bao nhiêu và t ổng số tiền  trên các hoá đơn c òn lại là bao nhiêu?",LTHDT_PhamVanAt.pdf - Sentence 845
846,Chương tr ình d ưới đây nhằm đáp ứng y êu cầu đặt ra.,LTHDT_PhamVanAt.pdf - Sentence 846
847,"//CT4_14.CPP   // thanh phan tinh   // Lop HDBH (hoa don ban hang)   #include <conio.h>   #include <iostream.h>   class HDBH   {  private:   char *tenhang ;   double tienban ;   static int tshd ;   static double tstienban ;   public:   HDBH(cha r *tenhang1=NULL,double tienban1=0.0 )   {  tienban=tienban1;   tenhang=tenhang1;   ++tshd;   tstienban += tienban;   }  ~HDBH()   {  --tshd;   tstienban -= tienban;   }  void sua();   static void in();   } ;  int HDBH::tshd=0;   double HDBH::tstienban=0;   void HDBH::in()   {  cout <<"" \n\nTong so hoa don: "" << tshd;   cout <<"" \nTong so tien: "" << tstienban;  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          144                                         tenshi3003@gmail.com  }  void HDBH::sua()   {  cout << "" \n\nTen hang: "" << tenhang;   cout << "" \nTien ban : "" << tienban;   tstienban -= tienban;   cout << "" \nSua tien ban thanh : "" ;   cin >> tienban;   tstienban += tien ban;  }  void main()   {  HDBH *h1 = new HDBH(""Xi mang"",2000);   HDBH *h2 = new HDBH(""Sat thep"",3000);   HDBH *h3 = new HDBH(""Ti vi"",4000);   clrscr();   HDBH::in();   getch();   delete h1;   HDBH::in();   getch();   h2->sua();   HDBH::in();   getch();   delete h3;   HDBH::in();   getch() ;  }    Bài 10.",LTHDT_PhamVanAt.pdf - Sentence 847
848,M ảng đối t ượng  10.1.,LTHDT_PhamVanAt.pdf - Sentence 848
849,"Khai báo   Có th ể dùng tên l ớp để khai báo mảng đối t ượng (giống nh ư khai báo m ảng int, float, char, ...)    theo m ẫu:  Tên_l ớp   t ên_m ảng[kích_cỡ] ;   Ví dụ giả sử đ ã định nghĩa lớp DIEM (Điểm), khi đó có thể khai báo các mảng đối tượng DIEM  như sau:   DIEM   a[10], b[20] ;   ý ngh ĩa: a là m ảng kiểu DIEM gồm 10 phần tử  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          145                                         tenshi3003@gmail.com                b là m ảng kiểu DIEM gồm 20 phần tử   Câu l ệnh khai báo mảng sẽ gọi tới h àm tạo không đối để tạo các phần tử mảng.",LTHDT_PhamVanAt.pdf - Sentence 849
850,"Trong ví dụ tr ên,  hàm t ạo được gọi 30 lầ n để tạo 30 phần tử mảng đối t ượng.",LTHDT_PhamVanAt.pdf - Sentence 850
851,10.2.,LTHDT_PhamVanAt.pdf - Sentence 851
852,"Khai báo và kh ởi gán   Để khai báo mảng v à khởi gán giá trị cho các phần tử mảng đối t ượng, cần d ùng các hàm t ạo có  đối theo mẫu sau:   Tên_l ớp  tên_m ảng[kích_cớ] = { T ên_lớp(các tham số), ...,   Tên_l ớp(các tham số) } ;   Ví dụ giả sử lớp DIEM đ ã định nghĩa:   class DIEM   {  private:   int x, y ;   public:   DIEM()   {  x=y=0;   }  DIEM(int x1, int y1)   {  x=x1; y=y1;   }  void nhapsl();   void ve_doan_thang(DIEM d2, int mau) ;   };  Khi đó các câu l ệnh khai báo d ưới đây đều đúng:   DIEM  d[5] = {DIE M(1,1),DIEM(200,200)};   DIEM  u[] = {DIEM(1,1),DIEM(200,200)};   ý ngh ĩa của các lệnh n ày như sau:   Câu l ệnh đầu gọi tới h àm tạo 2 lần để khởi gán cho d[1], d[2] v à gọi tới h àm tạo không đối 3 lần  để tạo các phần tử d[3], d[4] v à d[5].",LTHDT_PhamVanAt.pdf - Sentence 852
853,"Câu l ệnh sau gọi tới h àm tạo 2 lần để khởi gán cho u[1], u[2].",LTHDT_PhamVanAt.pdf - Sentence 853
854,Mảng u sẽ gồm 2 phần tử.,LTHDT_PhamVanAt.pdf - Sentence 854
855,10.3.,LTHDT_PhamVanAt.pdf - Sentence 855
856,"Bi ểu thị th ành ph ần của phần tử mảng   Để biểu thị thuộc tính của phần tử mảng đối t ượng, ta viết nh ư sau:   Tên_m ảng[chỉ số] .",LTHDT_PhamVanAt.pdf - Sentence 856
857,T ên_thu ộc_tính   Để thực hiện ph ương th ức đối với phần tử mảng ta viết nh ư sau:   Tên_m ảng[chỉ số] .,LTHDT_PhamVanAt.pdf - Sentence 857
858,"T ên_phương_th ức(danh sách tham số) ;   Ví d ụ để vẽ đoạn thẳng nối điểm d[1] với d[2] theo mầu đỏ, ta có thể d ùng phương th ức  ve_doan_thang như sau:   d[1].ve_doan_thang(d[2], 4);// Th ực hiện ph ương th ức đối với d[1]  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          146                                         tenshi3003@gmail.com  10.4.",LTHDT_PhamVanAt.pdf - Sentence 858
859,"Ví  dụ  Chương tr ình d ưới đây đ ưa vào l ớp TS (thí sinh) v à xét bài toán: Nh ập một danh sách thí sinh,  sắp xếp danh sách theo thứ tự giảm của tổng điểm.",LTHDT_PhamVanAt.pdf - Sentence 859
860,Ch ương tr ình minh ho ạ:  + Cách dùng m ảng đối t ượng.,LTHDT_PhamVanAt.pdf - Sentence 860
861,+ Vai trò con tr ỏ this (trong ph ương th ức hv(hoán vị)) .,LTHDT_PhamVanAt.pdf - Sentence 861
862,"+ Các hàm t ạo, h àm hu ỷ.",LTHDT_PhamVanAt.pdf - Sentence 862
863,+ Vai trò c ủa toán tử gán (nếu sử dụng phép gán mặc định ch ương tr ình s ẽ cho kết quả sai).,LTHDT_PhamVanAt.pdf - Sentence 863
864,"//CT4_15.CPP   // mang doi tuong   // Lop TS (thi sinh)   // Chu y vai tro cua toan tu gan   #include <conio.h>   #include <iostream.h>   #include <strin g.h>   class TS   {  private:   char *ht;   double td;   public:   TS()  {  ht = new char[20];   td = 0;   }  ~TS()   {  delete ht;   }  const TS &operator=(const TS &ts2)   {  this->td = ts2.td;   strcpy(this ->ht,ts2.ht);   return ts2;   }  void nhap(int i);   void in();   double gettd()   {  return td;  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          147                                         tenshi3003@gmail.com  }  void hv(TS &ts2)   {  TS tg;   tg = *this ;   *this = ts2 ;   ts2 = tg;   }  } ;  void TS::in()   {  cout << "" \nHo ten: "" << ht << ""    Tong diem: "" << td;   }  void TS::nhap(int i)   {  cout << "" \nNhap thi sinh "" << i ;   cout << "" \nHo ten: "" ; cin >> ht;   cout << ""Tong diem: "" ; cin >> td;   }  void main()   {  TS  ts[100];   int n, i, j;   clrscr();   cout << "" \n So thi sinh: "" ;   cin >> n;   for (i=1; i<= n; ++i)   ts[i].nhap(i);   cout <<"" \n Danh sach nhap vao:"";   for (i=1; i<= n; ++i)   ts[i].in();   for (i=1; i<n ; ++i)   for (j=i+1 ; j<=n; ++j)   if (ts[i].gettd() < ts[j].gettd())   ts[i].hv(ts[j]);   cout <<"" \n\n Danh sach sau khi sap xep:"";   for (i=1; i<= n; ++i)   ts[i].in();   getch();   }  Bài 11.",LTHDT_PhamVanAt.pdf - Sentence 864
865,c ấp phát bộ nhớ cho đối t ượng Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          148                                         tenshi3003@gmail.com  11.1.,LTHDT_PhamVanAt.pdf - Sentence 865
866,Cách c ấp phát bộ nhớ cho đối t ượng  Có th ể dùng new và tên l ớp để cấp  phát m ột vùng nh ớ cho một hoặc một dẫy các đối t ượng.,LTHDT_PhamVanAt.pdf - Sentence 866
867,Bộ  nhớ cấp phát đ ược quản lý bởi một con trỏ kiểu đối t ượng.,LTHDT_PhamVanAt.pdf - Sentence 867
868,"Ví dụ sau khi đ ã định nghĩa lớp DIEM  như trong m ục trên, ta có th ể thực hiện các lệnh cấp phát bộ nhớ nh ư sau:   int n = 10;   DIEM  *p, *q, *r ;  p = new DIEM ;  // C ấp phát bộ nhớ cho một đối t ượng  q = new DIEM[n] ; //C ấp phát bộ nhớ cho n đối t ượng  r = new DIEM(200,100); // C ấp phát bộ nhớ v à khởi gán cho   // một đối t ượng  11.2.",LTHDT_PhamVanAt.pdf - Sentence 868
869,Làm vi ệc với đối t ượng thông qua con trỏ   + Giả sử con trỏ p trỏ tới  vùng nh ớ của một đối t ượng n ào đó.,LTHDT_PhamVanAt.pdf - Sentence 869
870,"Khi đó:   - Để biểu thị một th ành ph ần (thuộc tính hoặc ph ương th ức) của đối t ượng, ta d ùng m ẫu viết  sau:  p -> tên_thành_ph ần  - Để biểu thị đối t ượng, ta d ùng m ẫu viết sau:   *p   + Giả sử con trỏ q trỏ tới địa chỉ đầu v ùng n hớ của một dẫy đối t ượng.",LTHDT_PhamVanAt.pdf - Sentence 870
871,"Khi đó:   - Để biểu thị một th ành ph ần (thuộc tính hoặc ph ương th ức) của đối t ượng thứ i, ta d ùng m ột  trong các m ẫu viết sau:   q[i].tên_thành_ph ần  (q+i) -> tên_thành_ph ần  - Để biểu thị đối t ượng thứ i, ta d ùng m ột trong các mẫu viết s au:  q[i]  *(q+i)   11.3.",LTHDT_PhamVanAt.pdf - Sentence 871
872,Bài toán s ắp xếp thí sinh   Trong m ục 10.4.,LTHDT_PhamVanAt.pdf - Sentence 872
873,"đ ã sử dụng mảng đối t ượng để giải quyết b ài toán: Nh ập một danh sách thí sinh,  sắp xếp danh sách theo thứ tự giảm của tổng điểm.",LTHDT_PhamVanAt.pdf - Sentence 873
874,D ưới đây sẽ đ ưa ra phương án m ới bằng cách  dùng con tr ỏ và cấp phát b ộ nhớ cho các đối t ượng.,LTHDT_PhamVanAt.pdf - Sentence 874
875,"Ch ương tr ình ch ỉ thay đổi h àm main() như sau:   void main()   {  TS  *ts;   int n, i, j;   clrscr();   cout << "" \n So thi sinh: "" ;   cin >> n;   ts = new TS[n+1];   for (i=1; i<= n; ++i)   ts[i].nhap(i);   cout <<"" \n Danh sach nhap vao:"";   for (i =1; i<= n; ++i)  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          149                                         tenshi3003@gmail.com  ts[i].in();   for (i=1; i<n ; ++i)   for (j=i+1 ; j<=n; ++j)   if (ts[i].gettd() < ts[j].gettd())   ts[i].hv(ts[j]);   cout <<"" \n\n Danh sach sau khi sap xep:"";   for (i=1; i<= n; ++i)   ts[i].in();   getch();   }    Nhận xét:  Sự khác biệt giữa h àm main m ới và hàm main trong 10.4 là r ất ít.",LTHDT_PhamVanAt.pdf - Sentence 875
876,11.4.,LTHDT_PhamVanAt.pdf - Sentence 876
877,Danh sách móc n ối  Chương tr ình d ưới đây định nghĩa lớp tự trỏ TS (lớp có thuộc tính kiểu *TS).,LTHDT_PhamVanAt.pdf - Sentence 877
878,Lớp n ày đư ợc  dùng đ ể tổ chức danh sách móc nối.,LTHDT_PhamVanAt.pdf - Sentence 878
879,Ch ương tr ình nh ập một danh sách thí sinh v à chứa trong một  danh sách móc n ối.,LTHDT_PhamVanAt.pdf - Sentence 879
880,Sau đó duy ệt trên danh sách này đ ể in các thí sinh trúng tuyển.,LTHDT_PhamVanAt.pdf - Sentence 880
881,"So với lớp TS  nêu trong m ục 10.4, lớp TS ở đây có một số điểm khác nh ư sau:   + Thêm thu ộc tính:   TS *dc;  // Dùng đ ể chứa địa chỉ của một đối t ượng kiểu TS   + Thêm các phương th ức:  void setdc( TS *dc1) ;  // Gán dc1 cho thu ộc tính dc   TS *getdc() ;               //  Nh ận giá trị của dc     + Phương th ức nhap trong ch ương tr ình tr ước có kiểu void nay sửa l à:           int nhap(int i);   Phương th ức trả về 1 nếu họ t ên nh ập vào khác tr ống, trả về 0 nếu trái lại.",LTHDT_PhamVanAt.pdf - Sentence 881
882,"+ Bỏ đi các ph ương th ức không d ùng đ ến nh ư: Toán t ử gán, hoán vị.",LTHDT_PhamVanAt.pdf - Sentence 882
883,"//CT4_16.CPP   // Danh sách móc n ối  // Lop TS (thi sinh)   #include <conio.h>   #include <iostream.h>   #include <string.h>   #include <ctype.h>   #include <stdio.h>   class TS   {  private:   char * ht;  double td;   TS *dc;  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          150                                         tenshi3003@gmail.com  public:   TS()  {  ht = new char[20];   td = 0;   dc=NULL;   }  ~TS()   {  delete ht; dc=NULL ;   }  int nhap(int i);   void in();   double gettd()   {  return td;   }  void setdc(TS *dc1)   {  dc=dc1;   }  TS *getdc()   {  return dc;   }  } ;  void TS::in()   {  cout << "" \nHo ten: "" << ht << ""    Tong diem: "" << td;   }  int TS::nhap(int i)   {  cout << "" \nNhap thi sinh "" << i ;   cout << "" \nHo ten (B ấm Enter để kết thúc nhập): "" ;   fflush(stdin);   gets(ht);   if (ht[0]==0) return 0;   cout << ""Tong diem: "" ; cin >> td;   dc=NULL;   return 1;   }  void main()  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          151                                         tenshi3003@gmail.com  {  int i=0;   TS  *pdau,*p,*q;   pdau=NULL;   clrscr();   while(1)   {  q=new TS;   ++i;   if (q->nhap(i)==0)   {  delete q; break;   }  if (pdau==NULL)   pdau = p = q;   else  {  p->setdc(q) ;   p = q;   }  }  /* In */   double diemchuan;   cout << "" \nDiem chuan: "" ;   cin >> diem chuan;   cout <<"" \nDanh sach trung tuyen:"" ;   p=pdau;   while (p!=NULL)   {  if (p->gettd()>=diemchuan)   p->in();   p = p ->getdc();   }  getch();   }  Bài 12.",LTHDT_PhamVanAt.pdf - Sentence 883
884,"Đ ối tượng hằng, ph ương th ức hằng   + Cũng giống nh ư các ph ần tử dữ liệu khác, một đối t ượng có thể đ ược khai báo l à hằng bằng  cách dùng t ừ khoá const.",LTHDT_PhamVanAt.pdf - Sentence 884
885,"Ví dụ:   class DIEM   {  private:   int x, y;  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          152                                         tenshi3003@gmail.com  int m;   public:   DIEM()   {  x = y = m = 0;   }  DIEM(int x1, int y1, int m1=15)   {  x= x1; y= y1; m= m1;   }  ...",LTHDT_PhamVanAt.pdf - Sentence 885
886,"} ;  const  DIEM  d = DIEM(200,100);  // Khai báo đ ối tượng hằng   + Khi khai báo cần sử dụng các h àm tạo để khởi gán giá trị cho đối t ượng hằng.",LTHDT_PhamVanAt.pdf - Sentence 886
887,"Giá trị khởi tạo  có th ể là các h ằng, các biến, các biểu thức v à các hàm, ví d ụ:  int  x0=100, y0=50; m0 =4;   const  DIEM  d5 = DIEM(x0 + getmaxx()/2, y0 + getmaxy()/2, m0);   + Các phương th ức có thể sử dụng cho các đối t ượng hằng l à hàm t ạo và hàm hu ỷ.",LTHDT_PhamVanAt.pdf - Sentence 887
888,"Về lý thuyết  các đ ối tượng hằng không thể bị thay đổi, m à chỉ được tạo ra hoặc huỷ bỏ đi.",LTHDT_PhamVanAt.pdf - Sentence 888
889,"Khi dùng m ột ph ương th ức cho đối t ượng hằng, th ì CTBD (Ch ương tr ình biên dich) s ẽ cảnh báo  (warning):   Non-const function called for const object   Tuy nhiên, chương tr ình EXE v ẫn được tạo v à khi th ực hiện ch ương tr ình, thì n ội dung các đối  tượng hằng vẫn bị thay đổi.",LTHDT_PhamVanAt.pdf - Sentence 889
890,Ch ương tr ình d ưới đây sẽ minh hoạ điều n ày.,LTHDT_PhamVanAt.pdf - Sentence 890
891,Chương tr ình đưa vào l ớp  PS (phân s ố).,LTHDT_PhamVanAt.pdf - Sentence 891
892,Ph ương th ức toá n tử ++ vẫn có thể l àm thay đ ổi đối t ượng hằng (mặc d ù khi biên d ịch  có 3 c ảnh báo).,LTHDT_PhamVanAt.pdf - Sentence 892
893,"//CT4_19.CPP   // doi tuong const   // Lop PS (phan so)   #include <conio.h>   #include <iostream.h>   #include <string.h>   #include <math.h>   class PS   {  private:   int t,m;   public:   PS()  {  t = m = 0;   } Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          153                                         tenshi3003@gmail.com  PS(int t1, int m1)   {  t = t1; m = m1;   }  PS operator++()   {  t += m ;   return *this ;   }  void in()   {  cout << "" \nPS= "" << t << ""/"" << m;   }  void nhap()   {  cout << "" \n Nhap tu va mau: "" ;   cin >> t >> m;   }  } ;  void main()   {  int t1= -3, m1=5;   const PS p = PS(abs(t1)+2,m1+2);  // Khai báo đ ối tượng hằng   clrscr();   p.in();   ++p;   p.in();   getch();   }  + Phương th ức const   Để biến một ph ương th ức th ành const ta ch ỉ việc viết th êm từ khoá const v ào sau dòng đầu của  phương th ức.",LTHDT_PhamVanAt.pdf - Sentence 893
894,"Chú ý:  Nếu ph ương th ức được khai bá o bên trong và đ ịnh nghĩa b ên ngoài l ớp, th ì từ khoá const  cần được bổ sung cả trong khai báo v à định nghĩa ph ương th ức.",LTHDT_PhamVanAt.pdf - Sentence 894
895,Trong thân phương th ức const không cho phép l àm thay đ ổi các thuộc tính của lớp.,LTHDT_PhamVanAt.pdf - Sentence 895
896,Vị vậy việc  dùng phương th ức const cho các đối t ượng h ằng sẽ đảm bảo giữ nguy ên nội dung của các đối t ượng  hằng.,LTHDT_PhamVanAt.pdf - Sentence 896
897,Đương nhiên các phương th ức const vẫn d ùng đư ợc cho các đối t ượng khác.,LTHDT_PhamVanAt.pdf - Sentence 897
898,Ví dụ sau về lớp PS (phân số) minh hoạ việc d ùng phương th ức const.,LTHDT_PhamVanAt.pdf - Sentence 898
899,"// Đối tượng const   // Phương th ức const  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          154                                         tenshi3003@gmail.com  // Lop PS (phan s o)  #include <conio.h>   #include <iostream.h>   #include <string.h>   #include <math.h>   class PS   {  private:   int t,m;   public:   PS()  {  t = m = 0;   }  PS(int t1, int m1)   {  t = t1; m = m1;   }  PS operator++()   {  t += m ;   return *this ;   }  void in() const ;   void nhap()   {  cout << "" \n Nhap tu va mau: "" ;   cin >> t >> m;   }  } ;  void PS::in() const   {  cout << "" \nPS= "" << t << ""/"" << m;   }  void main()   {  int t1= -3, m1=5;   const PS p = PS(abs(t1)+2,m1+2);   PS q;  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          155                                         tenshi3003@gmail.com  clrscr();   q.nhap();   p.in();   q.in();   getch();   }  Bài 13.",LTHDT_PhamVanAt.pdf - Sentence 899
900,"Hàm b ạn, lớp bạn   13.1.",LTHDT_PhamVanAt.pdf - Sentence 900
901,"Hàm b ạn (xem m ục bài 6, chương 3) c ủa một lớp, tuy không phải l à phương th ức của lớp,  nhưng có th ể truy nhập đến các th ành ph ần riêng (private) c ủa lớp.",LTHDT_PhamVanAt.pdf - Sentence 901
902,Một h àm có th ể là bạn của nhiều  lớp.,LTHDT_PhamVanAt.pdf - Sentence 902
903,13.2.,LTHDT_PhamVanAt.pdf - Sentence 903
904,N ếu lớp A đ ược khai báo l à bạn của lớp B  thì tất cả các ph ương th ức của A đều có thể truy  nhập đến các th ành ph ần ri êng c ủa lớp B.,LTHDT_PhamVanAt.pdf - Sentence 904
905,Một lớp có thể l à bạn của nhiều lớp khác.,LTHDT_PhamVanAt.pdf - Sentence 905
906,Cũng có thể  khai báo A là b ạn của B v à B là b ạn của A.,LTHDT_PhamVanAt.pdf - Sentence 906
907,13.3.,LTHDT_PhamVanAt.pdf - Sentence 907
908,"Cách khai báo l ớp bạn   Giả sử có 3 lớp A, B v à C.",LTHDT_PhamVanAt.pdf - Sentence 908
909,"Đ ể khai báo lớp n ày là b ạn của  lớp kia, ta viết theo mẫu sau:   // Khai báo trư ớc các lớp   class A;   class B ;   class C;   // Định nghĩa các lớp   class A   {  ...",LTHDT_PhamVanAt.pdf - Sentence 909
910,friend class B ;  // L ớp B l à bạn của A   friend class C ;  // L ớp C l à bạn của A   ...,LTHDT_PhamVanAt.pdf - Sentence 910
911,};  class B   {  ...,LTHDT_PhamVanAt.pdf - Sentence 911
912,friend class A ;  // L ớp A l à bạn của B  friend class C ;  // L ớp C l à bạn của B   ...,LTHDT_PhamVanAt.pdf - Sentence 912
913,};  class C   {  ...,LTHDT_PhamVanAt.pdf - Sentence 913
914,friend class B ;  // L ớp B l à bạn của C   ...,LTHDT_PhamVanAt.pdf - Sentence 914
915,Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          156                                         tenshi3003@gmail.com  };  13.4.,LTHDT_PhamVanAt.pdf - Sentence 915
916,Ví d ụ  Chương tr ình d ưới đây có 2 lớp:   MT (ma tr ận vuông)   VT (véc tơ)   Lớp MT l à bạn của VT v à lớp VT l à bạn của MT.,LTHDT_PhamVanAt.pdf - Sentence 916
917,"Trong ch ương tr ình s ử dụng các ph ương th ức  trùng tên:   2 phương th ức nhap():   nhập ma trận   nhập véc t ơ  2 phương th ức in():   in ma tr ận  in véc tơ   4 phương th ức tich():   tích ma tr ận với ma trận, kết quả l à ma tr ận  tích ma tr ận với véc t ơ, kết quả l à véc tơ   tích véc tơ v ới ma trận,  kết quả l à véc tơ   tích véc tơ v ới véc t ơ, kết quả l à số thực   Nội dung ch ương tr ình là:   +  Nh ập các ma trận A, B, C   +  Nh ập các véc t ơ  +  Tính tích  D = AB   + Tính tích  u = Dy   + Tính tích  v = xC   + Tính tích  s = vu   //CT4_17.CPP   // Lop ban   // Lop MT , lop VT  #include <conio.h>   #include <iostream.h>   class MT;   class VT;   class MT   {  private:   double a[10][10];   int n;   public:   friend class VT;   MT()   { Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          157                                         tenshi3003@gmail.com  n=0;   }  void nhap();   void in();   VT tich(const VT &y);   MT tich(const MT &b) ;   } ;  class VT   {  private:   double x[10];   int n;  public:   friend class MT;   VT()  {  n=0;   }  void nhap();   void in();   VT tich(const MT &b);   double tich(const VT &y) ;   } ;  void MT::nhap()   {  cout << "" \n Cap ma tran: "" ;   cin >> n;   for (int i=1; i<=n; ++i)   for (int j=1; j<=n; ++j)   {  cout << "" \nPhan tu hang ""  << i << ""  cot "" << j << "" = "" ;   cin >> a[i][j];   }  }  void MT::in()   {  for (int i=1; i<=n; ++i)   {  cout << "" \n"" ;  for (int j=1; j<=n; ++j)   cout << a[i][j] << "" "" ;  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          158                                         tenshi3003@gmail.com  }  }  void VT::nhap()   {  cout << "" \n Cap vec to: "" ;   cin >> n;   for (int i=1; i<=n; ++i)   {  cout <<  ""\nPhan tu thu "" << i <<  "" = "" ;   cin >> x[i];   }  }  void VT::in()   {  for (int i=1; i<=n; ++i)   cout <<  x[i] << "" "" ;   }  VT MT::tich(const VT &y)   {  VT z;   int i,j;   for (i=1; i<=n; ++i)   {  z.x[i] = 0.0 ;   for (j=1; j<=n; ++j)   z.x[i] += a[i][j]*y.x[j];   }  z.n = n;   return z;   }  MT MT::tich(const MT &b)   {  MT c;   int i,j,k;   for (i=1; i<=n; ++i)   for (j=1; j<=n; ++j)   {  c.a[i][j] = 0.0 ;   for (k=1; k<=n; ++k)   c.a[i][j] += a[i][k]*b.a[k][j];   }  c.n = n;   return c;   } Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          159                                         tenshi3003@gmail.com  VT VT::tich(const MT &b)   {  VT z;   int i,j;   for (j=1; j<=n; ++j)   {  z.x[j] = 0.0 ;   for (i=1; i<=n; ++i)   z.x[j] += b.a[i][j]*x[i];   }  z.n = n;   return z;   }  double VT::tich(const VT &y)   {  double tg=0.0;   for (int i=1; i<=n; ++i)   tg += x[i]*y.x[i];   return tg;     }  void main()   {  MT a,b,c;   VT x,y;   clrscr();   cout << "" \nMa tran A"" ;  a.nhap();   cout << "" \nMa tran B"";   b.nhap();   cout << "" \nMa tran C"";   c.nhap();   cout << "" \nvec to X"";   x.nhap();   cout << "" \nvec to Y"";   y.nhap();   MT d= a.tich(b);   VT u = d.tich(y);   VT v = x.tich(c);   double s = v.tich(u);   cout << "" \n\nVec to v \n""; Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          160                                         tenshi3003@gmail.com  v.in();   cout << "" \n\nMa tran D"";   d.in();   cout << "" \n\nVec to y \n"";  y.in();   cout << "" \n\nS= vDy = "" << s;   getch();   }       Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          161                                         tenshi3003@gmail.com  chương 5   Dẫn xuất v à thừa kế   Có 2 khái ni ệm rất quan trọng đ ã làm nên toàn b ộ thế mạnh của ph ương pháp l ập trình h ướng đối  tượng đó l à tính k ế thừa (inheritance) v à tính tương ứng bội (polymorphism).",LTHDT_PhamVanAt.pdf - Sentence 917
918,Tính kế thừa cho phép  các lớp được xây dựng tr ên các l ớp đã có.,LTHDT_PhamVanAt.pdf - Sentence 918
919,Trong ch ương này s ẽ nói về sự thừa kế của các lớp.,LTHDT_PhamVanAt.pdf - Sentence 919
920,Bài 1.,LTHDT_PhamVanAt.pdf - Sentence 920
921,Sự dẫn xuất v à tính th ừa kế   1.1.,LTHDT_PhamVanAt.pdf - Sentence 921
922,L ớp cơ sở và lớp dẫn xuất   Một lớp đ ược xây dựng thừa kế một lớp khác gọi l à lớp dẫn xuất.,LTHDT_PhamVanAt.pdf - Sentence 922
923,Lớp d ùng đ ể xây dựng lớp dẫn  xuất gọi l à lớp cơ sở.,LTHDT_PhamVanAt.pdf - Sentence 923
924,Lớp nào cũng c ó thể là một lớp c ơ sở.,LTHDT_PhamVanAt.pdf - Sentence 924
925,"H ơn th ế nữa, một lớp có thể l à cơ s ở cho nhiều lớp dẫn  xuất khác nhau.",LTHDT_PhamVanAt.pdf - Sentence 925
926,"Đến l ượt mình, l ớp dẫn xuất lại có thể d ùng làm cơ s ở để xây dựng các lớp dân xuất  khác.",LTHDT_PhamVanAt.pdf - Sentence 926
927,Ngoài ra m ột lớp có thể dẫn xuất từ nhiều lớp c ơ sở.,LTHDT_PhamVanAt.pdf - Sentence 927
928,"Dưới đây l à một số  sơ đồ về quan hệ dẫn xuất của các lớp:   Sơ đ ồ 1:  Lớp B dẫn xuất từ lớp A, lớp C dẫn xuất từ lớp B   A    B    C        Sơ đ ồ 2:  Lớp A l à cơ s ở của các lớp B, C v à D    A          B  C  D  Sơ đ ồ 3:  Lớp D dẫn xuất từ 3 lớp A, B, C   A  B  C          D           Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          162                                         tenshi3003@gmail.com  Sơ đ ồ 4: Lược đồ dẫn xuất tổng quát   A  B  C        D    E        F  G  H  Tính th ừa kế:  Một lớp dẫn xuất ngo ài các thành ph ần của ri êng nó, nó còn được thừa kế tất cả  các thành ph ần của các lớp c ơ sở có li ên quan.",LTHDT_PhamVanAt.pdf - Sentence 928
929,Ví d ụ trong s ơ đồ 1 th ì lớp C được thừa kế các th ành  phần của các lớp B v à A.,LTHDT_PhamVanAt.pdf - Sentence 929
930,"Trong sơ đ ồ 3 th ì lớp D đ ược thừa kế các th ành ph ần của các lớp A, B v à  C.",LTHDT_PhamVanAt.pdf - Sentence 930
931,"Trong sơ đ ồ 4 th ì lớp G đ ược thừa kế các th ành ph ần của các lớp D, E, A, B v à C.",LTHDT_PhamVanAt.pdf - Sentence 931
932,1.2.,LTHDT_PhamVanAt.pdf - Sentence 932
933,Cách xây d ựng lớp dân xuất   Giả sử đ ã định nghĩ a các l ớp A v à B.,LTHDT_PhamVanAt.pdf - Sentence 933
934,"Đ ể xây dựng lớp C dân xuất từ A v à B, ta vi ết nh ư sau:   class C : public A, public B   {  private:   // Khai báo các thu ộc tính   public:   // Các phương th ức  } ;  1.3.",LTHDT_PhamVanAt.pdf - Sentence 934
935,"Th ừa kế private v à public   Trong ví d ụ trên, lớp C thừa kế public các lớp A v à B.",LTHDT_PhamVanAt.pdf - Sentence 935
936,"Nếu thay từ khoá public bằng private, th ì  sự thừa kế l à private.",LTHDT_PhamVanAt.pdf - Sentence 936
937,"Chú ý:  Nếu bỏ qua không d ùng t ừ khoá th ì hiểu là private, ví d ụ nếu định nghĩa:   class C : public A, B   {  private:   // Khai báo các thu ộc tính   public:   // Các phương th ức  } ;  thì A là l ớp cơ sở public c ủa C , c òn B là l ớp cơ sở private của C.",LTHDT_PhamVanAt.pdf - Sentence 937
938,Theo ki ểu thừa kế public th ì tất cả các th ành ph ần public của lớp c ơ sở cũng l à các thành ph ần  public c ủa lớp dẫn xuất.,LTHDT_PhamVanAt.pdf - Sentence 938
939,Theo ki ểu thừa kế private th ì tất cả các th ành ph ần public của lớp c ơ sở sẽ tr ơ thành các thành  phần private của lớp dẫn xuất.,LTHDT_PhamVanAt.pdf - Sentence 939
940,1.4.,LTHDT_PhamVanAt.pdf - Sentence 940
941,Th ừa kế các th ành ph ần dữ liệu (thuộc tính)  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          163                                         tenshi3003@gmail.com  Các thu ộc tính của lớp c ơ sở được thừa kế trong lớp dẫn xuất.,LTHDT_PhamVanAt.pdf - Sentence 941
942,Nh ư vậy tập thuộc tính của lớp  dẫn xuất sẽ gồm: các thuộc tính mới khai báo trong định nghĩa lớp dẫn xu ất và các thu ộc tính của  lớp cơ sở.,LTHDT_PhamVanAt.pdf - Sentence 942
943,Tuy v ậy trong lớp dẫn xuất không cho phép truy nhập đến các thuộc tính private của lớp c ơ sở.,LTHDT_PhamVanAt.pdf - Sentence 943
944,Chú ý:  Cho phép đ ặt trùng tên thu ộc tính trong các lớp c ơ sở và lớp dẫn xuất.,LTHDT_PhamVanAt.pdf - Sentence 944
945,"Ví dụ:  class A   {  private:   int a, b, c;   public:   ...",LTHDT_PhamVanAt.pdf - Sentence 945
946,"};  class B   {  private:   double a, b, x;   public:   ...",LTHDT_PhamVanAt.pdf - Sentence 946
947,"};  class C : public A, B   {  private:   char  *a , *x ;   int b ;    public:   ...",LTHDT_PhamVanAt.pdf - Sentence 947
948,"};  Khi đó l ớp C sẽ có các  thuộc tính:   A::a , A::b, A::c  (ki ểu int) - thừa kế từ A   B::a , B::b, B::x  (ki ểu double) - thừa kế từ  B  a, x (ki ểu char*) v à b (ki ểu int) - khai báo trong C   Trong các phương th ức của C chỉ cho phép truy nhập trực tiếp tới các thuộc tính khai báo trong  C.",LTHDT_PhamVanAt.pdf - Sentence 948
949,1.5.,LTHDT_PhamVanAt.pdf - Sentence 949
950,Th ừa kế ph ương th ức  Trừ:  + Hàm t ạo  + Hàm hu ỷ  + Toán t ử gán   các phương th ức (public) khác của lớp cơ sở được thừa kế trong lớp dẫn xuất.,LTHDT_PhamVanAt.pdf - Sentence 950
951,"Ví dụ: Trong chương tr ình d ưới đây:  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          164                                         tenshi3003@gmail.com  + Đầu tiên định nghĩa lớp DIEM có:   Các thu ộc tính x, y   Hai hàm t ạo  Phương th ức in()   + Sau đó xây d ựng lớp HINH_TRON  dẫn xuất từ lớp DIEM, đ ưa thêm:   Thuộc tính r   Hai hàm t ạo  Phương thức getR   Chú ý  cách dùng hàm t ạo của lớp c ơ sở (lớp DIEM) để xây dựng h àm tạo của lớp dẫn xuất.",LTHDT_PhamVanAt.pdf - Sentence 951
952,"+ Trong hàm main:   Khai báo đ ối tượng h kiểu HINH_TRON   Sử dụng ph ương th ức in() đối với h (sự thừa kế)   Sử dụng ph ương th ức getR đối với h   //CT5 -01  // Lop co so   #include <conio.h>   #include <iostream.h>   class DIEM   {  private:   double x, y;   public:   DIEM()   {  x = y =0.0;   }  DIEM(double x1, double y1)   {  x = x1; y = y1;   }  void in()   {  cout << "" \nx= "" << x << ""  y= "" << y;   }  };  class HINH_TRON : public DIEM   {  private:   doubl e r;  public:  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          165                                         tenshi3003@gmail.com  HINH_TRON()   {  r = 0.0;   }  HINH_TRON(double x1, double y1,   double r1): DIEM(x1,y1)   {  r = r1;   }  double getR()   {  return r;   }     };  void main()   {  HINH_TRON h(2.5,3.5,8);   clrscr();   cout << "" \nHinh tron co tam: "";   h.in();   cout << "" \nCo ban kinh= "" < < h.getR();   getch();   }  1.6.",LTHDT_PhamVanAt.pdf - Sentence 952
953,L ớp cơ sở và đối tượng th ành ph ần  Lớp cơ sở thường đ ược xử lý giống nh ư một thành ph ần kiểu đối t ượng của lớp dẫn xuất.,LTHDT_PhamVanAt.pdf - Sentence 953
954,Ví dụ  chương tr ình trong 1.5 có th ể thay bằng một ch ương tr ình khác trong đó thay vi ệc dùng l ớp cơ sở  DIEM bằng một th ành ph ần kiểu DIEM trong lớp HINH_TRON.,LTHDT_PhamVanAt.pdf - Sentence 954
955,"Ch ương tr ình m ới có thể viết nh ư  sau:  //CT5 -02  // Lop co doi tuong thanh phan   #include <conio.h>   #include <iostream.h>   class DIEM   {  private:   double x, y;   public:   DIEM()   {  x = y =0.0;  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          166                                         tenshi3003@gmail.com  }  DIEM (double x1, dou ble y1)   {  x = x1; y = y1;   }  void in()   {  cout << "" \nx= "" << x << ""  y= "" << y;   }  } ;  class HINH_TRON   {  private:   DIEM d;   double r;   public:   HINH_TRON() : d()   {  r = 0.0;   }  HINH_TRON(double x1, double y1, double r1): d(x1,y1)   {  r = r1;   }  void in()   {  d.in();   }  double getR()   {  return r;   }  };  void main()   {  HINH_TRON h(2.5,3.5,8);   clrscr();   cout << "" \nHinh tron co tam: "";   h.in();   cout << "" \nCo ban kinh= "" << h.getR();   getch();   } Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          167                                         tenshi3003@gmail.com  Bài 2.",LTHDT_PhamVanAt.pdf - Sentence 955
956,"Hàm t ạo, h àm hu ỷ đối với tính thừa kế    2.1.",LTHDT_PhamVanAt.pdf - Sentence 956
957,"L ớp dẫn xuất không thừa kế các h àm t ạo, h àm hu ỷ, toán tử gán của các lớp c ơ sở  2.2.",LTHDT_PhamVanAt.pdf - Sentence 957
958,Cách xây d ựng h àm t ạo của lớp dẫn xuất   + Hàm t ạo cần có các đối để khởi gán cho các thuộc tính (th ành ph ần dữ liệu) của lớp.,LTHDT_PhamVanAt.pdf - Sentence 958
959,+ Có th ể phân thu ộc tính l àm 3 lo ại ứng với 3 cách khởi gán khác nhau:   1.,LTHDT_PhamVanAt.pdf - Sentence 959
960,Các thu ộc tính mới khai báo  trong lớp dẫn xuất.,LTHDT_PhamVanAt.pdf - Sentence 960
961,Trong các ph ương th ức của lớp dẫn xuất có  thể truy xuất đến các thuộc tính  n ày.,LTHDT_PhamVanAt.pdf - Sentence 961
962,Vì v ậy chúng th ường đ ược khởi gán bằng các câu lệnh gán  viết trong thân hàm t ạo.,LTHDT_PhamVanAt.pdf - Sentence 962
963,2.,LTHDT_PhamVanAt.pdf - Sentence 963
964,Các thành ph ần kiểu đối t ượng.,LTHDT_PhamVanAt.pdf - Sentence 964
965,Trong lớp dẫn xuất không cho phép truy nhập đến các thuộc  tính c ủa các đối t ượng n ày.,LTHDT_PhamVanAt.pdf - Sentence 965
966,Vì v ậy để khởi gán cho các đối t ượng th ành ph ần cần d ùng hàm t ạo của  lớp tương ứng.,LTHDT_PhamVanAt.pdf - Sentence 966
967,Điều n ày đã trình b ầy trong m ục  8 chương 4.,LTHDT_PhamVanAt.pdf - Sentence 967
968,3.,LTHDT_PhamVanAt.pdf - Sentence 968
969,Các thu ộc tính thừa kế từ các lớp cở sở.,LTHDT_PhamVanAt.pdf - Sentence 969
970,Trong lớp dẫn xuất không đ ược phép truy nhập đến  các thu ộc tính n ày.,LTHDT_PhamVanAt.pdf - Sentence 970
971,"Vì v ậy để khởi gán cho các thuộc tính nói tr ên, c ần sử dụng h àm tạo của lớp c ơ  sở.",LTHDT_PhamVanAt.pdf - Sentence 971
972,"Cách thức  cũng giống nh ư kh ởi gán cho các đối tượng th ành ph ần, chỉ khác nhau ở chỗ: Để  khởi gán cho các đối t ượng th ành ph ần ta d ùng tên đ ối tượng th ành ph ần, c òn để khởi gán cho các  thuộc tính thừa kế từ các lớp c ơ sở ta d ùng tên l ớp cơ sở:  Tên_đ ối_tượng_th ành_ph ần(danh sách giá trị)   Tên_l ớp_c ơ_sở(danh sách giá trị)   Danh sách giá tr ị lấy từ các đối của h àm tạo của lớp dẫn xuất đang xây dựng   (xem ví d ụ mục 2.4 v à  bài 6, ví d ụ 1)  2.3.",LTHDT_PhamVanAt.pdf - Sentence 972
973,"Hàm hu ỷ   Khi m ột đối t ượng của lớp dẫn xuất đ ược giải phóng (bị huỷ), th ì các đối tượng th ành ph ần và  các đ ối tượng thừa kế từ các lớp c ơ sở cũng bị giải phóng theo.",LTHDT_PhamVanAt.pdf - Sentence 973
974,Do đó các h àm hu ỷ tương ứng sẽ  được gọi đến.,LTHDT_PhamVanAt.pdf - Sentence 974
975,"Như v ậy khi xây dựng h àm hu ỷ của lớp dẫn xuất, chúng ta chỉ cần quan tâm đến các thuộc tính  (không ph ải là đối tượng)  khai báo th êm trong l ớp dẫn xuất m à thôi.",LTHDT_PhamVanAt.pdf - Sentence 975
976,Ta không c ần để ý đến các đối  tượng th ành ph ần và các thu ộc tính thừa kế từ các lớ p cơ s ở.,LTHDT_PhamVanAt.pdf - Sentence 976
977,"(xem ví dụ mục 2.4 v à  bài 6, ví d ụ 2)  2.4.",LTHDT_PhamVanAt.pdf - Sentence 977
978,"Ví d ụ  xét các lớp   + Lớp NGUOI gồm:   - Các thu ộc tính   char *ht ; // H ọ tên  int ns ;   - Hai hàm t ạo, ph ương th ức in() v à hàm hu ỷ  + Lớp MON_HOC gồm:   - Các thu ộc tính   char *monhoc ; // Tên môn h ọc  int st ;               // S ố tiết   - Hai hàm t ạo, ph ương th ức in() v à hàm hu ỷ  + Lớp GIAO_VIEN :   - Kế thừa từ lớp NGUOI   - Đưa thêm các thu ộc tính  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          168                                         tenshi3003@gmail.com  char *bomon ;      // B ộ môn công tá c  MON_HOC  mh ; // Môn h ọc đang dậy   - Hai hàm t ạo , ph ương th ức in() v à hàm hu ỷ  Hãy để ý cách xây dựng các h àm t ạo, h àm hu ỷ của lớp dẫn xuất GIAO_VIEN.",LTHDT_PhamVanAt.pdf - Sentence 978
979,Trong lớp  GIAO_VIEN có th ể gọi tới 2 ph ương th ức in():   GIAO_VIEN::in()   // Đư ợc xây dựng trong lớp GIA O_VIEN   NGUOI::in()           // Th ừa kế từ lớp NGUOI   Hãy chú ý cách g ọi tới 2 ph ương th ức in() trong ch ương tr ình d ưới đây.,LTHDT_PhamVanAt.pdf - Sentence 979
980,"//CT5 -03  // Ham tao cua lop dan suat   #include <conio.h>   #include <iostream.h>   #include <string.h>   class MON_HOC   {  private:   char *mon hoc;  int st;   public:   MON_HOC()   {  monhoc=NULL;   st=0;   }  MON_HOC(char *monhoc1, int st1)   {  int n = strlen(monhoc1);   monhoc = new char[n+1];   strcpy(monhoc,monhoc1);   st=st1;   }  ~ MON_HOC()   {  if (monhoc!=NULL)   {  delete monhoc;   st=0;   }  }  void in()   { Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          169                                         tenshi3003@gmail.com  cout << "" \nTen  mon: "" << monhoc << ""  so tiet: "" << st;   }  } ;  class NGUOI   {  private:   char *ht;   int ns;   public:   NGUOI()   {  ht=NULL;   ns=0;   }  NGUOI(char *ht1, int ns1)   {  int n = strlen(ht1);   ht = new char[n+1];   strcpy(ht,ht1);   ns=ns1;   }  ~NGUOI()   {  if (ht!=NULL)   {  delete ht;   ns=0;   }  }  void in()   {  cout << "" \nHo ten : "" << ht << ""  nam sinh: "" << ns;   }  } ;  class GIAO_VIEN : public NGUOI   {  private:   char *bomon;   MON_HOC mh;   public:   GIAO_VIEN():mh(),NGUOI()//Su dung ham tao khong doi   { Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          170                                         tenshi3003@gmail.com  bomon=NULL;   }  GIAO_VIEN(char *ht1, int ns1, c har *monhoc1,int st1, char *bomon1 ):   NGUOI(ht1,ns1),mh(monhoc1, st1)   {  int n = strlen(bomon1);   bomon = new char[n+1];   strcpy(bomon,bomon1);   }  ~GIAO_VIEN()   {  if (bomon!=NULL)   delete bomon;   }  void in()   {  // Su dung phuong thuc in   NGUOI::in();   cout << "" \n Co ng tac tai bo mon: "" << bomon;   mh.in();   }  };  void main()   {  clrscr();   GIAO_VIEN g1;  // Goi toi cac ham tao khong doi   GIAO_VIEN *g2;   //Goi toi cac ham tao co doi   g2 = new GIAO_VIEN(""PHAM VAN AT"", 1945, ""CNPM"",   60, ""TIN HOC"");   g2->in();   /*  co the viet   g2->GIAO_VIEN::in();   */  g2->NGUOI::in();   getch();   delete g2; // Goi toi cac ham huy   getch();   }  Bài 3.",LTHDT_PhamVanAt.pdf - Sentence 980
981,Ph ạm vi tru y nhập đến các th ành ph ần của lớp c ơ sở Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          171                                         tenshi3003@gmail.com  3.1.,LTHDT_PhamVanAt.pdf - Sentence 981
982,"Các t ừ khoá quy định phạm vi truy nhập của lớp c ơ sở  + Mặc dù lớp dẫn xuất đ ược thừa kế tất cả các th ành ph ần của lớp c ơ sở, nh ưng trong l ớp dẫn  xuất không thể truy nhập tới tất cả các th ành ph ần này.",LTHDT_PhamVanAt.pdf - Sentence 982
983,G iải pháp th ường d ùng là s ử dụng các  phương th ức của lớp cở sở để truy nhập đến các thuộc tính của chính lớp c ơ sở đó.,LTHDT_PhamVanAt.pdf - Sentence 983
984,Cũng có thể sử  dụng các giải pháp khác d ưới đây.,LTHDT_PhamVanAt.pdf - Sentence 984
985,+ Các thành ph ần private của lớp cở sở không cho phép truy nhập trong lớp dẫn xuất.,LTHDT_PhamVanAt.pdf - Sentence 985
986,+ Các  thành ph ần public của lớp c ơ sở có thể truy nhập bất kỳ chỗ n ào trong chương tr ình.,LTHDT_PhamVanAt.pdf - Sentence 986
987,Nh ư  vậy trong các lớp dẫn xuất có thể truy nhập đ ược tới các th ành ph ần này.,LTHDT_PhamVanAt.pdf - Sentence 987
988,"+ Các thành ph ần khai báo l à protected có ph ạm vi truy nhập rộng h ơn so v ới các th ành ph ần  private, nhưng h ẹp hơn so v ới các th ành ph ần public.",LTHDT_PhamVanAt.pdf - Sentence 988
989,Các th ành ph ần protected của một lớp chỉ  được mở rộng phạm vi truy nhập cho các lớp dẫn xuất trực tiếp từ lớp n ày.,LTHDT_PhamVanAt.pdf - Sentence 989
990,3.2.,LTHDT_PhamVanAt.pdf - Sentence 990
991,"Hai ki ểu dẫn xuất   Có 2 ki ểu dẫn xuất l à private và public, chúng cho các ph ạm vi truy nhập khác nhau tới lớp c ơ  sở.",LTHDT_PhamVanAt.pdf - Sentence 991
992,Cụ thể nh ư sau:   + Các thành ph ần public v à protected c ủa lớp c ơ sở sẽ trở th ành các thành ph ần public v à  protected c ủa lớp dẫn xuất theo kiểu public.,LTHDT_PhamVanAt.pdf - Sentence 992
993,+ Các thành ph ần public v à protected c ủa lớp c ơ sở sẽ trở th ành các thành ph ần private của lớp  dẫn xuất theo kiểu private.,LTHDT_PhamVanAt.pdf - Sentence 993
994,"Ví dụ :  Giả sử lớp A có:   thuộc tính public a1    thuộc tính protected  a2    và lớp B dẫn xuất public  từ A, th ì A::a1 tr ở thành public trong B, A::a2 tr ở thành protected trong B.",LTHDT_PhamVanAt.pdf - Sentence 994
995,Do đó n ếu dùng B làm l ớp cở để xây d ựng lớp C.,LTHDT_PhamVanAt.pdf - Sentence 995
996,Th ì trong C có th ể truy nhập tới A::a1 v à  A::a2.,LTHDT_PhamVanAt.pdf - Sentence 996
997,"Thế nhưng n ếu sửa đổi để B dẫn xuất private từ A, th ì cả A::a1 v à A::a2 trơ thành private trong  B, và khi đó trong C không đư ợc phép truy nhập tới các thuộc tính A::a1 v à A::a2.",LTHDT_PhamVanAt.pdf - Sentence 997
998,"Để  biết t ường tận hơn, chúng ta h ãy biên d ịch ch ương tr ình:  //CT5 -04  // Pham vi truy nhap   #include <conio.h>   #include <iostream.h>   #include <string.h>   class A   {  protected:   int a1;   public:   int a2;   A()  {  a1=a2=0;   } Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          172                                         tenshi3003@gmail.com  A(int t1, int t2)   {  a1=t1; a2= t2;   }  void in()   {  cout < < a1 <<""  "" << a2 ;   }  } ;  class B: private A   {  protected:   int b1;   public:   int b2;   B()  {  b1=b2=0;   }  B(int t1, int t2, int u1, int u2)   {  a1=t1; a2=t2; b1=u1;b2=u2;   }  void in()   {  cout << a1 <<""  "" << a2 << ""  "" << b1 << ""  "" << b2;   }  } ;  class C : public B   {  public:   C()  {  b1=b2=0;   }  C(int t1, int t2, int u1,int u2)   {  a1=t1; a2=t2; b1=u1;b2=u2;   } Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          173                                         tenshi3003@gmail.com  void in()   {  cout << a1;   cout  <<""  "" << a2 << ""  "" << b1 << ""  "" << b2;   }  };  void main()   {  C c(1,2,3,4);   c.in();   getch();   }  Chúng ta s ẽ nhận đ ược 4 thông báo lỗi sau trong lớp C (tại h àm tạo có đối v à phương th ức in):   A::a1 is not accessible   A::a2 is not accessible   A::a1 is not accessible   A::a2 is not accessible   Bây gi ờ nếu sửa đổi để lớp B dẫn xuất public từ A th ì chương tr ình s ẽ không có lỗi và làm vi ệc  tốt.",LTHDT_PhamVanAt.pdf - Sentence 998
999,Bài 4.,LTHDT_PhamVanAt.pdf - Sentence 999
1000,Th ừa kế nhiều mức v à sự trùng tên   4.1.,LTHDT_PhamVanAt.pdf - Sentence 1000
1001,"Sơ đ ồ xây dựng các lớp dẫn xuất theo nhiều mức   Như đ ã biết:  + Khi đ ã định nghĩa một lớp (ví dụ lớp A), ta có thể d ùng nó làm cơ s ở để xây dựng lớp dẫn xuất  (ví dụ B).",LTHDT_PhamVanAt.pdf - Sentence 1001
1002,"+ Đến lượt mình, B có th ể dùng làm cơ s ở để xây dựng lớp dẫn xuất mới (ví dụ  C).",LTHDT_PhamVanAt.pdf - Sentence 1002
1003,+ Tiếp đó lại có thể d ùng C làm cơ s ở để xây dựng lớp dẫn xuất mới.,LTHDT_PhamVanAt.pdf - Sentence 1003
1004,+ Sự tiếp tục theo cách tr ên là không h ạn chế.,LTHDT_PhamVanAt.pdf - Sentence 1004
1005,Sơ đồ trên chính là s ự thừa kế nhiều mức.,LTHDT_PhamVanAt.pdf - Sentence 1005
1006,Ngo ài ra chúng ta c ũng đ ã biết:  + Một lớp có thể đ ược dẫn xuất từ nhiều lớp c ơ sở.,LTHDT_PhamVanAt.pdf - Sentence 1006
1007,+ Một lớp có thể d ùng làm cơ s ở cho nhiều lớp.,LTHDT_PhamVanAt.pdf - Sentence 1007
1008,"Hình v ẽ dưới đây l à một ví dụ về s ơ đồ thừa kế khá tổng quát, thể hiện đ ược các điều nói tr ên:  A  B  C        D    E        F  G  H  Diễn giải:  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          174                                         tenshi3003@gmail.com  Lớp D dẫn x uất từ A v à B  Lớp E dẫn xuất từ  C   Lớp F dẫn xuất từ D   Lớp G dẫn xuất từ D v à E  Lớp H dẫn xuất từ E   4.2.",LTHDT_PhamVanAt.pdf - Sentence 1008
1009,S ự thừa kế nhiều mức.,LTHDT_PhamVanAt.pdf - Sentence 1009
1010,"+ Như đ ã biết: Lớp dẫn xuất thừa kế tất cả các th ành ph ần (thuộc tính v à phương th ức) của lớp  cở sở, kể cả các th ành ph ần m à lớp cơ sở được thừa kế.",LTHDT_PhamVanAt.pdf - Sentence 1010
1011,"+ Hãy áp d ụng nguy ên lý trên để xét lớp G:   - Lớp G thừa kế các th ành ph ần của các lớp D v à E   - Lớp D thừa kế các th ành ph ần của lớp A v à B   - Lớp E thừa kế các th ành ph ần của lớp C   Như v ậy các th ành ph ần có thể sử trong lớp G gồm:   - Các thành ph ần khai báo trong G  (của ri êng G)   - Các thành ph ần khai báo trong các lớp D, E, A, B, C (đ ược thừa kế).",LTHDT_PhamVanAt.pdf - Sentence 1011
1012,4.3.,LTHDT_PhamVanAt.pdf - Sentence 1012
1013,"S ự trùng tên   Như đ ã nói trong 4.2: Trong l ớp G có thể sử dụng (trực tiép hay gián tiếp) các th ành ph ần của  riêng G và các thành ph ần m à nó đư ợc thừa kế từ các lớp D, E, A, B, C.",LTHDT_PhamVanAt.pdf - Sentence 1013
1014,Y êu cầu về cách đặt t ên ở  đây là:   + Tên các l ớp không đ ược trùng l ặp  + Tên các thành ph ần trong một lớp cũng không đ ược trùng l ặp  + Tên các thành ph ần trong các lớp khác nhau có quyền đ ược trùng l ặp.,LTHDT_PhamVanAt.pdf - Sentence 1014
1015,"Để phân biệt các thành ph ần trùng tên trong l ớp dẫn xuất, cần sử dụng th êm tên l ớp (xem ví dụ  trong 4.4).",LTHDT_PhamVanAt.pdf - Sentence 1015
1016,4.4.,LTHDT_PhamVanAt.pdf - Sentence 1016
1017,S ử dụng các th ành ph ần trong lớp dẫn xuất   Như đ ã nói ở trên: Thành ph ần của lớp dẫn xuất gồm:   + Các thành ph ần khai báo trong lớp dẫn xuất     + Các thành ph ần mà l ớp dẫn xuất thừa kế từ các lớp c ơ sở  Quy t ắc sử dụng các th ành ph ần trong lớp dẫn xuất:   Cách 1:  Dùng tên l ớp và tên thành ph ần.,LTHDT_PhamVanAt.pdf - Sentence 1017
1018,Khi đó Ch ương tr ình d ịch C++ dễ d àng phân bi ệt thành  phần thuộc lớp n ào.,LTHDT_PhamVanAt.pdf - Sentence 1018
1019,"Ví d ụ:  D   h; // h là đ ối tượng của lớp D dẫn xuấ t từ A v à B  h.D::n  là thu ộc tính n khai báo trong D   h.A::n  là thu ộc tính n thừa kế từ A (khai báo trong A)   h.D::nhap()   là phương th ức nhap() định nghĩa trong D   h.A::nhap()   là phương th ức nhap() định nghĩa trong A   Cách 2:   Không dùng tên l ớp, chỉ d ùng tên thành ph ần.",LTHDT_PhamVanAt.pdf - Sentence 1019
1020,Khi đó Ch ương tr ình d ịch C++ phải tự  phán đoán đ ể biết th ành ph ần đó thuộc lớp n ào.,LTHDT_PhamVanAt.pdf - Sentence 1020
1021,Cách phán đoán như sau: Trư ớc ti ên xem thành  phần đang xét có tr ùng tên v ới một th ành ph ần nào của lớp dẫn xuất không?,LTHDT_PhamVanAt.pdf - Sentence 1021
1022,Nếu tr ùng thì đó là  thành ph ần của l ớp dẫn xuất.,LTHDT_PhamVanAt.pdf - Sentence 1022
1023,"Nếu không tr ùng thì ti ếp tục xét các lớp c ơ sở theo thứ tự: Các lớp có  quan h ệ gần với lớp dẫn xuất xét tr ước, các lớp quan hệ xa xét sau.",LTHDT_PhamVanAt.pdf - Sentence 1023
1024,H ãy chú ý tr ường hợp sau: Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          175                                         tenshi3003@gmail.com  Thành ph ần đang xét có mặt đồng thời trong 2 lớp c ơ sở có c ùng m ột đẳng cấp qu an hệ với lớp dẫn  xuất.,LTHDT_PhamVanAt.pdf - Sentence 1024
1025,Gặp tr ường hợp n ày Chương tr ình d ịch C++ không thể quyết định đ ược th ành ph ần này th ừa  kế từ lớp n ào và bu ộc phải đ ưa ra m ột thông báo lỗi (xem ví dụ d ưới đây).,LTHDT_PhamVanAt.pdf - Sentence 1025
1026,Cách khắc phục: Tr ường  hợp này ph ải sử dụng th êm tên l ớp nh ư trình b ầy trong cách 1.,LTHDT_PhamVanAt.pdf - Sentence 1026
1027,Ví dụ xét lớp dẫn xuất D.,LTHDT_PhamVanAt.pdf - Sentence 1027
1028,Lớp D có 2 c ơ sở là các l ớp A v à B.,LTHDT_PhamVanAt.pdf - Sentence 1028
1029,"Gi ả sử  các lớp A, B v à D đư ợc  định nghĩa:   class A   {  private:   int n;   float    a[20];   public:   void nhap();   void xuat():   } ;    class B   {  private:   int m,n;   float    a[20][20];   publi c:  void nhap();   void xuat():   } ;    class D : public A, public B   {  private:   int k;   public:   void nhap();   void xuat():   } ;    Hãy chú ý các điểm sau:   1.",LTHDT_PhamVanAt.pdf - Sentence 1029
1030,"Dùng các phương th ức của các lớp A, B để xây dựng các ph ương th ức của D   // Xây d ựng ph ương th ức nhap()   void D::nhap()   {  cout << “ \n Nhap k : “  ;   cin >> k ;   // k là thu ộc tính của D   A::nhap();  // Nh ập các thuộc tính m à D th ừa kế từ A      Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          176                                         tenshi3003@gmail.com  B::nhap();  // Nh ập các thuộc tính m à D th ừa kế từ B   }  // Xây d ựng ph ương th ức xuat()   void D::xuat()   {  cout << “ \n k = “  << k ;   A::xuat();  // Xu ất các thuộc tính m à D th ừa kế từ A       B::xuat();  // Xu ất các thuộc tính m à D th ừa kế từ B   }  2.",LTHDT_PhamVanAt.pdf - Sentence 1030
1031,"Làm vi ệc với các đối t ượng của lớp dẫn xuất   D  h ; // Khai báo h là đ ối tượng của lớp D   h.nhap() ;  // tương tương v ới h.D::nhap();   h.A::xuat(); // In giá tr ị các thuộc tính h.A::n v à h.A::a   h.B::xuat(); // In giá tr ị các thuộc tính h.B::m, h.B::n v à h.B::a   h.D::xuat() ; // In giá tr ị tất cả các thuộc tính của h   h.xuat() ;      // tương đương v ới h.D::xuat() ;   Bài 5.",LTHDT_PhamVanAt.pdf - Sentence 1031
1032,Các l ớp cơ sở ảo  5.1.,LTHDT_PhamVanAt.pdf - Sentence 1032
1033,M ột lớp c ơ sở xuất hiện nhiều lần trong lớp dẫn xuất   Một điều hiển nhi ên là không th ể khai báo 2 lần c ùng m ột lớp trong danh sách của các lớp c ơ sở  cho m ột lớp dẫn xuất.,LTHDT_PhamVanAt.pdf - Sentence 1033
1034,"Chẳng hạn ví dụ sau l à không cho phép:   class B : public A, public A   {  } ;  Tuy nhiê n vẫn có thể có tr ường hợp c ùng m ột lớp c ơ sở được đề cập nhiều h ơn m ột lần trong các  lớp cơ sở trung gian của một lớp dẫn xuất.",LTHDT_PhamVanAt.pdf - Sentence 1034
1035,"Ví dụ:   #include <iostream.h>   class A   {  public:   int  a;   } ;     class B : public A   {  public:   int  b;   } ;  class C : public A   {  public:  int  c;  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          177                                         tenshi3003@gmail.com  } ;  class D : public B , public C   {  public:   int  d;   } ;  void main()   {  D  h ;   h.d = 4 ; // t ốt  h.c =  3 ; // t ốt  h.b = 2 ; // t ốt  h.a =  1 ; // l ỗi  }  Trong ví d ụ này A là cơ s ở cho cả 2 lớp c ơ sở trực tiếp của D l à B và C.",LTHDT_PhamVanAt.pdf - Sentence 1035
1036,Nói cách khác có 2 l ớp  cơ sở A cho lớp D.,LTHDT_PhamVanAt.pdf - Sentence 1036
1037,V ì vậy trong câu lệnh:   h.a = 1 ;   thì Ch ương tr ình d ịch C++ không thể nhận biết đ ược thuộc tính a thừa kế thông qua B hay thông  qua C và nó s ẽ đưa ra thông báo l ỗi sau:   Member is ambiguous:  ‘A::a’  and   ‘A::a’   5.2.,LTHDT_PhamVanAt.pdf - Sentence 1037
1038,Các l ớp cơ sở ảo  Giải pháp cho vấn đề nói tr ên là khai báo A như m ột lớp c ơ sở kiểu virtual cho cả B v à C.,LTHDT_PhamVanAt.pdf - Sentence 1038
1039,Khi đó  B và C đư ợc định nghĩa nh ư sau:   class B : virtual public A   {  public:   int  b;   } ;  class C : virtual public A   {  public:   int  c;   } ;  Các l ớp cơ sở ảo (virtual) sẽ đ ược kết hợp để tạo một lớp c ơ sở duy nhất cho bất kỳ lớp n ào dẫn  xuất từ chúng.,LTHDT_PhamVanAt.pdf - Sentence 1039
1040,"Trong ví dụ tr ên, hai l ớp cơ sở A ( A l à cơ s ở của B v à A là cơ s ở của C) sẽ kết hợp  lại để trở th ành m ột lớp c ơ sở A duy nhất cho bất kỳ lớp dẫn xuất n ào từ B v à C.",LTHDT_PhamVanAt.pdf - Sentence 1040
1041,"Như v ậy bâ y giờ D  sẽ chỉ có một lớp c ơ sở A duy nhất, do đó phép gán:   h.a = 1 ;   sẽ gán 1 cho thuộc tính a của lớp c ơ sở A duy nhất m à D k ế thừa.",LTHDT_PhamVanAt.pdf - Sentence 1041
1042,Bài 6.,LTHDT_PhamVanAt.pdf - Sentence 1042
1043,"M ột số ví dụ về h àm t ạo, h àm hu ỷ trong thừa kế nhiều mức  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          178                                         tenshi3003@gmail.com  Ví dụ 1.",LTHDT_PhamVanAt.pdf - Sentence 1043
1044,Ví dụ này minh ho ạ cách xây dựng h àm tạo trong c ác lớp dẫn xuất.,LTHDT_PhamVanAt.pdf - Sentence 1044
1045,Ngo ài ra còn minh  hoạ cách d ùng các phương th ức của các lớp c ơ sở trong lớp dẫn xuất v à cách x ử lý các đối t ượng  thành ph ần.,LTHDT_PhamVanAt.pdf - Sentence 1045
1046,"Xét 4 l ớp A, B, C  v à D.",LTHDT_PhamVanAt.pdf - Sentence 1046
1047,"L ớp C dẫn xuất từ B, lớp D dẫn xuất từ C v à có thành ph ần là đối tượng  kiểu A.",LTHDT_PhamVanAt.pdf - Sentence 1047
1048,"//CT5 -06  // Thua ke nhieu muc   // Ham tao   #include <conio.h>   #include <iostream.h>   #include <string.h>   class A   {  private:   int a;   char *str ;   public:   A()  {  a=0; str=NULL;   }  A(int a1,char *str1)   {  a=a1; str=strdup(str1);   }  void xuat()   {  cout << "" \n"" << ""So nguyen lop A = "" << a   << ""  Chuoi lop A: "" << str ;   }  } ;  class B   {  private:   int b;   char *str ;   public:   B()  {  b=0; str=NULL;   }  B(int b1,char *str1)   {  b=b1; str=strdup(str1);  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          179                                         tenshi3003@gmail.com  }  void xuat()   {  cout << "" \n"" << ""So nguyen lop B = "" << b   << ""  Chuoi lop B: "" << str ;   }  } ;  class C : public B   {  private:   int c;   char *str ;   public:   C():B()   {  c=0; str=NULL;   }  C(int b1,char *strb,int c1, char *strc) : B(b1,strb)   {  c=c1; str=strdup(strc);   }  void xuat()   {  B::xuat();   cout << "" \n"" << ""So nguyen lop C = "" << c   << ""  Chuoi lop C: "" << s tr ;  }  } ;  class D : public C   {  private:   int d;   char *str ;   A    u;   public:   D():C(),u()   {  d=0; str=NULL;   }  D(int a1, char *stra,int b1,char *strb,int c1, char *strc,  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          180                                         tenshi3003@gmail.com  int d1, char *strd) : u(a1,stra), C(b1,strb,c1,strc)   {  d=d1; str=strdup(strd);   }  void xuat ()  {  u.xuat();   C::xuat();   cout << "" \n"" << ""So nguyen lop D = "" << d   << ""  Chuoi lop D: "" << str ;   }  } ;  void main()   {  D h(1,""AA"",2,""BB"",3,""CC"",4,""DD"");   clrscr();   cout << "" \n\n Cac thuoc tinh cua h thua ke B: "" ;   h.B::xuat();   cout << "" \n\n Cac thuoc tinh cu a h thua ke B va C: "" ;   h.C::xuat();   cout << "" \n\n Cac thuoc tinh cua h thua ke B,C va khai bao trong D:"" ;   h.xuat();   getch();   }  Ví dụ 2.",LTHDT_PhamVanAt.pdf - Sentence 1048
1049,Ví dụ này minh ho ạ cách xây dựng h àm hu ỷ trong lớp dẫn xuất.,LTHDT_PhamVanAt.pdf - Sentence 1049
1050,"Ch ương tr ình trong ví  dụ này lấy từ ch ương tr ình c ủa ví dụ 1, sau đó đ ưa thêm vào các hàm hu ỷ.",LTHDT_PhamVanAt.pdf - Sentence 1050
1051,"//CT5 -07  // Thua ke nhieu muc   // Ham tao   // Ham huy   #include <conio.h>   #include <iostream.h>   #include <string.h>   class A   {  private:   int a;   char *str ;   public:   A()  { Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          181                                         tenshi3003@gmail.com  a=0; str=NULL;   }  A(int a1,char *str1)   {  a=a1; str=strdup(str1);   }  ~A()  {  cout <<"" \n Huy A""; getch();   a=0;   if (str!=NULL) delete str;   }  void xuat()   {  cout << "" \n"" << ""So nguyen lop A= "" << a   << ""  Chuoi lop A: "" << str ;   }  } ;  class B   {  private:   int b;   char *str ;   public:   B()  {  b=0; str=NULL;   }  B(int b1,char *str1)   {  b=b1; str=strdup(str1);   }  ~B()  {  cout <<"" \n Huy B""; getch();   b=0;   if (str!=NULL) delete str;   }  void xuat()   {  cout << "" \n"" << ""So nguyen lop B = "" << b   << ""  Chuoi lop B: "" << str ;   }  } ; Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          182                                         tenshi3003@gmail.com  class C : public B   {  private:   int c;   char *str ;   public:   C():B()   {  c=0; str=NULL;   }  C(int b1,char *strb,int c1, char *strc) : B(b1,strb)   {  c=c1; str=strdup(strc);   }  ~C()  {  cout <<"" \n Huy C""; g etch();   c=0;   if (str!=NULL) delete str;   }  void xuat()   {  B::xuat();   cout << "" \n"" << ""So nguyen lop C = "" << c   << ""  Chuoi lop C: "" << str ;   }  } ;  class D : public C   {  private:   int d;   char *str ;   A    u;   public:   D():C(),u()   {  d=0; str=NULL;   }  D(int a1, char *stra,int b1,char *strb,int c1, char *strc,   int d1, char *strd) : u(a1,stra), C(b1,strb,c1,strc)   { Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          183                                         tenshi3003@gmail.com  d=d1; str=strdup(strd);   }  ~D()   {  cout <<"" \n Huy D""; getch();   d=0;   if (str!=NULL) delete str;   }  void xuat()   {  u.xuat();   C::xuat();   cout << "" \n"" << ""So nguyen lop D = "" << d   << ""  Chuoi lop D: "" << str ;   }  } ;  void main()   {  D *h;   h = new D(1,""AA"",2,""BB"",3,""CC"",4,""DD"");   clrscr();   cout << "" \n\n Cac thuoc tinh cua h thua ke B: "" ;   h->B::xuat();   cout << "" \n\n Cac thuoc tinh cua h thua ke B va C: "" ;   h->C::xuat();   cout << "" \n\n Cac thuoc tinh cua h thua ke B,C va khai bao trong D:"" ;   h->xuat();   delete h; // Lan luot goi toi cac ham huy cua cac lop D, A, C, B   getch();   }  Bài 7.",LTHDT_PhamVanAt.pdf - Sentence 1051
1052,Toán t ử gán của lớp dẫn xuất   7.1.,LTHDT_PhamVanAt.pdf - Sentence 1052
1053,"Khi nào c ần xây dựng toán tử gán:  Khi l ớp dẫn xuất có các t huộc tính (kể cả thuộc tính thừa  kế từ các lớp c ơ sở) là con tr ỏ, thì nhất thiết không đ ược dùng toán t ử gán mặc định, m à phải xây  dựng cho lớp dẫn xuất một toán tử gán.",LTHDT_PhamVanAt.pdf - Sentence 1053
1054,7.2.,LTHDT_PhamVanAt.pdf - Sentence 1054
1055,Cách xây d ựng toán tử gán cho lớp dẫn xuất   + Trư ớc hết cần xây dựng toán tử gán cho các l ớp cơ sở  + Vấn đề mấu chốt l à: Khi xây d ựng toán tử gán cho lớp dẫn xuất th ì làm th ế nào để sử dụng  được các toán tử gán của lớp c ơ sở.,LTHDT_PhamVanAt.pdf - Sentence 1055
1056,Cách giải quyết nh ư sau:  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          184                                         tenshi3003@gmail.com  - Xây d ựng các ph ương th ức (trong các lớp c ơ sở) để nhận đ ược địa chỉ của đối t ượng ẩn  của  lớp.,LTHDT_PhamVanAt.pdf - Sentence 1056
1057,"Ph ương th ức này đư ợc viết đ ơn gi ản theo mẫu:   Tên_l ớp *  get_DT  ( )   {  return this ;   }  -  Trong thân c ủa toán tử gán (cho lớp dẫn xuất), sẽ d ùng phương th ức tr ên để nhận địa chỉ đối  tượng của lớp c ơ sở mà lớp dẫn xuất thừa kế.",LTHDT_PhamVanAt.pdf - Sentence 1057
1058,Sau đó thực hiện phé p gán trên các đ ối tượng n ày.,LTHDT_PhamVanAt.pdf - Sentence 1058
1059,Phương pháp nêu trên có th ể minh hoạ một cách h ình th ức nh ư sau: Gi ả sử lớp B dân xuất từ A.,LTHDT_PhamVanAt.pdf - Sentence 1059
1060,"Để xây dựng toán tử gán cho B, th ì:  1.",LTHDT_PhamVanAt.pdf - Sentence 1060
1061,Trong l ớp A cần xây dựng toán tử gán v à phương th ức cho địa chỉ của đối t ượng ẩn.,LTHDT_PhamVanAt.pdf - Sentence 1061
1062,Cụ thể A  cần được định nghĩa nh ư sau:     class A   {  ...,LTHDT_PhamVanAt.pdf - Sentence 1062
1063,A & operator=(A& h)   {  //các câu l ệnh để thực hiện gán trong A   }  // Phương th ức nhận địa chỉ đối t ượng ẩn của A   A*   get_A()   {  return this;   }  ...,LTHDT_PhamVanAt.pdf - Sentence 1063
1064,} ;  2.,LTHDT_PhamVanAt.pdf - Sentence 1064
1065,Toán t ử gán trong lớp B cần nh ư sau:   class B : public A   {  ...,LTHDT_PhamVanAt.pdf - Sentence 1065
1066,"B & operator=(B& h)   {  A  *u1, *u2;   u1 = this ->get_A();   u2 = h.get_A();   *u1 = *u2 ;  // S ử dụng phép gán trong A để gán các     // thu ộc tính m à B k ế thừa từ A              //Các câu l ệnh thực hiện gán các thuộc tính ri êng c ủa B  }  ...",LTHDT_PhamVanAt.pdf - Sentence 1066
1067,} ; Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          185                                         tenshi3003@gmail.com  7.3.,LTHDT_PhamVanAt.pdf - Sentence 1067
1068,"Ví d ụ  Chương tr ình dư ới đây minh hoạ cách xây dựng toán tử gán cho lớp D có 2 lớp c ơ sở là C và B  (C là l ớp cơ sở trực tiếp, c òn B là c ơ sở của C) .",LTHDT_PhamVanAt.pdf - Sentence 1068
1069,Ngo ài ra D còn có m ột thuộc tính l à đối tượng của  lớp A.,LTHDT_PhamVanAt.pdf - Sentence 1069
1070,"//CT5 -08  // Thua ke nhieu muc   // gan   #include <conio.h>   #include < stdio.h>   #include <iostream.h>   #include <string.h>   class A   {  private:   int a;   char *str ;   public:   A()  {  a=0; str=NULL;   }  A& operator=(A& h)   {  this->a = h.a;   if (this ->str!=NULL) delete this ->str;   this->str = strdup(h.str);   return h;   }  void nhap()   {  cout << ""\nNhap so nguyen lop A: "" ; cin >> a ;   if (str!=NULL) delete str;   cout << "" \nNhap chuoi lop A: "" ;   char tg[30];   fflush(stdin); gets(tg);   str = strdup(tg);   }  void xuat()   {  cout << "" \n"" << ""So nguyen lop A= "" << a  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          186                                         tenshi3003@gmail.com  << ""  Chuoi lop A: "" << str ;   }  } ;  class B   {  private:   int b;   char *str ;   public:   B()  {  b=0; str=NULL;   }  B* getB()   {  return this;   }  B& operator=(B& h)   {  this->b = h.b;   if (this ->str!=NULL) delete this ->str;   this->str = strdup(h.str);   return h;   }  void nhap()   {  cout << "" \nNhap so nguyen lop B: "" ; ci n >> b ;   if (str!=NULL) delete str;   cout << "" \nNhap chuoi lop B: "" ;   char tg[30];   fflush(stdin); gets(tg);   str = strdup(tg);   }  void xuat()   {  cout << "" \n"" << ""So nguyen lop B = "" << b   << ""  Chuoi lop B: "" << str ;   }  } ;  class C : public B  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          187                                         tenshi3003@gmail.com  {  private:   int c;   char *str ;   public:   C():B()   {  c=0; str=NULL;   }  C* getC()   {  return this;   }  C& operator=(C& h)   {  B *b1, *b2;   b1= this ->getB();   b2= h.getB();   *b1 = *b2;   this->c = h.c;   if (this ->str!=NULL) delete this ->str;   this->str = strdup(h.str);   return h;   }  void nhap()   {  B::nhap();   cout << "" \nNhap so nguyen lop C: "" ; cin >> c ;   if (str!=NULL) delete str;   cout << "" \nNhap chuoi lop C: "" ;   char tg[30];   fflush(stdin); gets(tg);   str = strdup(tg);   }    void xuat()   {  B::xuat();   cout << "" \n"" << ""So nguyen lop C = "" << c   << ""  Chuo i lop C: "" << str ;  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          188                                         tenshi3003@gmail.com  }  } ;  class D : public C   {  private:   int d;   char *str ;   A    u;   public:   D():C(),u()   {  d=0; str=NULL;   }  D& operator=(D& h)   {  this->u = h.u;   C *c1,*c2;   c1 = this ->getC();   c2 = h.getC();   *c1 = *c2;   this->d = h.d;   if (this ->str!=NULL) delete  this->str;   this->str = strdup(h.str);   return h;   }  void nhap()   {  u.nhap();   C::nhap();   cout << "" \nNhap so nguyen lop D: "" ; cin >> d ;   if (str!=NULL) delete str;   cout << "" \nNhap chuoi lop D: "" ;   char tg[30];   fflush(stdin); gets(tg);   str = strdup(tg);   }  void xuat()   {  u.xuat();   C::xuat();   cout << "" \n"" << ""So nguyen lop D = "" << d  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          189                                         tenshi3003@gmail.com  << ""  Chuoi lop D: "" << str ;   }  } ;  void main()   {  D h1,h2,h3;   clrscr();   h1.nhap();   h3=h2=h1;   cout<<"" \n\nH2:"";   h2.xuat();   cout<<"" \n\nH3:"";   h3.xuat();   h1.nhap();   cout<<"" \n\nH2:"";   h2.xua t();  cout<<"" \n\nH3:"";   h3.xuat();   cout<<"" \n\nH1:"";   h1.xuat();   getch();   }    Bài 8.",LTHDT_PhamVanAt.pdf - Sentence 1070
1071,Hàm t ạo sao chép của lớp dẫn xuất   8.1.,LTHDT_PhamVanAt.pdf - Sentence 1071
1072,"Khi nào c ần xây dựng h àm t ạo sao chép:  Khi l ớp dẫn xuất có các thuộc tính (kể cả thuộc tính  thừa kế từ các lớp c ơ sở) là con tr ỏ, thì nhất thiết không đ ược dùng hàm t ạo sao chép mặc định, m à  phải xây dựng cho lớp dẫn xuất một hàm tạo sao chép.",LTHDT_PhamVanAt.pdf - Sentence 1072
1073,8.2.,LTHDT_PhamVanAt.pdf - Sentence 1073
1074,Cách xây d ựng h àm t ạo sao chép cho lớp dẫn xuất   + Trư ớc hết cần xây dựng toán tử gán cho lớp dẫn xuất (xem §7).,LTHDT_PhamVanAt.pdf - Sentence 1074
1075,+ Sau đó xây d ựng h àm tạo sao chép cho lớp dẫn xuất theo mẫu:   Tên_l ớp_dẫn_xuất (T ên_lớp_dẫn_xuất  &h )   {  *this = h ;  }  8.3.,LTHDT_PhamVanAt.pdf - Sentence 1075
1076,"Ví d ụ  Chương tr ình d ưới đây minh hoạ cách xây dựng h àm tạo sao chép cho lớp D có 2 lớp c ơ sở là C  và B (C là l ớp cơ sở trực tiếp, c òn B là c ơ sở của C) .",LTHDT_PhamVanAt.pdf - Sentence 1076
1077,Ngo ài ra D còn có m ột thuộc tính l à đối tượng  của lớp A.,LTHDT_PhamVanAt.pdf - Sentence 1077
1078,Ch ương tr ình này d ựa trên chương tr ình trong m ục 7.3 với 2 thay đổi:   + Xây d ựng th êm  hàm t ạo sao chép cho lớp D.,LTHDT_PhamVanAt.pdf - Sentence 1078
1079,Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          190                                         tenshi3003@gmail.com  + Thay đ ổi một số câu lệnh trong h àm main đ ể sử d ùng hàm t ạo sao chép.,LTHDT_PhamVanAt.pdf - Sentence 1079
1080,Để thấy r õ vai trò c ủa hàm tạo sao chép chúng ta h ãy so sánh k ết quả nhận đ ược trong 2 tr ường  hợp: Có h àm tạo sao chép v à bỏ đi h àm này.,LTHDT_PhamVanAt.pdf - Sentence 1080
1081,"//CT5 -09  // Thua ke nhieu muc   // Ham tao sao chep   #include <conio.h>   #include <stdio.h>   #include <iostream.h>   #include <string.h>   class A   {  private:   int a;   char *str ;   public:   A()  {  a=0; str=NULL;   }  A& operator=(A& h)   {  this->a = h.a;   if (this ->str!=NULL) delete this ->str;   this->str = strdup(h.str);   return h;   }  void nhap()   {  cout << "" \nNhap so nguyen lop A: "" ; cin >> a ;   if (str!=NULL) delete str;   cout << "" \nNhap chuoi lop A: "" ;   char tg[30];   fflush(stdin); gets(tg);   str = str dup(tg);   }  void xuat()   {  cout << "" \n"" << ""So nguyen lop A= "" << a   << ""  Chuoi lop A: "" << str ;   } Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          191                                         tenshi3003@gmail.com  } ;  class B   {  private:   int b;   char *str ;   public:   B()  {  b=0; str=NULL;   }  B* getB()   {  return this;   }  B& operator=(B& h)   {  this->b = h.b;   if (this ->str!=NULL) d elete this ->str;   this->str = strdup(h.str);   return h;   }  void nhap()   {  cout << "" \nNhap so nguyen lop B: "" ; cin >> b ;   if (str!=NULL) delete str;   cout << "" \nNhap chuoi lop B: "" ;   char tg[30];   fflush(stdin); gets(tg);   str = strdup(tg);   }  void xuat()   {  cout < < ""\n"" << ""So nguyen lop B = "" << b   << ""  Chuoi lop B: "" << str ;   }  } ;  class C : public B   {  private:  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          192                                         tenshi3003@gmail.com  int c;   char *str ;   public:   C():B()   {  c=0; str=NULL;   }  C* getC()   {  return this;   }  C& operator=(C& h)   {  B *b1, *b2;   b1= this ->getB();   b2= h.getB();   *b1 = *b 2;  this->c = h.c;   if (this ->str!=NULL) delete this ->str;   this->str = strdup(h.str);   return h;   }  void nhap()   {  B::nhap();   cout << "" \nNhap so nguyen lop C: "" ; cin >> c ;   if (str!=NULL) delete str;   cout << "" \nNhap chuoi lop C: "" ;   char tg[30];   fflush(stdin);  gets(tg);   str = strdup(tg);   }    void xuat()   {  B::xuat();   cout << "" \n"" << ""So nguyen lop C = "" << c   << ""  Chuoi lop C: "" << str ;   }  } ; Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          193                                         tenshi3003@gmail.com  class D : public C   {  private:   int d;   char *str ;   A u;  public:   D():C(),u()   {  d=0; str=NULL;   }  D(D& h) // Ham tao sao chep   {  *this=h;   }  D& operator=(D& h)   {  this->u = h.u;   C *c1,*c2;   c1 = this ->getC();   c2 = h.getC();   *c1 = *c2;   this->d = h.d;   if (this ->str!=NULL) delete this ->str;   this->str = strdup(h.str);   return h;   }  void nhap()   {  u.nhap();   C::nhap();   cout << "" \nNhap so nguy en lop D: "" ; cin >> d ;   if (str!=NULL) delete str;   cout << "" \nNhap chuoi lop D: "" ;   char tg[30];   fflush(stdin); gets(tg);   str = strdup(tg);   }  void xuat()   { Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          194                                         tenshi3003@gmail.com  u.xuat();   C::xuat();   cout << "" \n"" << ""So nguyen lop D = "" << d   << ""  Chuoi lop D: "" << str ;   }  } ;  void main()   {  D h1;   clrscr();   h1.nhap();   D h2(h1);   cout<<"" \n\nH2:"";   h2.xuat();   h1.nhap();   cout<<"" \n\nH2:"";   h2.xuat();   cout<<"" \n\nH1:"";   h1.xuat();   getch();   }  Bài 9.",LTHDT_PhamVanAt.pdf - Sentence 1081
1082,"Phát tri ển, ho àn thi ện ch ương tr ình  Có th ể dùng tính th ừa kế để phát triển khả năng của ch ương trình.",LTHDT_PhamVanAt.pdf - Sentence 1082
1083,9.1.,LTHDT_PhamVanAt.pdf - Sentence 1083
1084,"ý t ưởng của việc phát triển ch ương tr ình nh ư sau: Sau khi đ ã xây d ựng đ ược một lớp, ta sẽ  phát tri ển lớp n ày bằng cách xây một lớp dân xuất trong đó đ ưa thêm các thu ộc tính v à phương th ức  mới.",LTHDT_PhamVanAt.pdf - Sentence 1084
1085,Quá tr ình trên l ại tiếp tục với lớp vừa nhận đ ược.,LTHDT_PhamVanAt.pdf - Sentence 1085
1086,Ta cũng có thể xây dựng các lớp mới có  thuộc tính l à đối tượng của các lớp cũ.,LTHDT_PhamVanAt.pdf - Sentence 1086
1087,"Bằng cách n ày, s ẽ nhận đ ược một dẫy các lớp c àng ngày  càng hoàn thi ện và có nhi ều khả năng h ơn.",LTHDT_PhamVanAt.pdf - Sentence 1087
1088,9.2.,LTHDT_PhamVanAt.pdf - Sentence 1088
1089,Ví d ụ về việc phát triển ch ương tr ình  Giả sử cần xây dựng ch ương tr ình v ẽ một số h ình ph ẳng.,LTHDT_PhamVanAt.pdf - Sentence 1089
1090,"Chúng ta có thể phát triển ch ương tr ình  này như sau:   Đầu ti ên định nghĩa lớp DIEM (Điểm) gồm 2 thuộc tính x, y.",LTHDT_PhamVanAt.pdf - Sentence 1090
1091,Từ lớp DIEM xây dựng lớp  DUONG_TRON (Đương tr òn) b ằng cách bổ sung 2 biến nguy ên là r (bán kính) và md (m ầu  đường).,LTHDT_PhamVanAt.pdf - Sentence 1091
1092,Từ lớp DUONG_TRON xây d ựng lớp HINH_TRON bằng cách th êm vào bi ến nguy êm mt  (mầu tô).,LTHDT_PhamVanAt.pdf - Sentence 1092
1093,"Đi theo một nhánh khác: Xây dựng lớp DOAN_THANG (Đoạn thẳng) gồm 2 đối t ượng  kiểu DIEM, v à lớp TAM_GIAC gồm 3 đối t ượng DIEM.",LTHDT_PhamVanAt.pdf - Sentence 1093
1094,"Chương tr ình d ưới đây cho phép vẽ các đ ường tr òn, hì nh tròn, đoạn thẳng v à hình tam giác.",LTHDT_PhamVanAt.pdf - Sentence 1094
1095,Chương tr ình còn minh ho ạ cách d ùng con tr ỏ this trong l ớp dẫn xuất để thực hiện các ph ương  thức của lớp co sở.,LTHDT_PhamVanAt.pdf - Sentence 1095
1096,"Ngo ài ra còn minh ho ạ cách d ùng toán t ử chỉ số []  để nhận các toạ độ x, y từ  các đ ối tượng của lớp DIEM.",LTHDT_PhamVanAt.pdf - Sentence 1096
1097,"//CT5 -10 Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          195                                         tenshi3003@gmail.com  // Phat trien chuong trinh   #include <conio.h>   #include <stdio.h>   #include <iostream.h>   #include <string.h>   #include <graphics.h>   class DIEM   {  private:   int x,y;   public:   DIEM()   {  x=y=0;   }  DIEM(int x1, int y1)   {  x=x1; y=y1;   }  DIEM(DIEM &d)   {  this->x= d.x;  this->y= d.y;   }  int operator[](int i)   {  if (i==1) return x;   else  return y;   }  };  class DUONG_TRON : public DIEM   {  private:   int r,md;   public:   DUONG_TRON() : DIEM()   {  r=md=0;   }  DUONG_TRON(DIEM d, int r1, int md1) : DIEM(d)   { Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          196                                         tenshi3003@gmail.com  r=r1; md=md1;   }  void ve()   {  setcolor(md);   circle ( (*this)[1],(*this)[2],r);   }  int getmd()   {  return md;   }  } ;  class HINH_TRON : public DUONG_TRON   {  private:   int  mt;   public:   HINH_TRON() : DUONG_TRON()   {  mt=0;   }  HINH_TRON(DIEM d, int r1, int md1, int mt1) :   DUONG_TRON(d,r1,md1)   {  mt=mt1;  }  void ve()   {  DUONG_TRON::ve();   setfillstyle(1,mt);   floodfill((*this)[1],(*this)[2],this ->getmd());   }  } ;  class DOAN_THANG   {  private:   DIEM d1, d2;   int md;   public:   DOAN_THANG() : d1(), d2()   {  md=0;  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          197                                         tenshi3003@gmail.com  }  DOAN_THANG(DIEM t1, DIEM t2, int md1)   {  d1=t1; d2 = t2; md=md1;   }  void ve()   {  setcolor(md);   line(d1[1],d1[2] ,d2[1],d2[2]);   }  } ;  class TAM_GIAC   {  private:   DIEM d1,d2,d3;   int md, mt;   public:   TAM_GIAC(): d1(), d2(), d3()   {  md=mt=0;   }  TAM_GIAC(DIEM t1,DIEM t2,DIEM t3,int md1,int mt1)   {  d1=t1; d2=t2; d3 = t3; md=md1;mt=mt1;   }  void ve()   {  DOAN_THANG(d1,d2,md).ve();   DOAN_THANG(d1,d3,md).ve();   DOAN_THANG(d2,d3,md).ve();   setfillstyle(1,mt);   floodfill((d1[1]+d2[1]+d3[1])/3,(d1[2]+d2[2]+d3[2])/3,md);   }  } ;  void ktdh()   {  int mh=0,mode=0;   initgraph(&mh,&mode,"""");   }  void main()  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          198                                         tenshi3003@gmail.com  {  ktdh();   DUONG_TRON dt(DIEM(100,100),80,MAGENTA);   HINH_TRON ht(DIEM(400,100),80,RED,YELLOW);   DOAN_THANG t(DIEM(100,100),DIEM(400,100),BLUE);   TAM_GIAC tg(DIEM(250,150), DIEM(100,400),   DIEM(400,400), CYAN, CYAN);   dt.ve();   ht.ve();   t.ve();   tg.ve();   getch();   closegraph();   }    Bài 10.",LTHDT_PhamVanAt.pdf - Sentence 1097
1098,"B ổ sung, nâng cấp ch ương tr ình  Có th ể dùng tính th ừa kế để sửa đổi, bổ sung, nâng cấp ch ương tr ình.",LTHDT_PhamVanAt.pdf - Sentence 1098
1099,10.1.,LTHDT_PhamVanAt.pdf - Sentence 1099
1100,ý t ưởng của việc nâng cấp ch ương tr ình nh ư sau: Giả sử đ ã có m ột ch ương tr ình ho ạt động  tốt.,LTHDT_PhamVanAt.pdf - Sentence 1100
1101,Bây giờ cần có một số  bổ sung thay đổi không nhiều lắm.,LTHDT_PhamVanAt.pdf - Sentence 1101
1102,"Có 2 giải pháp: Hoặc sửa chữa các  lớp đang hoạt động ổn định, hoặc xây dựng một lớp dẫn xuất để thực hiện các bổ sung, sửa chữa  trên l ớp này.",LTHDT_PhamVanAt.pdf - Sentence 1102
1103,Rõ ràng gi ải pháp thứ 2 tỏ ra hợp lý h ơn .,LTHDT_PhamVanAt.pdf - Sentence 1103
1104,10.2.,LTHDT_PhamVanAt.pdf - Sentence 1104
1105,"Ví d ụ  Giả sử đ ã có ch ương tr ình quản lý giáo vi ên gồm 3 lớp MON_HOC (Môn học), GV (Giáo vi ên)  và BM (B ộ môn) :   class  MON_HOC   {  private:   char tenmh[20] ;  // Tên môn h ọc  int    sotiet       ;   // S ố tiết   public:   MON_HOC() ;   // Hàm t ạo  const MON_HOC& operator=(const MON_HOC& m) ;   // Gán   void nhap() ;   // Nh ập  void xuat() ;   // Xu ất  } ;  class GV   { Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          199                                         tenshi3003@gmail.com  private:   char ht[25]; // Ho ten   int ns;     // Nam sinh   int sm;    // So mon hoc co the day   MON_HOC  *mh ; //Danh sach cac mon hoc   public:   GV() ;  // Hàm t ạo  ~GV() ; //Hàm hu ỷ  int getsm()  ;  // Cho bi ết số môn (d ùng trong BM::sapxep)   const GV& operator=(const GV& g); // Gán (dùng trong   // BM::sapxep)   void nhap();  // Nh ập  void xuat();  // Xu ất  } ;  class BM    // Bo mon   {  private:   char tenbm[20];  // Tên b ộ môn   int  n; // So giao vien   GV  *gv; // Danh sach giao vien   public:   BM()   // Hàm t ạo  void nhap();  // Nh ập  void xuat();   // Xu ất  void sapxep();  // S ắp xếp   } ;  Chương tr ình cho phép:   1.",LTHDT_PhamVanAt.pdf - Sentence 1105
1106,Nh ập danh sách giáo vi ên của bộ môn.,LTHDT_PhamVanAt.pdf - Sentence 1106
1107,2.,LTHDT_PhamVanAt.pdf - Sentence 1107
1108,Sắp xếp danh sách giáo vi ên theo th ứ tự giảm của số môn m à mỗi giáo vi ên có th ể giảng dậy.,LTHDT_PhamVanAt.pdf - Sentence 1108
1109,3.,LTHDT_PhamVanAt.pdf - Sentence 1109
1110,In danh sách giáo viên.,LTHDT_PhamVanAt.pdf - Sentence 1110
1111,"Nội dung ch ương tr ình nh ư sau:   //CT5 -11  // Nang cap chuong trinh   // CT ban dau   #include <conio.h>   #include <stdio.h>   #include <iostream.h>   #include <string.h>   class MON_HOC  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          200                                         tenshi3003@gmail.com  {  private:   char tenmh[20 ];  int sotiet;   public:   MON_HOC()   {  tenmh[0]=sotiet=0;   }  const MON_HOC& operator=(const MON_HOC& m)   {  strcpy(this ->tenmh,m.tenmh);   this->sotiet = m.sotiet;   return m;   }  void nhap()   {  cout << "" \nTen mon hoc:"";   fflush(stdin); gets(tenmh);   cout << ""So tiet: "" ;   cin >> sotiet;   }  void xuat()   {  cout << "" \nTen mon hoc:"" << tenmh   << ""   so tiet: "" << sotiet;   }  } ;  class GV   {  private:   char ht[25]; // Ho ten   int ns;     // Nam sinh   int sm;    // So mon hoc co the day   MON_HOC  *mh ; //Danh sach cac mon hoc   public:   GV()   {  ht[0]= ns= sm= 0 ;   mh = NULL;   } Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          201                                         tenshi3003@gmail.com  ~GV()   {  ht[0]= ns= sm= 0 ;   if (mh) delete mh;   }  int getsm()   {  return sm;   }  const GV& operator=(const GV& g);   void nhap();   void xuat();   } ;  const GV& GV::operator=(const GV& g)   {  strcpy(this ->ht,g.ht);   this->ns=g.ns;   int n = g.sm;   this->sm = n;   if (this ->mh) delete this ->mh;   if (n)   {  this->mh = new MON_HOC[n+1];   for (int i=1; i<=n; ++i)   this->mh[i] = g.mh[i];   }  return g;   }  void GV::nhap()   {  cout << "" \nHo ten: "" ;   fflush(stdin); gets(ht);   cout << ""Nam sinh: "" ;   cin >> ns;   cout << ""So mon co the giang day: "" ;   cin >> sm;   if (this ->mh) delete this ->mh;   if(sm)   {  this->mh = new MON_HOC[sm+1];  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          202                                         tenshi3003@gmail.com  for (int i=1; i<=sm; ++i)   this->mh[i].nhap();   }  }  void GV::xuat()   {  cout << "" \nHo ten: "" << ht ;   cout << "" \nNam sinh: "" << ns ;   cout << "" \nSo mon co the giang day: "" << sm;   if (sm)   {  cout << "" \n Do la: "";   for (int i=1; i<=sm; ++i)   this->mh[i].xuat();   }  }  class BM    // Bo mon   {  private:   char tenbm[20];   int  n; // So giao vien   GV  *gv; // Danh sach giao vien   public:   BM()   {  tenbm[0] = n = 0;   gv = NULL;   }  void nhap();   void xuat();   void sapxep();   } ;  void BM::nhap()   {  cout << "" \n\nTen bo mon: "" ;   fflush(stdin); gets(tenbm);   cout << ""So giao vien: "";   cin >> n;   if (gv) delete gv;   if (n)   { Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          203                                         tenshi3003@gmail.com  gv = new GV[n+1];   for (int i=1; i<=n; ++i)   gv[i].nhap();   }  }  void BM::xuat()   {  cout << "" \nBo mon: "" << tenbm;   cout << "" \nSo giao vien: "" << n;   if (n)   {  cout << "" \n Danh sach giao vien cua bo mon:"";   for (int i=1; i<=n; ++i)   gv[i].xuat();   }  }  void BM::sapxep()   {  GV tg;   int i,j;   if (n)   for (i=1;i<n;++i)   for (j=i+1;j<=n; ++j)   if (gv[i].getsm()<gv[j].getsm())   {  tg=gv[i]; gv[i]=gv[j]; gv[j]=tg;   }  }  void main()   {  BM b;   b.nhap();   b.sapxep();   b.xuat();   getch();   }  Vấn đề đặt ra l à: Hi ện nay các giáo vi ên đã bắt đầu h ướng dẫn luận văn tốt nghiệp cho sinh vi ên.",LTHDT_PhamVanAt.pdf - Sentence 1111
1112,Vì vậy cần bổ sung  thông tin này vào ph ần dữ liệu giáo vi ên.,LTHDT_PhamVanAt.pdf - Sentence 1112
1113,"Đ ể nâng cấp ch ương tr ình chúng ta s ẽ  định nghĩa lớp GV2 dẫn xuất từ lớp GV, sau đó trong lớp BM sẽ thay GV bằng GV2.",LTHDT_PhamVanAt.pdf - Sentence 1113
1114,Có 2 chỗ cần  bổ sung v à một chỗ cần sửa đổi nh ư sau:   1.,LTHDT_PhamVanAt.pdf - Sentence 1114
1115,Bổ sung trong lớp GV ph ương th ức:  GV*  g etGV()  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          204                                         tenshi3003@gmail.com  {  return this;   }  Phương th ức này dùng đ ể xây dựng toán tử gán cho lớp GV2.,LTHDT_PhamVanAt.pdf - Sentence 1115
1116,2.,LTHDT_PhamVanAt.pdf - Sentence 1116
1117,Trong l ớp BM thay  GV bằng GV2.,LTHDT_PhamVanAt.pdf - Sentence 1117
1118,Điều n ày có th ể đạt đ ược bằng sửa chữa trực tiếp hoặc  bằng một câu lệnh #define :   #define  GV  GV2   3.,LTHDT_PhamVanAt.pdf - Sentence 1118
1119,"Định nghĩa th êm 2 l ớp: LV (Luận văn) và GV2  (L ớp GV2 dẫn xuất từ lớp GV) nh ư sau:   class LV // Luan van   {  private:   char tenlv[30]; // Ten luan van   char tensv[25]; // Ten sinh vien   int nambv;      // Nam bao ve luan van   public:   LV() ;  // Hàm t ạo  const LV& operator=(const LV& l) ; // Gán   void nhap() ; // Nh ập  void xuat() ;   } ;  class GV2 : public GV   {  private:   int solv;  // S ố luận văn đ ã hướng dẫn   LV  *lv;  // Danh sách lu ận văn   public:   GV2(); // Hàm t ạo  ~GV2() ; // Hàm hu ỷ  GV2& operator=(GV2& g); // Gán   void nhap(); // Nh ập  void xuat(); // Xu ất  } ;    Chương tr ình nâng c ấp nh ư sau:   //CT5 -12B  // Nang cap chuong trinh   // CT nang cap   #include <conio.h>   #include <stdio.h>   #include <iostream.h>   #include <string.h>   class MON_HOC  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          205                                         tenshi3003@gmail.com  {  private:   char tenmh[20];   int sotiet;   public:   MON_HOC()   {  tenmh[0]=sotiet =0;  }  const MON_HOC& operator=(const MON_HOC& m)   {  strcpy(this ->tenmh,m.tenmh);   this->sotiet = m.sotiet;   return m;   }  void nhap()   {  cout << "" \nTen mon hoc:"";   fflush(stdin); gets(tenmh);   cout << ""So tiet: "" ;   cin >> sotiet;   }  void xuat()   {  cout << "" \nTen mon  hoc:"" << tenmh   << ""   so tiet: "" << sotiet;   }  } ;  // Bo sung phuong thuc getGV cho lop GV   // dung de xay dung toan tu gan cho lop GV2   class GV   {  private:   char ht[25]; // Ho ten   int ns;     // Nam sinh   int sm;    // So mon hoc co the day   MON_HOC  *mh ; //D anh sach cac mon hoc   public:   GV()   {  ht[0]= ns= sm= 0 ;  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          206                                         tenshi3003@gmail.com  mh = NULL;   }  ~GV()   {  ht[0]= ns= sm= 0 ;   if (mh) delete mh;   }  // Bo sung phuong thuc getGV   GV* getGV()   {  return this;   }  int getsm()   {  return sm;   }  const GV& operator=(const GV& g);   void nhap();   void xua t();  } ;  const GV& GV::operator=(const GV& g)   {  strcpy(this ->ht,g.ht);   this->ns=g.ns;   int n = g.sm;   this->sm = n;   if (this ->mh) delete this ->mh;   if (n)   {  this->mh = new MON_HOC[n+1];   for (int i=1; i<=n; ++i)   this->mh[i] = g.mh[i];   }  return g;   }  void GV::nh ap()  {  cout << "" \nHo ten: "" ;   fflush(stdin); gets(ht);   cout << ""Nam sinh: "" ;  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          207                                         tenshi3003@gmail.com  cin >> ns;   cout << ""So mon co the giang day: "" ;   cin >> sm;   if (this ->mh) delete this ->mh;   if (sm)   {  this->mh = new MON_HOC[sm+1];   for (int i=1; i<=sm; ++i)   this->mh[i].nhap();   }  }  void GV::xuat()   {  cout << "" \nHo ten: "" << ht ;   cout << "" \nNam sinh: "" << ns ;   cout << "" \nSo mon co the giang day: "" << sm;   if (sm)   {  cout << "" \n Do la: "";   for (int i=1; i<=sm; ++i)   this->mh[i].xuat();   }  }    // Bo sung cac lop LV va GV2   class LV // Luan v an  {  private:   char tenlv[30]; // Ten luan van   char tensv[25]; // Ten sinh vien   int nambv;      // Nam bao ve luan van   public:   LV()  {  tenlv[0]=tensv[0] = nambv = 0;   }  const LV& operator=(const LV& l)   {  strcpy(this ->tenlv,l.tenlv);   strcpy(this ->tensv,l.tensv ); Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          208                                         tenshi3003@gmail.com  this->nambv = l.nambv ;   return l;   }  void nhap()   {  cout << "" \nTen luan van:"";   fflush(stdin); gets(tenlv);   cout << ""Ten sinh vien:"";   fflush(stdin); gets(tensv);   cout << ""Nam bao ve: "" ;   cin >> nambv ;   }  void xuat()   {  cout << "" \nTen lan van:"" << tenlv   <<  ""    Sinh vien: "" << tensv   << ""   Nam bao ve: "" << nambv;   }  } ;  class GV2 : public GV   {  private:   int solv;   LV  *lv;   public:   GV2():GV()   {  solv = 0 ;   lv = NULL;   }  ~GV2()   {  if (solv) delete lv;   }  GV2& operator=(GV2& g);   void nhap();   void xuat();   } ;  GV2& GV2: :operator=(GV2& g)   { Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          209                                         tenshi3003@gmail.com  GV *g1, *g2;   g1 = this ->getGV();   g2 = g.getGV();   *g1 = *g2;   int n = g.solv;   this->solv = n;   if (this ->lv) delete this ->lv;  if (n)   {  this->lv = new LV[n+1];   for (int i=1; i<=n; ++i)   this->lv[i] = g.lv[i];   }  return g;   }  void GV2::nhap()   {  GV::nhap();   cout << ""So luan van da huong dan: "" ;   cin >> solv;   if (this ->lv) delete this ->lv;  if (solv)   {  this->lv = new LV[solv+1];   for (int i=1; i<=solv; ++i)   this->lv[i].nhap();   }  }  void GV2::xuat()   {  GV::xuat();   cout << "" \nSo luan van da huong dan: "" << solv;   if (solv)   {  cout << "" \n Do la: "";   for (int i=1; i<=solv; ++i)   this->lv[i].xuat();   }  } Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          210                                         tenshi3003@gmail.com  // Sua lop BM: thay GV bang GV2   #define GV GV2   class BM    // Bo mon   {  private:   char tenbm[20];   int  n; // So giao vien   GV  *gv; // Danh sach giao vien   public:   BM()   {  tenbm[0] = n = 0;   gv = NULL;   }  void nhap();   void xuat();   void sapxep();   } ;  void BM::nhap()   {  cout << "" \n\nTen bo mon: "" ;   fflush(stdin); gets(tenbm);   cout << ""So giao vien: "";   cin >> n;   if (gv) delete gv;   if (n)   {  gv = new GV[n+1];   for (int i=1; i <=n; ++i)   gv[i].nhap();   }  }  void BM::xuat()   {  cout << "" \nBo mon: "" << tenbm;   cout << "" \nSo giao vien: "" << n;   if (n)   {  cout << "" \n Danh sach giao vien cua bo mon:"";   for (int i=1; i<=n; ++i)   gv[i].xuat();  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          211                                         tenshi3003@gmail.com  }  }  void BM::sapxep()   {  GV tg;   int i,j;   if (n)   for (i=1;i<n;++i)   for (j=i+1;j<=n;++j)   if (gv[i].getsm()<gv[j].getsm())   {  tg=gv[i]; gv[i]=gv[j]; gv[j]=tg;   }  }  #undef GV   void main()   {  BM b;   b.nhap();   b.sapxep();   b.xuat();   getch();   }    Bài 11.",LTHDT_PhamVanAt.pdf - Sentence 1119
1120,"T ừ khái quát đến cụ thể   Tính th ừa kế cũng th ường d ùng đ ể thiết kế cá c bài toán theo hư ớng từ khái quát đến cụ thể, từ  chung đ ến riêng.",LTHDT_PhamVanAt.pdf - Sentence 1120
1121,"Đ ầu tiên đưa ra các l ớp để mô tả những đối t ượng chung, sau đó dẫn xuất tới các  đối tượng ng ày m ột cụ thể h ơn.",LTHDT_PhamVanAt.pdf - Sentence 1121
1122,Một trường hợp khác cũng th ường gặp l à: Qu ản lý nhiều thực thể có những phần d ữ liệu chung.,LTHDT_PhamVanAt.pdf - Sentence 1122
1123,Khi đó ta có th ể xây dựng một lớp c ơ sở gồm các phần dữ liệu chung.,LTHDT_PhamVanAt.pdf - Sentence 1123
1124,Mỗi thực thể sẽ đ ược mô tả  bằng một lớp dẫn xuất từ lớp c ơ sở này.,LTHDT_PhamVanAt.pdf - Sentence 1124
1125,Sau đây là m ột số ví dụ minh hoạ:   Ví dụ 1 (minh ho ạ tư tưởng đi từ khái quát đến cụ thể) : Giả sử cần quản lý sinh viên c ủa một  trường đại học.,LTHDT_PhamVanAt.pdf - Sentence 1125
1126,Khi đó ta có thể bắt đầu từ lớp SINH_VIEN (Sinh vi ên).,LTHDT_PhamVanAt.pdf - Sentence 1126
1127,"Sau đó dùng nó làm cơ s ở  để dẫn xuất tới các lớp mô tả các đối t ượng sinh vi ên cụ thể h ơn, ví d ụ:  SV Tin, SV Toán, SV Luật,  SV Du l ịch, ...",LTHDT_PhamVanAt.pdf - Sentence 1127
1128,Các bài toán ki ểu nh ư vậy rất th ường gặp trong thực tế.,LTHDT_PhamVanAt.pdf - Sentence 1128
1129,Ví dụ 2 (minh ho ạ phần chung của nhiều thực thể).,LTHDT_PhamVanAt.pdf - Sentence 1129
1130,Giả sử cần xây dựng phần mềm để thực hiện  các phép tính v ề ma trân vuông v à véc tơ c ấp n.,LTHDT_PhamVanAt.pdf - Sentence 1130
1131,Ta có nhận xét l à n chung cho c ả véc t ơ và ma tr ận.,LTHDT_PhamVanAt.pdf - Sentence 1131
1132,Hơn n ữa nó c òn chung cho t ất cả  các ma tr ận và véc tơ cùng xét trong bài toán.,LTHDT_PhamVanAt.pdf - Sentence 1132
1133,V ì vậy có thể định Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          212                                         tenshi3003@gmail.com  nghĩa một lớp c ơ sở chỉ có một thuộc tính tĩnh (static) n.,LTHDT_PhamVanAt.pdf - Sentence 1133
1134,"Các lớp ma trận, véc t ơ dẫn xuất từ lớp n ày  và sử dụng chung c ùng m ột giá trị n.",LTHDT_PhamVanAt.pdf - Sentence 1134
1135,"Dưới đây l à chương tr ình th ực hiện các phép toán ma tr ận, véc t ơ.",LTHDT_PhamVanAt.pdf - Sentence 1135
1136,"Chương tr ình được tổ chức  thành 3 l ớp:  Lớp CAP (Cấp ma trận, véc t ơ) gồm một th ành ph ần tĩnh n v à phương th ức nhập n.",LTHDT_PhamVanAt.pdf - Sentence 1136
1137,"Lớp VT (Véc t ơ) có m ột thuộc tính l à mảng một chiều (chứa các phần tử của véc t ơ) và các  phương th ức nhập, xuất.",LTHDT_PhamVanAt.pdf - Sentence 1137
1138,"Lớp MT ( Ma tr ận) có một thuộc tính l à mảng 2 chiều (chứa các phần tử của ma trận) , các  phương th ức nhập, xuất v à nhân.",LTHDT_PhamVanAt.pdf - Sentence 1138
1139,L ớp MT l à bạn của lớp VT.,LTHDT_PhamVanAt.pdf - Sentence 1139
1140,"Chương tr ình s ẽ nhập một ma trận, nhập một véc t ơ và tính tích c ủa chúng.",LTHDT_PhamVanAt.pdf - Sentence 1140
1141,"//CT5 -13  // ma tran vec to   // Dùng thu ộc tín h static   #include <conio.h>   #include <stdio.h>   #include <iostream.h>   #include <ctype.h>   class CAP;   class MT;   class VT;   class CAP   {  private:   static int n;   public:   void nhap()   {  int ch;   if (n==0)   {  cout << "" \nN= ""; cin >> n;   }  else  {  cout <<"" \n Hien n = "" <<   n;  cout << "" \n Co thay doi n?",LTHDT_PhamVanAt.pdf - Sentence 1141
1142,"- C/K"";   ch=toupper(getch());   if (ch=='C')   {  cout << "" \nN= ""; cin >> n;   }  } Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          213                                         tenshi3003@gmail.com  }  int getN()   {  return n;   }  } ;  int CAP::n=0;   class  MT : public CAP   {  private:   double a[20][20];   public:   void nhap();   void xuat();   VT operator*(VT x) ;  };  class  VT : public CAP   {  private:   double x[20];   public:   friend class MT;   void nhap();   void xuat();   };  void MT::nhap()   {  int n,i,j;   n = this ->getN();   if (n==0)   {  this->CAP::nhap();   n = this ->getN();   }  for (i=1; i<=n; ++i)   for (j=1; j<=n; ++j)   {  cout <<  "" PT hang "" << i << "" cot "" << j << "" = "";   cin >> a[i][j];   }  } Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          214                                         tenshi3003@gmail.com  void MT::xuat()   {  int n,i,j;   n = this ->getN();   if (n)   for (int i=1; i<=n; ++i)   {  cout << "" \n"" ;  for (int j=1; j<=n; ++j)   cout <<  a[i][j] << "" "";   }  }  VT MT::operator*(VT x)   {  VT y;   int n,i,j;   n = this ->getN();   for (i=1; i<=n; ++i)   {  y.x[i]=0;   for (j=1; j<=n; ++j)   y.x[i] += a[i][j]*x.x[j];   }  return y;   }  void VT::nhap()   {  int n,i;   n = this ->getN();   if (n==0)   {  this->CAP::nhap();   n = this ->getN();   }  for (i=1; i<=n; ++i)   {  cout << "" PT thu "" << i < <  "" = "";   cin >> x[i];   }  }  void VT::xuat()  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          215                                         tenshi3003@gmail.com  {  int n,i;   n = this ->getN();   if (n)   {  cout << "" \n"";  for (int i=1; i<=n; ++i)   {  cout <<  x[i] << "" "";   }  }  }  void main()   {  MT a; VT x,y;   clrscr();   cout<<"" \nNhap ma tran A:"";   a.nhap();   cout<<"" \n\nNhap Vec to X: \n"";  x.nhap();   y = a*x;   cout<<"" \n\nMa tran A"";   a.xuat();   cout<<"" \n\nVec to X"";   x.xuat();   cout<<"" \n\nVec to Y=AX"";   y.xuat();   getch();   }  Bài 12.",LTHDT_PhamVanAt.pdf - Sentence 1142
1143,"Toàn th ể và bộ phận   Thông thư ờng khi xem xét, giải quyết một b ài toán, ta thư ờng chia nó th ành các bài toán nh ỏ  hơn.",LTHDT_PhamVanAt.pdf - Sentence 1143
1144,Nó i cách khác: M ột bài toán l ớn bao gồm nhiều b ài toán b ộ phận.,LTHDT_PhamVanAt.pdf - Sentence 1144
1145,Khi đó ta có thể định nghĩa  các lớp cho các b ài toán b ộ phận.,LTHDT_PhamVanAt.pdf - Sentence 1145
1146,Lớp cho b ài toán chung đư ợc dẫn xuất từ các lớp nói tr ên.,LTHDT_PhamVanAt.pdf - Sentence 1146
1147,Xét m ột thí dụ đ ơn gi ản là bài toán qu ản lý th ư viện.,LTHDT_PhamVanAt.pdf - Sentence 1147
1148,Nó gồm 2 b ài toán b ộ phận là quản lý sách  và qu ản lý đọc giả.,LTHDT_PhamVanAt.pdf - Sentence 1148
1149,Chúng ta sẽ xây dựng lớp SACH v à lớp DOC_GIA.,LTHDT_PhamVanAt.pdf - Sentence 1149
1150,Sau đó d ùng các l ớp này  làm cơ sở để xây dựng lớp THU_VIEN          Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          216                                         tenshi3003@gmail.com  Chương 6   Tương ứng bội v à phương th ức ảo   Tương ứng bội v à phương th ức ảo l à  công c ụ mạnh của C++ cho phép tổ chức quản lý các  đối tượng khác nhau theo c ùng m ột lược đồ.,LTHDT_PhamVanAt.pdf - Sentence 1150
1151,Một khái niệm khác li ên quan là: l ớp cơ sở trừu t ượng.,LTHDT_PhamVanAt.pdf - Sentence 1151
1152,Chương này s ẽ trình b ầy cách s ử dụng các công cụ tr ên để xây dựng ch ương tr ình qu ản lý nhiều đối  tượng khác nhau theo một l ược đồ thống nhất.,LTHDT_PhamVanAt.pdf - Sentence 1152
1153,Bài 1.,LTHDT_PhamVanAt.pdf - Sentence 1153
1154,Phương th ức tĩnh   1.1.,LTHDT_PhamVanAt.pdf - Sentence 1154
1155,L ời gọi tới ph ương th ức tĩnh   Như đ ã biết một lớp dẫn xuất đ ược thừa kế các ph ương th ức của các lớp c ơ sở tiền bối của nó.,LTHDT_PhamVanAt.pdf - Sentence 1155
1156,"Ví dụ lớp A l à cơ s ở của B, lớp B lại l à cơ s ở của C, th ì C có 2 l ớp cơ sở tiền bối l à B và A.",LTHDT_PhamVanAt.pdf - Sentence 1156
1157,L ớp C  được thừa kế các ph ương th ức của A v à B.,LTHDT_PhamVanAt.pdf - Sentence 1157
1158,Các phương th ức m à chúng ta v ẫn nói l à các phương  thức tĩnh.,LTHDT_PhamVanAt.pdf - Sentence 1158
1159,"Để t ìm hi ểu th êm v ề cách gọi tới các ph ương thức tĩnh, ta xét ví dụ về các lớp A, B v à  C   như sau:   class A   {  public:   void xuat()   {  cout << "" \n Lop A "" ;   }  };  class B:public A   {  public:   void xuat()   {  cout << "" \n Lop B "" ;   }  };  class C:public B   {  public:   void xuat()   {  cout << "" \n Lop C "" ;   }  };  Lớp C  có 2 l ớp cơ sở tiền bối l à A , B và C k ế thừa các ph ương th ức của A v à B.",LTHDT_PhamVanAt.pdf - Sentence 1159
1160,Do đó m ột đối  tượng của C sẽ có  tới 3 ph ương th ức xuat.,LTHDT_PhamVanAt.pdf - Sentence 1160
1161,H ãy theo rõi các câu l ệnh sau:   C  h ; //  h là đ ối tượng kiểu C   h.xuat() ; // G ọi tới ph ương th ức h.D::xuat()  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          217                                         tenshi3003@gmail.com  h.B::xuat() ; // Gọi tới ph ương th ức h.B::xuat()   h.A::xuat() ; // G ọi tới ph ương th ức h.A::xuat()   Các l ời gọi ph ương th ức trong ví dụ tr ên đều xuất phát từ đối t ượng h v à mọi lời gọi đều xác  định rõ phương th ức cần gọi.,LTHDT_PhamVanAt.pdf - Sentence 1161
1162,Bây gi ờ chúng ta h ãy xét các l ời gọi không phải từ  một biến đối t ượng m à từ một con trỏ.,LTHDT_PhamVanAt.pdf - Sentence 1162
1163,"Xét  các câu l ệnh:  A  *p, *q, *r;   // p, q, r là con tr ỏ kiểu A   A   a;    //  a là đ ối tượng kiểu A   B   b;    //  b là đ ối tượng kiểu B   C   c;    //  c là đ ối tượng kiểu c   Chúng ta hãy ghi nh ớ mệnh đề sau  về con trỏ c ủa các lớp dẫn xuất v à cơ s ở:  Phép gán con tr ỏ:  Con tr ỏ của lớp c ơ sở có thể d ùng đ ể chứa địa chỉ các đối t ượng của lớp dẫn  xuất.",LTHDT_PhamVanAt.pdf - Sentence 1163
1164,"Như v ậy cả 3 phép gán sau đều hợp lệ:   p =  &a ;   q =  &b ;   r =   &c ;     Chúng ta ti ếp tục xét các lời gọi ph ương th ức từ các co n trỏ p, q, r:   p->xuat();   q->xuat();   r->xuat();   và hãy lý gi ải xem ph ương th ức nào (trong các phương th ức A::xuat, B::xuat v à C::xuat) đư ợc gọi.",LTHDT_PhamVanAt.pdf - Sentence 1164
1165,"Câu tr ả lời nh ư sau:   Cả 3 câu lệnh tr ên đều gọi tới ph ương th ức A::xuat() , v ì các con tr ỏ p, q v à r đều có kiể u A.",LTHDT_PhamVanAt.pdf - Sentence 1165
1166,Như v ậy có thể tóm l ược cách thức gọi các ph ương th ức tĩnh nh ư sau:   Quy t ắc gọi ph ương th ức tĩnh: Lời gọi tới ph ương th ức tĩnh bao giờ cũng xác định r õ phương  thức nào (trong s ố các ph ương th ức trùng tên c ủa các lớp có quan hệ thừa kế) đ ược gọi:   1.,LTHDT_PhamVanAt.pdf - Sentence 1166
1167,"Nếu lời gọi xuất phát từ một đối t ượng của lớp n ào,  thì ph ương th ức của lớp đó sẽ đ ược gọi.",LTHDT_PhamVanAt.pdf - Sentence 1167
1168,2.,LTHDT_PhamVanAt.pdf - Sentence 1168
1169,"Nếu lời gọi xuất phát từ một  con trỏ kiểu lớp n ào,  thì ph ương th ức của lớp đó sẽ đ ược gọi bất  kể con trỏ chứa địa chỉ của đối t ượng n ào.",LTHDT_PhamVanAt.pdf - Sentence 1169
1170,1.2.,LTHDT_PhamVanAt.pdf - Sentence 1170
1171,"Ví d ụ  Xét 4 l ớp A , B, C và D.",LTHDT_PhamVanAt.pdf - Sentence 1171
1172,L ớp B v à C có chung l ớp cơ sở A.,LTHDT_PhamVanAt.pdf - Sentence 1172
1173,Lớp D dẫn xuất từ C.,LTHDT_PhamVanAt.pdf - Sentence 1173
1174,Cả 4 lớp đều có  phương th ức xuat().,LTHDT_PhamVanAt.pdf - Sentence 1174
1175,"Xét h àm:  void hien(A *p)   {  p->xuat();   }  Không c ần biết tới địa chỉ của đối t ượng n ào sẽ truyền cho đối con trỏ p, lời gọi trong h àm luôn  luôn g ọi tới ph ương th ức A::xuat() v ì con tr ỏ p kiểu A.",LTHDT_PhamVanAt.pdf - Sentence 1175
1176,Nh ư vậy bốn câu lệnh:   hien(&a);   hien(&b);  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          218                                         tenshi3003@gmail.com  hien(&c);   hien(&d);   trong hàm main (c ủa ch ương tr ình d ưới đây) đều gọi tới A::xuat().,LTHDT_PhamVanAt.pdf - Sentence 1176
1177,"//CT6 -01  // Phuong thuc tinh   #include <conio.h>   #include <stdio.h>   #include <iostream.h>   #include <ctype.h>   class A   {  private:   int n;   public:   A()  {  n=0;   }  A(int n1)   {  n=n1;   }  void xuat()   {  cout << "" \nLop A: ""<< n;   }  int getN()   {  return n;   }  };  class B:public A   {  public:   B():A()   {  }  B(int n1):A(n1)   {  }  void xuat()   { Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          219                                         tenshi3003@gmail.com  cout << "" \nLop B: ""<<getN() ;  }  };  class C:public A   {  public:   C():A()   {  }  C(int n1):A(n1)   {  }  void xuat()   {  cout << "" \nLop C: ""<<getN();   }  };  class D:public C   {  public:   D():C()   {  }  D(int n1):C(n1)   {  }  void xuat()   {  cout << "" \nLop D: ""<<getN();   }  };  void hien(A *p)   {  p->xuat();   }  void main()   {  A a(1);   B b(2);   C c(3);   D d(4);  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          220                                         tenshi3003@gmail.com  clrscr();   hien(&a);   hien(&b);   hien(&c);   hien(&d);   getch();   }  Bài 2.",LTHDT_PhamVanAt.pdf - Sentence 1177
1178,Sự hạn chế của ph ương th ức tĩnh   Ví dụ sau cho thấy sự hạn chế của ph ương th ức tĩnh trong việc sử dụng tính thừa kế để phát triển  chương tr ình.,LTHDT_PhamVanAt.pdf - Sentence 1178
1179,Giả sử cần xây dựng ch ương tr ình qu ản lý thí sinh.,LTHDT_PhamVanAt.pdf - Sentence 1179
1180,"Mỗi thí sinh đ ưa vào ba thu ộc tính: Họ t ên,  số báo danh v à tổng điểm.",LTHDT_PhamVanAt.pdf - Sentence 1180
1181,"Ch ương tr ình g ồm ba chức năng: Nhập dữ liệu thí sinh, in dữ liệu thí  sinh ra máy in và xem - in (in h ọ tên ra màn hình, sau đó lựa chọn ho ặc in hoặc không).",LTHDT_PhamVanAt.pdf - Sentence 1181
1182,Ch ương  trình d ưới đây sử dụng lớp TS (Thí sinh) đáp ứng đ ược yêu cầu đặt ra.,LTHDT_PhamVanAt.pdf - Sentence 1182
1183,"//CT6 -02  // Han che phuong thuc tinh   // Lop TS   #include <conio.h>   #include <stdio.h>   #include <iostream.h>   #include <ctype.h>   class TS   {  private:   char ht[25];   int sobd;   float td;   public:   void nhap()   {  cout << "" \nHo ten: "" ;   fflush(stdin); gets(ht);   cout << ""So bao danh: "" ;   cin >> sobd;   cout << ""Tong diem: "" ;   cin >> td;   }  void in()   {  fprintf(stdprn,"" \n\nHo ten: %s"", ht);   fprintf(stdprn,"" \nSo bao danh: %d"", sobd );  fprintf(stdprn,"" \nTong diem: %0.1f"", td);   } Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          221                                         tenshi3003@gmail.com  void xem_in()   {  int ch;   cout << "" \nHo ten: "" << ht ;   cout << "" \nCo in khong?",LTHDT_PhamVanAt.pdf - Sentence 1183
1184,"- C/K"" ;   ch = toupper(getch());   if (ch=='C')   this->in();   }  } ;  void main()   {  TS t[100];   int i, n;   cout << "" \nSo thi sinh: "";   cin >> n;  for (i=1; i<=n; ++i)   t[i].nhap();   for (i=1; i<=n; ++i)   t[i].xem_in();   getch();   }  Giả sử Nh à trường muốn quản lý th êm đ ịa chỉ  của thí sinh.",LTHDT_PhamVanAt.pdf - Sentence 1184
1185,"V ì sự thay đổi ở đây l à không nhi ều,  nên chúng ta không đ ả động đến lớp TS m à xây d ựng lớp mới TS2 dẫn xuất từ lớ p TS.",LTHDT_PhamVanAt.pdf - Sentence 1185
1186,"Trong l ớp  TS2 đưa thêm thu ộc tính dc (địa chỉ) v à các phương th ức nhap, in.",LTHDT_PhamVanAt.pdf - Sentence 1186
1187,"Cụ thể lớp TS2 đ ược định nghĩa  như sau:   class TS2:public TS   {  private:   char dc[30] ; // Dia chi   public:   void nhap()   {  TS::nhap();   cout << ""Dia chi: "" ;   fflush(stdin); gets(dc );  }  void in()   {  TS::in();   fprintf(stdprn,"" \nDia chi: %s"", dc);  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          222                                         tenshi3003@gmail.com  }  };  Trong l ớp TS2 không xây dựng lại ph ương th ức xem_in, m à sẽ dùng phương th ức xem_in của  lớp TS.",LTHDT_PhamVanAt.pdf - Sentence 1187
1188,"Ch ương tr ình m ới nh ư sau:   //CT6 -03  // Han che phuong thuc tinh   // Lop TS TS2   #include <conio .h>  #include <stdio.h>   #include <iostream.h>   #include <ctype.h>   class TS   {  private:   char ht[25];   int sobd;   float td;   public:   void nhap()   {  cout << "" \nHo ten: "" ;   fflush(stdin); gets(ht);   cout << ""So bao danh: "" ;   cin >> sobd;   cout << ""Tong diem: "" ;   cin >>  td;  }  void in()   {  fprintf(stdprn,"" \n\nHo ten: %s"", ht);   fprintf(stdprn,"" \nSo bao danh: %d"", sobd);   fprintf(stdprn,"" \nTong diem: %0.1f"", td);   }  void xem_in()   {  int ch;   cout << "" \nHo ten: "" << ht ;   cout << "" \nCo in khong?",LTHDT_PhamVanAt.pdf - Sentence 1188
1189,"- C/K"" ;   ch = toupper(getch());   if (ch=='C')  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          223                                         tenshi3003@gmail.com  this->in(); //Goi den TS::in() (Vi this la con tro   //kieu TS)   }  } ;  class TS2:public TS   {  private:   char dc[30] ; // Dia chi   public:   void nhap()   {  TS::nhap();   cout << ""Dia chi: "" ;   fflush(stdin); gets(dc);   }  void in()   {  TS::in();   fprintf(stdprn,"" \nDia chi: %s"", dc);   }  };  void main()   {  TS2 t[100];   int i, n;   cout << "" \nSo thi sinh: "";   cin >> n;   for (i=1; i<=n; ++i)   t[i].nhap();   for (i=1; i<=n; ++i)   t[i].xem_in();   getch();   }  Khi th ực hiện ch ương tr ình này, chúng ta nh ận thấy: Dữ liệu in ra vẫn không có địa chỉ.",LTHDT_PhamVanAt.pdf - Sentence 1189
1190,Điều n ày  có th ể giải thích nh ư sau:   Xét câu l ệnh (thứ 2 từ d ưới lên trong hàm main):   t[i].xem_in() ;   Câu l ệnh n ày gọi tới ph ương th ức xem_in của lớp TS2 (v ì t[i] là đối tượng của lớp TS2).,LTHDT_PhamVanAt.pdf - Sentence 1190
1191,"Nh ưng  lớp TS2 không định nghĩa ph ương th ức xem_in, n ên phương th ức TS::xem_in() sẽ đ ược gọi tới.",LTHDT_PhamVanAt.pdf - Sentence 1191
1192,"Hãy theo rõi ph ương th ức này: Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          224                                         tenshi3003@gmail.com  void xem_in()   {  int ch;   cout << "" \nHo ten: "" << ht ;   cout << "" \nCo in khong?",LTHDT_PhamVanAt.pdf - Sentence 1192
1193,"- C/K"" ;   ch = toupper(getch());   if(ch=='C')   this->in(); //Goi den TS::in() (Vi this la con tro kieu TS)   }  Các l ệnh đầu của ph ương th ức sẽ in họ t ên thí sinh.",LTHDT_PhamVanAt.pdf - Sentence 1193
1194,"N ếu chọn có (bấm phím C), th ì  câu l ệnh:  this->in() ;   sẽ được thực hiện.",LTHDT_PhamVanAt.pdf - Sentence 1194
1195,"Mặc d ù địa chỉ của t[i] (l à đối tượng của lớp TS2) đ ược truyền  cho con tr ỏ this,  thế nhưng  câu l ệnh n ày luôn luôn g ọi tới ph ương th ức TS::in(), v ì con tr ỏ this ở đây có kiểu TS v à  vì in() là ph ương th ức tĩnh.",LTHDT_PhamVanAt.pdf - Sentence 1195
1196,Kết quả l à không in đư ợc địa chỉ của thí sinh.,LTHDT_PhamVanAt.pdf - Sentence 1196
1197,Như v ậy việc sử dụng các ph ương th ức tĩnh in() (trong các lớp  TS và TS2) đ ã không đáp ứng  được yêu cầu phát triển ch ương tr ình.,LTHDT_PhamVanAt.pdf - Sentence 1197
1198,Có m ột giải pháp rất đ ơn gi ản là: Định nghĩa các ph ương th ức  in() trong các l ớp TS v à TS2 như các phương th ức ảo (virtual).,LTHDT_PhamVanAt.pdf - Sentence 1198
1199,Bài 3.,LTHDT_PhamVanAt.pdf - Sentence 1199
1200,Phương th ức ảo v à tương ứng bội   3.1.,LTHDT_PhamVanAt.pdf - Sentence 1200
1201,"Cách đ ịnh nghĩa ph ương thức ảo   Giả sử A l à lớp cơ sở, các lớp B, C, D dẫn xuất (trực tiếp hoặc dán tiếp) từ A.",LTHDT_PhamVanAt.pdf - Sentence 1201
1202,"Giả sử trong 4 lớp  trên đ ều có các ph ương th ức trùng dòng tiêu đề (trùng ki ểu, tr ùng tên, trùng các đ ối).",LTHDT_PhamVanAt.pdf - Sentence 1202
1203,"Để định nghĩa  các phương th ức này là các phương th ức ảo, ta chỉ cần:   + Ho ặc th êm từ khoá virtual v ào dòng tiêu đề của ph ương th ức bên trong đ ịnh nghĩa lớp c ơ sở A.",LTHDT_PhamVanAt.pdf - Sentence 1203
1204,"+ Ho ặc th êm từ khoá virtual v ào dòng tiêu đề bên trong đ ịnh nghĩa của  tất cả các lớp A, B, C v à  D.",LTHDT_PhamVanAt.pdf - Sentence 1204
1205,Ví dụ:  Cách 1:   class A   {  ...,LTHDT_PhamVanAt.pdf - Sentence 1205
1206,virtual void  hien_thi( )  {  cout << “ \n Đây là  l ớp A” ;   };  } ;  class B : public A   {  ...,LTHDT_PhamVanAt.pdf - Sentence 1206
1207,void  hien_thi()   { Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          225                                         tenshi3003@gmail.com  cout << “ \n Đây là  l ớp B” ;   };  } ;  class C : public B   {  ...,LTHDT_PhamVanAt.pdf - Sentence 1207
1208,void  hien_thi()   {  cout << “ \n Đây là  l ớp C” ;   };  } ;  class D : public A   {  ...,LTHDT_PhamVanAt.pdf - Sentence 1208
1209,void  hien_thi()   {  cout << “ \n Đây là  l ớp D” ;   };  } ;  Cách 2:   class A   {  ...,LTHDT_PhamVanAt.pdf - Sentence 1209
1210,virtual void  hien_thi()   {  cout << “ \n Đây là  l ớp A” ;   };  } ;  class B : public A   {  ...,LTHDT_PhamVanAt.pdf - Sentence 1210
1211,virtual  void  hien_thi()   {  cout << “ \n Đây là  l ớp B” ;   };  } ;  class C : public B   {  ...,LTHDT_PhamVanAt.pdf - Sentence 1211
1212,virtual void  hien_thi()   {  cout < < “\n Đây là  l ớp C” ;  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          226                                         tenshi3003@gmail.com  };  } ;  class D : public A   {  ...,LTHDT_PhamVanAt.pdf - Sentence 1212
1213,virtual void  hien_thi()   {  cout << “ \n Đây là  l ớp D” ;   };  } ;  Chú ý:   Từ khoá virtual không đ ược đặt b ên ngoài đ ịnh nghĩa lớp.,LTHDT_PhamVanAt.pdf - Sentence 1213
1214,Ví dụ nếu viết nh ư sau là sai  (CTBD s ẽ báo lỗi).,LTHDT_PhamVanAt.pdf - Sentence 1214
1215,class A   {  ...,LTHDT_PhamVanAt.pdf - Sentence 1215
1216,virtual vo id  hien_thi() ;       } ;  virtual void  hien_thi()  // Sai   {  cout << “ \n Đây là  l ớp A” ;   };  Cần sửa lại nh ư sau:   class A   {  ...,LTHDT_PhamVanAt.pdf - Sentence 1216
1217,virtual void  hien_thi() ;       } ;  void  hien_thi()  // Đúng   {  cout << “ \n Đây là  l ớp A” ;   };  3.2.,LTHDT_PhamVanAt.pdf - Sentence 1217
1218,"Quy t ắc gọi ph ương th ức ảo   Để có sự so sánh với ph ương th ức tĩnh, ta nhắc lại quy tắc gọi ph ương th ức tĩnh n êu trong §1.",LTHDT_PhamVanAt.pdf - Sentence 1218
1219,3.2.1.,LTHDT_PhamVanAt.pdf - Sentence 1219
1220,Quy t ắc gọi ph ương th ức tĩnh   Lời gọi tới ph ương th ức tĩnh bao giờ cũng xác định r õ phương th ức nào (trong s ố các ph ương  thức trùng tên c ủa các lớp có quan  hệ thừa kế) đ ược gọi:   1.,LTHDT_PhamVanAt.pdf - Sentence 1220
1221,"Nếu lời gọi xuất phát từ một đối t ượng của lớp n ào,  thì ph ương th ức của lớp đó sẽ đ ược gọi.",LTHDT_PhamVanAt.pdf - Sentence 1221
1222,2.,LTHDT_PhamVanAt.pdf - Sentence 1222
1223,"Nếu lời gọi xuất phát từ một  con trỏ kiểu lớp n ào,  thì ph ương th ức của lớp đó sẽ đ ược gọi bất  kể con trỏ chứa địa chỉ của đối t ượng nào.",LTHDT_PhamVanAt.pdf - Sentence 1223
1224,3.2.2.,LTHDT_PhamVanAt.pdf - Sentence 1224
1225,Quy t ắc gọi ph ương th ức ảo  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          227                                         tenshi3003@gmail.com  Phương th ức ảo chỉ khác ph ương th ức tĩnh khi đ ược gọi từ một con trỏ (tr ường hợp 2 n êu trong  mục 3.2.1).,LTHDT_PhamVanAt.pdf - Sentence 1225
1226,Lời gọi tới ph ương th ức ảo từ một con trỏ ch ưa cho bi ết rõ phương th ức nào (trong s ố  các phương th ức ảo tr ùng t ên của các lớp có quan hệ thừa kế) sẽ đ ược gọi.,LTHDT_PhamVanAt.pdf - Sentence 1226
1227,Điều n ày ph ụ thuộc v ào  đối tượng cụ thể m à con tr ỏ đang trỏ tới: Con trỏ đang trỏ tới đối t ượng của lớp n ào thì ph ương th ức  của lớp đó sẽ đ ược gọi.,LTHDT_PhamVanAt.pdf - Sentence 1227
1228,"Ví dụ A, B, C và D là các l ớp đã định nghĩa trong 3.1.",LTHDT_PhamVanAt.pdf - Sentence 1228
1229,Ta kh ai báo m ột con trỏ kiểu A v à 4 đ ối  tượng:  A  *p ;  //  p là con tr ỏ kiểu A   A   a ;   //  a là bi ến đối t ượng kiểu A   B   b ;   //  b là bi ến đối t ượng kiểu B   C   c ;   //  c là bi ến đối t ượng kiểu C   D   d ;   //  d là bi ến đối t ượng kiểu D   Xét l ời gọi tới c ác phương th ức ảo hien_thi sau:   p = &a;             // p tr ỏ tới đối t ượng a của lớp A   p->hien_thi() ;  // G ọi tới A::hien_thi()    p = &b;             // p tr ỏ tới đối t ượng b của lớp B   p->hien_thi() ;  // G ọi tới B::hien_thi()    p = &c;             // p  trỏ tới đối t ượng c của lớp C   p->hien_thi() ;  // G ọi tới C::hien_thi()    p = &d;             // p tr ỏ tới đối t ượng d của lớp D   p->hien_thi() ;  // G ọi tới D::hien_thi()      3.3.,LTHDT_PhamVanAt.pdf - Sentence 1229
1230,Tương ứng bội   Chúng ta nh ận thấy c ùng m ột câu lệnh   p->hien_thi();   tương ứng với nhiều ph ương th ức khác nhau.,LTHDT_PhamVanAt.pdf - Sentence 1230
1231,Đây chính l à tương ứng bội.,LTHDT_PhamVanAt.pdf - Sentence 1231
1232,"Khả năng n ày rõ ràng  cho phép x ử lý nhiều đối t ượng khác nhau, nhiều công việc, thậm chí nhiều thuật toán khác nhau  theo cùng m ột cách thức, c ùng m ột lược đồ.",LTHDT_PhamVanAt.pdf - Sentence 1232
1233,Điều n ày sẽ được minh hoạ trong các mục tiếp theo.,LTHDT_PhamVanAt.pdf - Sentence 1233
1234,3.4.,LTHDT_PhamVanAt.pdf - Sentence 1234
1235,Liên k ết động   Có th ể so sánh sự khác nhau giữ ph ương th ức tĩnh v à phương th ức ảo tr ên khía c ạnh li ên kết một  lời gọi với một ph ương th ức.,LTHDT_PhamVanAt.pdf - Sentence 1235
1236,"Trở lại ví dụ trong 3.2:   A  *p ;  //  p là con tr ỏ kiểu A   A   a ;   //  a là bi ến đối t ượng kiểu  A  B   b ;   //  b là bi ến đối t ượng kiểu B   C   c ;   //  c là bi ến đối t ượng kiểu C   D   d ;   //  d là bi ến đối t ượng kiểu D   Nếu hien_thi() l à các phương th ức tĩnh, th ì dù p ch ứa địa chỉ của các đối t ượng a, b, c hay d, th ì  lời gọi:   p->hien_thi() ;    luôn luôn g ọi tới ph ương th ức A::hien_thi()   Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          228                                         tenshi3003@gmail.com  Như v ậy một lời gọi (xuất phát từ con trỏ) tới ph ương th ức tĩnh luôn luôn li ên kết với một  phương th ức cố định v à sự liên kết này xác đ ịnh trong quá tr ình biên d ịch ch ương tr ình.",LTHDT_PhamVanAt.pdf - Sentence 1236
1237,"Cũng với lời gọi:   p->hien_thi() ;    như trên, nhưng n ếu hien_thi() l à các phương th ức ảo, th ì lời gọi n ày không liên k ết cứng với một  phương th ức cụ thể n ào.",LTHDT_PhamVanAt.pdf - Sentence 1237
1238,Phương th ức m à nó liên k ết (gọi tới) c òn ch ưa xác đ ịnh trong giai đoạn  dịch ch ương tr ình.,LTHDT_PhamVanAt.pdf - Sentence 1238
1239,"L ời gọi n ày sẽ:  + liên k ết với A::hien_thi( ) , nếu p chứa địa chỉ đối t ượng lớp A   + liên k ết với B::hien_thi() , nếu p chứa địa chỉ đối t ượng lớp B   + liên k ết với C::hien_thi() , nếu p chứa địa chỉ đối t ượng lớp C   + liên k ết với D::hien_thi() , nếu p chứa địa chỉ đối t ượng lớp D   Như v ậy một lời gọi  (xuất phát từ con trỏ) tới ph ương th ức ảo không li ên kết với một ph ương  thức cố định, m à tuỳ thuộc v ào nội dung con trỏ.",LTHDT_PhamVanAt.pdf - Sentence 1239
1240,Đó l à sự liên kết động v à phương th ức được liên  kết (được gọi) thay đổi mỗi khi có sự thay đổi nội dung con trỏ trong quá tr ình ch ạy chương tr ình.,LTHDT_PhamVanAt.pdf - Sentence 1240
1241,3.5.,LTHDT_PhamVanAt.pdf - Sentence 1241
1242,"Quy t ắc gán địa chỉ đối t ượng cho con trỏ lớp c ơ sở  + Như đ ã nói trong §1, C++ cho phép gán đ ịa chỉ đối t ượng của một lớp dẫn xuất cho con trỏ  của lớp c ơ sở.",LTHDT_PhamVanAt.pdf - Sentence 1242
1243,"Nh ư vậy các phép gán sau (xem 3.2) l à đúng:   A  *p ;  //  p là con tr ỏ kiểu A   A   a ;   //  a là bi ến đối t ượng kiểu A   B   b ;   //  b là bi ến đối t ượng kiểu B   C   c ;   //  c là bi ến đối t ượng kiểu C   D   d ;   //  d là bi ến đối t ượng kiểu D   p = &a;    // p và a cùng l ớp A   p = &b;   // p là con tr ỏ lớp c ơ sở, b l à đối tượng lớp dẫn x uất   p = &c;   // p là con tr ỏ lớp c ơ sở, c l à đối tượng lớp dẫn xuất   p = &d;   // p là con tr ỏ lớp c ơ sở, d l à đối tượng lớp dẫn xuất   + Tuy nhiên c ần chú ý l à: Không cho phép gán đ ịa chỉ đối t ượng của lớp cở sở cho con trỏ của  lớp dẫn xuất.",LTHDT_PhamVanAt.pdf - Sentence 1243
1244,Nh ư vậy ví d ụ sau l à sai:   B  *q ;   A  a ;   q = &a;   Sai vì:  Gán địa chỉ đối t ượng của lớp c ơ sở A cho con trỏ của lớp dẫn xuất B   3.6.,LTHDT_PhamVanAt.pdf - Sentence 1244
1245,Ví d ụ  Ta sửa ch ương tr ình trong bài 1 bằng cách định nghĩa các ph ương th ức xuat() l à ảo.,LTHDT_PhamVanAt.pdf - Sentence 1245
1246,"Khi đó bốn  câu l ệnh:  hien(&a);   hien(&b);   hien(& c);  hien(&d);   trong hàm main (c ủa ch ương tr ình d ưới đây) sẽ lần l ượt gọi tới 4 ph ương th ức khác nhau:   A::xuat()   B::xuat()  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          229                                         tenshi3003@gmail.com  C::xuat()   D::xuat()   //CT6 -01B  // Phuong thuc ảo và tương ứng bội   #include <conio.h>   #include <stdio.h>   #include <iostream.h>   #include <ctype.h>   class A   {  private:   int n;   public:   A()  {  n=0;   }  A(int n1)   {  n=n1;   }  virtual void xuat()   {  cout << "" \nLop A: ""<< n;   }  int getN()   {  return n;   }  };  class B:public A   {  public:   B():A()   {  }  B(int n1):A(n1)   {  }  void xuat()   { Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          230                                         tenshi3003@gmail.com  cout << "" \nLop B: ""<<getN();   }  };  class C:public A   {  public:   C():A()   {  }  C(int n1):A(n1)   {  }  void xuat()   {  cout << "" \nLop C: ""<<getN();   }  };  class D:public C   {  public:   D():C()   {  }  D(int n1):C(n1)   {  }  void xuat()   {  cout << "" \nLop D: ""<<getN();   }  };  void hien(A *p)   {  p->xuat();   }  void m ain()   {  A a(1);   B b(2);   C c(3);   D d(4);   clrscr();  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          231                                         tenshi3003@gmail.com  hien(&a);   hien(&b);   hien(&c);   hien(&d);   getch();   }  3.5.",LTHDT_PhamVanAt.pdf - Sentence 1246
1247,"S ự thừa kế của các ph ương th ức ảo   Cũng giống nh ư các phương th ức thông th ường khác, ph ương th ức ảo cũng có tính thừa kế.",LTHDT_PhamVanAt.pdf - Sentence 1247
1248,"Chẳng hạn trong ch ương tr ình trên (m ục 3.4) ta bỏ đi ph ương th ức xuat() của lớp D, th ì câu l ệnh:  hien(&d) ;   (câu l ệnh gần cuối trong h àm main) s ẽ gọi tới C::xuat() , ph ương th ức này đư ợc kế thừa trong lớp D  (vì D d ẫn xuất từ C).",LTHDT_PhamVanAt.pdf - Sentence 1248
1249,Bài 4.,LTHDT_PhamVanAt.pdf - Sentence 1249
1250,"Sự linh hoạt của ph ương th ức ảo trong phát triển nâng c ấp ch ương tr ình  Ví dụ về các lớp TS v à TS2 trong §2 đã chỉ ra sự hạn chế của ph ương th ức tĩnh trong việc sử  dụng tính thừa kế để nâng cấp, phát triển ch ương tr ình.",LTHDT_PhamVanAt.pdf - Sentence 1250
1251,Trong §2 cũng đ ã chỉ ra lớp TS2 ch ưa đáp  ứng đ ược yêu cầu nêu ra là in đ ịa chỉ của thí  sinh.,LTHDT_PhamVanAt.pdf - Sentence 1251
1252,Gi ải pháp cho vấn đề n ày rất đơn gi ản: Thay các  phương th ức tĩnh in() bằng cách d ùng chúng như các phương th ức ảo.,LTHDT_PhamVanAt.pdf - Sentence 1252
1253,"Ch ương tr ình khi đó sẽ như  sau:  //CT6 -03B  // Sự linh hoạt của ph ương th ức ảo   // Lop TS TS2   #include <conio.h>   #include <stdio.h>   #incl ude <iostream.h>   #include <ctype.h>   class TS   {  private:   char ht[25];   int sobd;   float td;   public:   void nhap()   {  cout << "" \nHo ten: "" ;   fflush(stdin); gets(ht);   cout << ""So bao danh: "" ;   cin >> sobd;   cout << ""Tong diem: "" ;   cin >> td;  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          232                                         tenshi3003@gmail.com  }  virtual  void in()   {  fprintf(stdprn,"" \n\nHo ten: %s"", ht);   fprintf(stdprn,"" \nSo bao danh: %d"", sobd);   fprintf(stdprn,"" \nTong diem: %0.1f"", td);   }  void xem_in()   {  int ch;   cout << "" \nHo ten: "" << ht ;   cout << "" \nCo in khong?",LTHDT_PhamVanAt.pdf - Sentence 1253
1254,"- C/K"" ;   ch = toupper(getch());   if (ch=='C')   this->in(); // Vì in() là ph ương th ức ảo n ên   //có th ể gọi đến  TS::in() hoặc TS2::in()   }  } ;  class TS2:public TS   {  private:   char dc[30] ; // Dia chi   public:   void nhap()   {  TS::nhap();   cout << ""Dia chi: "" ;   fflush(stdin); gets(dc);   }  void in()   {  TS::in();   fprintf(st dprn,"" \nDia chi: %s"", dc);   }  };  void main()   {  TS2 t[100];   int i, n;   cout << "" \nSo thi sinh: "";   cin >> n;   for (i=1; i<=n; ++i)  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          233                                         tenshi3003@gmail.com  t[i].nhap();   for (i=1; i<=n; ++i)          t[i].xem_in();   getch();   }  Khi th ực hiện ch ương tr ình này, chúng ta nh ận thấy: Dữ liệu thí  sinh in ra đ ã có địa chỉ.",LTHDT_PhamVanAt.pdf - Sentence 1254
1255,Điều n ày  có th ể giải thích nh ư sau:   Xét câu l ệnh (thứ 2 từ d ưới lên trong hàm main):   t[i].xem_in() ;   Câu l ệnh n ày gọi tới ph ương th ức xem_in của lớp TS2 (v ì t[i] là đối tượng của lớp TS2).,LTHDT_PhamVanAt.pdf - Sentence 1255
1256,"Nh ưng  lớp TS2 không định nghĩa ph ương th ức xem_in, n ên phương th ức TS::xem_in() sẽ đ ược gọi tới.",LTHDT_PhamVanAt.pdf - Sentence 1256
1257,"Hãy theo rõi ph ương th ức này:  void xem_in()   {  int ch;   cout << "" \nHo ten: "" << ht ;   cout << "" \nCo in khong?",LTHDT_PhamVanAt.pdf - Sentence 1257
1258,"- C/K"" ;   ch = toupper(getch());   this->in(); // Vì in() là ph ương th ức ảo n ên                   //có th ể gọi đến  TS::in() hoặc TS2::in()   }  Các l ệnh đầu của ph ương th ức sẽ in họ t ên thí sinh.",LTHDT_PhamVanAt.pdf - Sentence 1258
1259,"N ếu chọn Có (bấm phím C), th ì  câu l ệnh:  this->in() ;   sẽ được thực hiện.",LTHDT_PhamVanAt.pdf - Sentence 1259
1260,Địa chỉ của t[i] (l à đối tượng của lớp TS2) đ ược truyền cho con trỏ this (của lớp  cơ sở TS).,LTHDT_PhamVanAt.pdf - Sentence 1260
1261,"V ì in() là ph ương th ức ảo v à vì this đang tr ỏ tới đối t ượng t[i] của lớp TS2, n ên câu l ệnh  này  g ọi tới ph ương th ức TS2::in().",LTHDT_PhamVanAt.pdf - Sentence 1261
1262,Trong ph ương th ức TS2::in() có in địa chỉ của thí sinh.,LTHDT_PhamVanAt.pdf - Sentence 1262
1263,Như v ậy việc sử dụng các ph ương th ức tĩnh in() (trong các lớp TS và TS2) đ ã không đáp ứng đ ược  yêu c ầu phát triển ch ương tr ình.,LTHDT_PhamVanAt.pdf - Sentence 1263
1264,Có m ột giải pháp rất đ ơn gi ản là: Định nghĩa các ph ương th ức in()  trong các l ớp TS v à TS2 như các phương th ức ảo (virtual).,LTHDT_PhamVanAt.pdf - Sentence 1264
1265,Bài 5.,LTHDT_PhamVanAt.pdf - Sentence 1265
1266,Lớp cơ sở trừu t ượng  5.1.,LTHDT_PhamVanAt.pdf - Sentence 1266
1267,L ớp cơ sở trừu t ượng   Một lớp c ơ sở trừu tượng l à một lớp chỉ đ ược dùng làm cơ s ở cho các lớp khác.,LTHDT_PhamVanAt.pdf - Sentence 1267
1268,"Không hề có  đối tượng n ào của một lớp trừu t ượng đ ược tạo ra cả, bởi v ì nó ch ỉ được dùng đ ể định nghĩa một số  khái ni ệm tổng quát, chung cho các lớp khác.",LTHDT_PhamVanAt.pdf - Sentence 1268
1269,"Một ví dụ về lớp trừu t ượng l à lớp CO N_VAT (con  vật), nó sẽ d ùng làm cơ s ở để xây dựng các lớp con vật cụ thể nh ư lớp CON_CHO (con chó),  CON_MEO (con mèo),...",LTHDT_PhamVanAt.pdf - Sentence 1269
1270,"(xem ví d ụ bên dư ới)  Trong C++ , thu ật ngữ “Lớp trừu t ượng” đặc biệt áp dụng cho các lớp có chứa các ph ương th ức  ảo thuần tuý.",LTHDT_PhamVanAt.pdf - Sentence 1270
1271,Ph ương thức ảo thuần tuý l à một ph ương th ức ảo m à nội dung của nó không có g ì.,LTHDT_PhamVanAt.pdf - Sentence 1271
1272,"Cách th ức định nghĩa một ph ương th ức ảo thuần tuý nh ư sau:   virtual  void  tên_phương_th ức() = 0 ;   Ví dụ:  class A  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          234                                         tenshi3003@gmail.com  {  public:   virtual void  nhap() = 0 ;   virtual void  xuat() = 0 ;   void  c huong();   } ;  Trong ví d ụ trên, thì A là l ớp cơ sở trừu t ượng.",LTHDT_PhamVanAt.pdf - Sentence 1272
1273,Các ph ương th ức nhap v à xuat đư ợc khai báo l à  các l ớp ảo thuần tuý (bằng cách gán số 0 cho chúng thay cho việc c ài đặt các ph ương th ức này).,LTHDT_PhamVanAt.pdf - Sentence 1273
1274,Phương th ức chuong() l à một ph ương th ức bình th ường v à sẽ phải có một định nghĩa ở đâu đó cho  phương th ức này.,LTHDT_PhamVanAt.pdf - Sentence 1274
1275,Không có đ ối tượng n ào của một lớp trừu t ượng lại có thể đ ược phát sinh.,LTHDT_PhamVanAt.pdf - Sentence 1275
1276,Tuy nhi ên các con tr ỏ  và các bi ến tham chiếu đến các đối t ượng của lớp trừu t ượng th ì vẫn hợp lệ.,LTHDT_PhamVanAt.pdf - Sentence 1276
1277,"Bất kỳ lớp n ào dẫn xuất  từ một lớp cớ sở trừu t ượng phải định nghĩa lại tất cả các ph ương th ức thuần ảo m à nó th ừa hưởng,  hoặc bằng các ph ương th ức ảo thuần tuý, hoặc bằng những định nghĩa thực sự.",LTHDT_PhamVanAt.pdf - Sentence 1277
1278,"Ví dụ:   class B : public A   {  public:   virtual void  nhap() = 0 ;   virtual void  xuat()   {  // Các câu l ệnh  }  } ;  Theo ý ngh ĩa về h ướng đối t ượng, ta vẫn có thể có một lớp trừu t ượng m à không nh ất thiết phải  chứa đựng những ph ương th ức thuần tuý ảo.",LTHDT_PhamVanAt.pdf - Sentence 1278
1279,Một cách tổng quát m à nói thì b ất kỳ lớp n ào mà nó ch ỉ được dùng làm cơ s ở cho những lớp  khác đ ều có thể đ ược gọi l à “lớp trừu t ượng”.,LTHDT_PhamVanAt.pdf - Sentence 1279
1280,Một cách dễ d àng đ ể nhận biết một lớp trừu t ượng l à  xem có dùng l ớp đó để khai báo các đối t ượng hay không?,LTHDT_PhamVanAt.pdf - Sentence 1280
1281,.,LTHDT_PhamVanAt.pdf - Sentence 1281
1282,Nếu không th ì đó là l ớp cơ sở trừu  tượng.,LTHDT_PhamVanAt.pdf - Sentence 1282
1283,5.2.,LTHDT_PhamVanAt.pdf - Sentence 1283
1284,"Ví d ụ  Giả sử có 20 ô, mỗi ô có thể nuôi một con chó hoặc mộ t con mèo.",LTHDT_PhamVanAt.pdf - Sentence 1284
1285,"Yêu c ầu xây dựng ch ương  trình g ồm các chức năng:   + Nh ập một con vật mới mua (hoặc chó, hoặc m èo) vào ô r ỗng đầu ti ên.",LTHDT_PhamVanAt.pdf - Sentence 1285
1286,"+ Xu ất (đem bán) một con vật (hoặc chó, hoặc m èo).",LTHDT_PhamVanAt.pdf - Sentence 1286
1287,+ Th ống k ê các con v ật đang nuôi trong 20 ô.,LTHDT_PhamVanAt.pdf - Sentence 1287
1288,Chương tr ình được tổ chức nh ư sau:  + Trư ớc tiên định nghĩa lớp CON_VAT l à lớp cơ sở ảo.,LTHDT_PhamVanAt.pdf - Sentence 1288
1289,Lớp n ày có m ột thuộc tính l à tên con v ật  và m ột ph ương th ức ảo d ùng đ ể xưng tên.,LTHDT_PhamVanAt.pdf - Sentence 1289
1290,+ Hai l ớp là CON_MEO và CON_CHO đư ợc dẫn xuất từ lớp CON_VAT   + Cu ối cùng là l ớp DS_CON_VAT (Danh sách con vật) d ùng đ ể quản lý chung cả m èo và chó.,LTHDT_PhamVanAt.pdf - Sentence 1290
1291,"Lớp này có 3 thu ộc tính l à: số con vật cực đại (chính bằng số ô), số con vật đang nuôi v à một mảng  con tr ỏ kiểu CON_VAT.",LTHDT_PhamVanAt.pdf - Sentence 1291
1292,Mỗi phần tử mảng sẽ chứa địa chỉ của một đối t ượng kiểu CON_MEO  hoặc CON_CHO.,LTHDT_PhamVanAt.pdf - Sentence 1292
1293,Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          235                                         tenshi3003@gmail.com  Lớp sẽ có 3 ph ương th ức để thực hiện 3 chức năng n êu trên c ủa ch ương tr ình.,LTHDT_PhamVanAt.pdf - Sentence 1293
1294,"N ội dung ch ương  trình nh ư sau:   //CT6 -04  // Lop co so truu tuong   // Lop CON_VAT   #include <conio.h>   #include <stdio.h>   #include <iostream.h>   #include <ctype.h>   #include <string.h>   class CON_VAT   {  protected:   char *ten;   public:   CON_VAT()   {  ten = NULL;   }  CON_VAT(char *ten1)   {  ten = strdup(ten1);   }  virtual void xung_ten()   {  }  } ;  class CON_MEO:public CON_VAT   {  public:   CON_MEO() : CON_VAT()   {  }  CON_MEO(char *ten1) : CON_VAT(ten1)   {  }  virtual void xung_ten()   {  cout < < ""\nToi la chu meo: "" << ten ;   }  }; Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          236                                         tenshi3003@gmail.com  class CON_CHO:public CON_VAT   {  public:   CON_CHO() : CON_VAT()   {  }  CON_CHO(char *ten1) : CON_VAT(ten1)   {  }  virtual void xung_ten()   {  cout << "" \nToi la chu cho: "" << ten ;   }  };  class DS_CON_VAT // Danh sach con vat   {  priva te:  int max_so_con_vat;   int so_con_vat;   CON_VAT **h ;   public:   DS_CON_VAT(int max);   ~DS_CON_VAT();   int nhap(CON_VAT *c);   CON_VAT* xuat(int n);   void thong_ke();   } ;  DS_CON_VAT::DS_CON_VAT(int max)   {  max_so_con_vat = max;   so_con_vat = 0;   h = new CON_VAT*[max] ;  for (int i=0; i<max; ++i)   h[i] = NULL;   }  DS_CON_VAT::~DS_CON_VAT()   {  max_so_con_vat = 0;   so_con_vat = 0;   delete h;  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          237                                         tenshi3003@gmail.com  }  int DS_CON_VAT::nhap(CON_VAT *c)   {  if (so_con_vat==max_so_con_vat)   return 0;   int i=0;   while (h[i]!=NULL) ++i;   h[i]=c;   so_con_vat++ ;   return (i+1);   }  CON_VAT* DS_CON_VAT::xuat(int n)   {  if (n<1 || n > max_so_con_vat)   return NULL ;   --n ;  if (h[n])   {  CON_VAT *c = h[n];   h[n]=NULL;   so_con_vat -- ;  return c;   }  else  return NULL;   }  void DS_CON_VAT::thong_ke()   {  if (so_con_vat)   {  cout << "" \n"" ;  for (i nt i=0; i<max_so_con_vat; ++i)   if (h[i])   h[i]->xung_ten();   }  }  CON_CHO  c1(""MUC"");   CON_CHO  c2(""VEN"");   CON_CHO  c3(""LAI"");   CON_CHO  c4(""NHAT"");   CON_CHO  c5(""BONG"");  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          238                                         tenshi3003@gmail.com  CON_MEO  m1(""MUOP"");   CON_MEO  m2(""DEN"");   CON_MEO  m3(""TRANG"");   CON_MEO  m4(""TAM THE"");   CON_ MEO  m5(""VANG"");   void main()   {  DS_CON_VAT d(20);   clrscr();   d.nhap(&c1);   int im2 = d.nhap(&m2);   d.nhap(&c3);   d.nhap(&m1);   int ic4 = d.nhap(&c4);   d.nhap(&c5);   d.nhap(&m5);   d.nhap(&c2);   d.nhap(&m3);   d.thong_ke();   d.xuat(im2);   d.xuat(ic4);   d.thong_ke();   getch( );  }  Chú ý:  Theo quan đi ểm chung về cách thức sử dụng, th ì lớp CON_VAT l à lớp cơ sở trừu t ượng.",LTHDT_PhamVanAt.pdf - Sentence 1294
1295,"Tuy nhiên theo quan đi ểm của C++ th ì lớp n ày chưa ph ải là lớp cơ sở trừu t ượng, v ì trong l ớp  không có các phương th ức thuần tuý ảo.",LTHDT_PhamVanAt.pdf - Sentence 1295
1296,"Ph ương th ức xung_ten:   virtu al void xung_ten()   {  }  là phương th ức ảo, đ ược định nghĩa đầy đủ , mặc d ù thân c ủa nó l à rỗng.",LTHDT_PhamVanAt.pdf - Sentence 1296
1297,Do v ậy khai báo:   CON_VAT   cv(“Con vat chung”);   vẫn được C++ chấp nhận.,LTHDT_PhamVanAt.pdf - Sentence 1297
1298,Bây gi ờ nếu định nghĩa lại ph ương th ức xung_ten nh ư sau:   virtual void xung_ten() = 0 ;   thì nó tr ở thành phương th ức thuần ảo v à C++ s ẽ quan niệm lớp CON_VAT l à lớp trừu t ượng.,LTHDT_PhamVanAt.pdf - Sentence 1298
1299,Khi  đó câu l ệnh khai báo:   CON_VAT   cv(“Con vat chung”);   sẽ bị C++ bắt lỗi với thông báo:   Cannot  create instance of abstruct class ‘CON_VAT’  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          239                                         tenshi3003@gmail.com  Bài 6.,LTHDT_PhamVanAt.pdf - Sentence 1299
1300,Sử dụng t ương ứng bội và phương th ức ảo   6.1.,LTHDT_PhamVanAt.pdf - Sentence 1300
1301,"Chi ến lược sử dụng t ương ứng bội   Tương ứng bội cho phép xét các vấn đề khác nhau, các đối t ượng khác nhau, các ph ương pháp  khác nhau, các cách gi ải quyết khác nhau theo c ùng m ột lược đồ chung.",LTHDT_PhamVanAt.pdf - Sentence 1301
1302,Các bư ớc áp dụng t ương ứng bội có t hể tổng kết lại nh ư sau:   1.,LTHDT_PhamVanAt.pdf - Sentence 1302
1303,Xây d ựng lớp c ơ sở trừu t ượng bao gồm những thuộc tính chung nhất của các thực thể cần  quản lý.,LTHDT_PhamVanAt.pdf - Sentence 1303
1304,Đ ưa vào các phương th ức ảo hay thuần ảo d ùng đ ể xây dựng các nhóm ph ương th ức ảo cho  các l ớp dẫn xuất sau n ày.,LTHDT_PhamVanAt.pdf - Sentence 1304
1305,M ỗi nhóm ph ương th ức ảo sẽ thực hiện một chức năng n ào đó trên các  lớp.,LTHDT_PhamVanAt.pdf - Sentence 1305
1306,2.,LTHDT_PhamVanAt.pdf - Sentence 1306
1307,Xây d ựng các lớp dẫn xuất bắt đầu từ lớp c ơ sở ảo.,LTHDT_PhamVanAt.pdf - Sentence 1307
1308,Số mức dẫn xuất l à không h ạn chế.,LTHDT_PhamVanAt.pdf - Sentence 1308
1309,Các  lớp dẫn xuất sẽ mô tả các đối t ượng cụ thể cần quản lý.,LTHDT_PhamVanAt.pdf - Sentence 1309
1310,3.,LTHDT_PhamVanAt.pdf - Sentence 1310
1311,Xây d ựng các ph ương th ức ảo trong các dẫn xuất.,LTHDT_PhamVanAt.pdf - Sentence 1311
1312,Các ph ương th ức này tạo th ành các nhóm  phương th ức ảo trong s ơ đồ các lớp có quan hệ thừa kế.,LTHDT_PhamVanAt.pdf - Sentence 1312
1313,4.,LTHDT_PhamVanAt.pdf - Sentence 1313
1314,Xây d ựng lớp quản lý các đối t ượng.,LTHDT_PhamVanAt.pdf - Sentence 1314
1315,Dữ liệu của lớp n ày là m ột dẫy con trỏ của lớp c ơ sở trừu  tượng ban đầu.,LTHDT_PhamVanAt.pdf - Sentence 1315
1316,Các con trỏ n ày có th ể chứa địa chỉ đối t ượng của các lớ p dẫn xuất.,LTHDT_PhamVanAt.pdf - Sentence 1316
1317,Do vậy  có thể  dùng các con tr ỏ này để thực hiện các thao tác tr ên các đ ối tượng của bất kỳ lớp dẫn xuất n ào.,LTHDT_PhamVanAt.pdf - Sentence 1317
1318,6.2.,LTHDT_PhamVanAt.pdf - Sentence 1318
1319,Ví d ụ  Chương tr ình qu ản lý các con vật trong §5 là m ột ví dụ về cách sử dụng t ương ứng bội.,LTHDT_PhamVanAt.pdf - Sentence 1319
1320,D ưới  đây là m ột ví dụ khác.,LTHDT_PhamVanAt.pdf - Sentence 1320
1321,"Giả sử có  4 hình v ẽ: Đoạn  thẳng, h ình tròn, hình ch ữ nhật v à hình vuông.",LTHDT_PhamVanAt.pdf - Sentence 1321
1322,Bốn hình cho hi ện thẳng h àng trên màn hình t ạo th ành m ột bức tranh.,LTHDT_PhamVanAt.pdf - Sentence 1322
1323,Nếu thay đổi thứ tự các h ình  sẽ nhận đ ược các bức tranh khác nhau.,LTHDT_PhamVanAt.pdf - Sentence 1323
1324,Ch ương tr ình d ưới đây sẽ cho hiện tất cả các bức tranh k hác  nhau.,LTHDT_PhamVanAt.pdf - Sentence 1324
1325,"Chương tr ình được tổ chức theo các b ước nêu trong 6.1:   + Lớp cơ sở trừu t ượng l à lớp HINH (h ình) g ồm một thuộc tính mau (mầu) v à một ph ương th ức  ảo thuần tuý:   virtual void draw(int x, int y) = 0 ;   + Các l ớp dẫn xuất trực tiếp từ lớp h ình là : DTH ANG , HTRON và CHUNHAT.",LTHDT_PhamVanAt.pdf - Sentence 1325
1326,+ Lớp VUONG dẫn xuất từ lớp CHUNHAT.,LTHDT_PhamVanAt.pdf - Sentence 1326
1327,"+ Lớp quản lý chung l à lớp picture có thuộc tính l à một mảng con trỏ kiểu HINH gồm 4 phần tử  dùng đ ể chứa địa chỉ 4 đối t ượng: DTHANG, HTRON, CHUNHAT v à VUONG.",LTHDT_PhamVanAt.pdf - Sentence 1327
1328,S ử dụng ph ương  thức draw gọi từ 4 p hần tử mảng nói tr ên sẽ nhận đ ược một bức tranh.,LTHDT_PhamVanAt.pdf - Sentence 1328
1329,"Bằng cách hoán vị các phần  tử này, sẽ nhận đ ược tất cả các bức tranh khác nhau.",LTHDT_PhamVanAt.pdf - Sentence 1329
1330,"//CT6 -05  // Lop co so truu tuong   // Lop hinh hoc   #include <conio.h>   #include <graphics.h>   class HINH   {  private:   int mau;   public :  HINH(int m)   {  mau = m;  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          240                                         tenshi3003@gmail.com  }  getmau()   {  return mau;   }  virtual void draw(int x, int y) = 0;   };  class DTHANG : public HINH   {  private:   int  dodai;   public:   DTHANG(int d, int m):HINH(m)   {  dodai = d ;   }  virtual void draw(int x, int y)   {  setcolor(getmau()) ;   line(x ,y,x+dodai,y);   }  };  class CHUNHAT: public HINH   {  private:   int rong, cao;   public:   CHUNHAT(int r, int c, int m):HINH(m)   {  rong = r; cao = c;   }  virtual void draw(int x, int y )   {  setcolor(getmau()) ;   rectangle(x,y,x+rong,y+cao);   setfillstyle(1,getmau());   floodfill(x+rong/2,y+cao/2, getmau() );   }  };  class VUONG : public CHUNHAT   { Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          241                                         tenshi3003@gmail.com  public:   VUONG(int a, int m): CHUNHAT(a,a,m)   {  }  };  class HTRON: public HINH   {  private:   int bk; //Ban kinh   public:   HTRON(int bk1, int m):HINH(m)   {  bk = bk1;   }  virtual void draw(int x, i nt y)  {  setcolor(getmau()) ;   circle(x+bk,y+bk,bk);   setfillstyle(1,getmau());   floodfill(x + bk, y + bk,getmau());   }  };  class picture   {  private:   HINH *h[4];   public:   picture(HINH *h0,HINH *h1,HINH *h2,HINH *h3)   {  h[0]=h0;   h[1]=h1;   h[2]=h2;   h[3]=h3;   }  void pai nt(int *k);   void listpaint();   } ;  void picture::paint(int *k)   {  for (int i=0; i<4; ++i)   h[k[i]] ->draw(10+i*150, 200);   } Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          242                                         tenshi3003@gmail.com  void picture::listpaint()   {  int k[4],i1,i2,i3,i4;   for (i1=0;i1<4;++i1)   for (i2=0;i2<4;++i2)   if (i2!=i1)   for (i3=0;i3<4;++i3)   if (i3!=i2 && i3!=i1)   for (i4=0;i4<4;++i4)   if (i4!=i3 && i4!=i2 && i4!=i1)   {  k[0]=i1;k[1]=i2;   k[2]=i3;k[3]=i4;   paint(k);   getch();   cleardevice();   }  }  DTHANG dt(120,14);   HTRON ht(60,RED);   CHUNHAT cn(120,100,MAGENTA);   VUONG v(120,CYAN);   } ;  void main()   {  int mh=0,mode=0 ;  initgraph(&mh,&mode,"""");   picture pic(&dt,&ht,&cn,&v);   pic.listpaint();   getch();   closegraph();   }  Bài 7.",LTHDT_PhamVanAt.pdf - Sentence 1330
1331,Xử lý các thuật toán khác nhau   Có th ể sử dụng t ương ứng bội để tổ chức thực hiện các thuật toán khác nhau tr ên cùng m ột bài  toán như sau:   + Lớp cơ sở trừu tượng sẽ chứa dữ liệu b ài toán và m ột ph ương th ức ảo.,LTHDT_PhamVanAt.pdf - Sentence 1331
1332,+ Mỗi lớp dẫn xuất ứng với một thuật toán cụ thể.,LTHDT_PhamVanAt.pdf - Sentence 1332
1333,Ph ương th ức ảo của lớp dẫn xuất sẽ thực hiện  một thuật toán cụ thể.,LTHDT_PhamVanAt.pdf - Sentence 1333
1334,Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          243                                         tenshi3003@gmail.com  + Sử dụng một mảng con trỏ của lớp c ơ sở và gán cho m ỗi phần tử mảng  địa chỉ c ủa  một đối  tượng của lớp dẫn xuất.,LTHDT_PhamVanAt.pdf - Sentence 1334
1335,Sau đó d ùng các ph ần tử mảng con trỏ để gọi tới các ph ương th ức ảo.,LTHDT_PhamVanAt.pdf - Sentence 1335
1336,Bằng  cách đó s ẽ thực hiện c ùng m ột bài toán theo các thu ật toán khác nhau v à dễ dàng so sánh hiê ụ quả  của các thuật toán.,LTHDT_PhamVanAt.pdf - Sentence 1336
1337,"Ví dụ sau minh hoạ việc thực h iện bài toán s ắp xếp dẫy số nguy ên theo th ứ tự tăng bằng cách  dùng đ ồng thời 3 thuật toán: Thuật toán lựa chọn (Select_Sort), thuật toán sắp xếp nhanh  (Quick_Sort) và thu ật toán vun đống (Heap_Sort).",LTHDT_PhamVanAt.pdf - Sentence 1337
1338,"Ch ương tr ình g ồm 4 lớp:   + Lớp cơ sở trừu t ượng:  class so rt  {  protected:   int *a;   void hoan_vi(long i, long j) ;     public:   virtual void sapxep(int *a1, long n) ;   } ;  Lớp này gồm:  - Một thành ph ần dữ liệu l à con tr ỏ a trỏ tới một v ùng nh ớ chứa dẫy số nguy ên cần sắp xếp.",LTHDT_PhamVanAt.pdf - Sentence 1338
1339,"- Phương th ức hoan_vi(i,j) d ùng đ ể hoán vị c ác ph ần tử a[i] v à a[j].",LTHDT_PhamVanAt.pdf - Sentence 1339
1340,Phương th ức này đư ợc dùng  trong 3 l ớp dẫn xuất b ên dư ới.,LTHDT_PhamVanAt.pdf - Sentence 1340
1341,"- Phương th ức ảo sapxep(a1,n) d ùng đ ể sắp xếp dẫy n số nguy ên ch ứa trong mảng a1.",LTHDT_PhamVanAt.pdf - Sentence 1341
1342,"+ Ba l ớp dẫn xuất l à: SELECT_SORT, QUICK_SORT và HEAP_SORT.",LTHDT_PhamVanAt.pdf - Sentence 1342
1343,"M ỗi lớp đều có  phương th ức ảo:   virtual void sapxep(int *a1, long n) ;   để thực hiện hiện việc sắp xếp theo theo một thuật toán cụ thể.",LTHDT_PhamVanAt.pdf - Sentence 1343
1344,"+ Trong hàm main() s ẽ tạo ra một dẫy 30000 số nguy ên m ột cách ngẫu nhi ên, sau đó l ần lượt sử  dụng 3 thuật toán sắp xếp để so sánh.",LTHDT_PhamVanAt.pdf - Sentence 1344
1345,"Kết quả nh ư sau:   Thời gian sắp xếp theo thuật toán Select sort l à: 19.20 giây   Thời gian sắp xếp theo thuật toán Quick sort l à: 0.11 giây   Thời gian sắp xếp theo thuật toán  Heap  sort l à: 0.44 giây   Nội dung ch ương tr ình nh ư sau:   //CT6 -06  // Lop co so truu tuong   // Lop sort   #inclu de <conio.h>   #include <stdio.h>   #include <time.h>   #include <stdlib.h>   #include <iostream.h>   #include <dos.h>   class sort   {  protected:  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          244                                         tenshi3003@gmail.com  int *a;   void hoan_vi(long i, long j)   {  int tg = a[i];   a[i] = a[j];   a[j] = tg;   }  public:   virtual void sapxep(int *a1, long n )  {  a = a1;   }  } ;  class select_sort : public sort   {  public:   virtual void sapxep(int *a1, long n) ;   } ;  void select_sort::sapxep(int *a1, long n)   {  long i,j,r;   sort::sapxep(a1,n);   for (i=1; i<n; ++i)   {  r=i;  for (j=i+1; j<=n; ++j)   if(a[j] < a[r]) r = j;   if(r!=i) hoan_vi(i,r);   }  }  class quick_sort : public sort   {  private:   void q_sort(long l, long r);   public:   virtual void sapxep(int *a1, long n) ;   } ;  void quick_sort::q_sort(long l, long r)   {  int x;   long i,j;  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          245                                         tenshi3003@gmail.com  if (l < r)   {  x = a[l]; i = l; j = r+1;   do  {  ++i;  --j;  while (i<r && a[i] < x) ++i ;   while (a[j] > x) --j ;  if (i<j) hoan_vi(i,j);   } while (i<j);   hoan_vi(l,j);   q_sort(l,j -1);  q_sort(j+1,r);   }  }  void quick_sort::sapxep(int *a1, long n)   {  sort::sapxep(a1,n);   q_sort(1,n);   }  class heap_sort : public sort   {  private:  void shift(long i, long n);   public:   virtual void sapxep(int *a1, long n) ;   } ;  void heap_sort::shift(long i, long n)   {  long l,r,k;   l = 2*i; r = l+1;   if (l>n) return;   if (l==n)   {  if (a[i]<a[l]) hoan_vi(i,l);   return;   }  if (a[l] > a[r])   k = l;   else  k = r ; Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          246                                         tenshi3003@gmail.com  if (a[i]>=a[k])   return;   else  {  hoan_vi(i,k);   shift(k,n);   }  }  void heap_sort::sapxep(int *a1, long n)   {  long i;   sort::sapxep(a1,n);   /* Tao dong */   for (i=n/2 ; i>=1; --i) shift(i,n);   /* Lap */   for (i=n ; i>=2; --i)  {  hoan_vi(1,i);   shift(1,i -1);  }  }  void m ain()   {  long i,n;   struct time t1,t2;   int *a, k, tg, sec, hund;   n=30000;   a=(int*) malloc((n+1)*sizeof(int));   if (a==NULL)   {  puts("" \nLoi BN"");   getch();   exit(0);   }  sort *s[3];   select_sort ss;   quick_sort  qs;   heap_sort   hs;   s[0]=&ss; s[1]=&qs; s[2]=&hs;   clrscr();  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          247                                         tenshi3003@gmail.com  for (k=0; k<3; ++k)   {  srand(5000);   for (i=1;i<=n;++i)   a[i]=rand();   gettime(&t1);   s[k]->sapxep(a,n);   gettime(&t2);   tg =  (t2.ti_sec - t1.ti_sec)*100 + t2.ti_hund - t1.ti_hund ;   sec = tg / 100;   hund = tg % 100;   printf("" \n Sap xep %d  %d  %d %d  %d"",k+ 1,  t2.ti_sec,t2.ti_hund,t1.ti_sec,t1.ti_hund);   printf("" \n Sap xep %d  Thoi gian %d sec %d hund"",   k+1,sec,hund);   }  getch();   }                             Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          248                                         tenshi3003@gmail.com  Chương 7   Các dòng  tập tin (Stream)   C đã cung c ấp một th ư viện các h àm nh ập xuất nh ư printf, scanf, gets, getch(), puts, puch(),  fprintf, fscanf, fopen, fwite, fread,...",LTHDT_PhamVanAt.pdf - Sentence 1345
1346,.,LTHDT_PhamVanAt.pdf - Sentence 1346
1347,Các hàm này làm vi ệc khá hiệu quả nh ưng không thích ứng  với cách tổ chức ch ương tr ình hướng đối t ượng.,LTHDT_PhamVanAt.pdf - Sentence 1347
1348,C++ s ử dụng khái niệm d òng tin (stream) và đưa ra các l ớp dòng tin để tổ chức việc nhập xuất.,LTHDT_PhamVanAt.pdf - Sentence 1348
1349,Dòng tin có th ể xem nh ư một dẫy các byte.,LTHDT_PhamVanAt.pdf - Sentence 1349
1350,Thao tác nhập l à lấy (đọc) các byte từ d òng tin (khi đó  gọi là dòng nh ập - input) vào b ộ nhớ.,LTHDT_PhamVanAt.pdf - Sentence 1350
1351,Thao tác  xuất là đưa các byte t ừ bộ nhớ ra d òng tin (khi đó gọi  là dong xu ất - output).,LTHDT_PhamVanAt.pdf - Sentence 1351
1352,Các thao tác này là đ ộc lập thiết bị.,LTHDT_PhamVanAt.pdf - Sentence 1352
1353,"Để thực hiện việc nhập, xuất l ên m ột  thiết bị cụ thể, chúng ta chỉ cần gắn d òng tin v ới thiết bị n ày.",LTHDT_PhamVanAt.pdf - Sentence 1353
1354,Bài 1.,LTHDT_PhamVanAt.pdf - Sentence 1354
1355,các l ớp stream   Có 4 l ớp quan trọng cần nhớ l à:  + Lớp cơ sở ios   + Từ lớp ios dẫn xuất đến 2 lớp istream v à ostream   + Hai l ớp istream v à ostream l ại dẫn xuất tới lớp iostream   Sơ đồ kế thừa giữa các lớp nh ư sau:     ios          istream     ostream           iostream     Lớp ios    + Thu ộc tính c ủa lớp: Trong lớp ios định nghĩa các thuộc tính đ ược sử dụng l àm các c ờ định  dạng cho việc nhập xuất v à các c ờ kiểm tra lỗi (xem b ên dư ới).,LTHDT_PhamVanAt.pdf - Sentence 1355
1356,"+ Các phương th ức: Lớp ios cung cấp một số ph ương th ức phục vụ việc định dạng dữ liệu nhập  xuất, kiểm tra l ỗi (xem b ên dư ới).",LTHDT_PhamVanAt.pdf - Sentence 1356
1357,"Lớp istream   Lớp này cung c ấp toán tử nhập  >>  v à nhi ều ph ương th ức nhập khác (xem b ên dư ới) nh ư các  phương th ức: get, getline, read, ignore, peek, seekg, tellg,...",LTHDT_PhamVanAt.pdf - Sentence 1357
1358,"Lớp ostream   Lớp n ày cung c ấp toán tử xuất <<  v à nhi ều ph ương th ức xuất khác (xem bên dư ới) nh ư các  phương th ức: put, write, flush, seekp, tellp,...",LTHDT_PhamVanAt.pdf - Sentence 1358
1359,Lớp iostream   Lớp này th ừa kế các ph ương th ức nhập xuất của các lớp istream v à ostream.,LTHDT_PhamVanAt.pdf - Sentence 1359
1360,Bài 2.,LTHDT_PhamVanAt.pdf - Sentence 1360
1361,Dòng cin và toán t ử nhập   Dòng cin là m ột đối t ượng kiểu istream đ ã định nghĩa trong C ++ .,LTHDT_PhamVanAt.pdf - Sentence 1361
1362,Đó là d òng vào (input) chu ẩn  gắn với b àn phím (tương t ự như stdin c ủa C).,LTHDT_PhamVanAt.pdf - Sentence 1362
1363,Các thao tác nhập tr ên dòng cin đồng nghĩa với nhập  dữ liệu từ b àn phím.,LTHDT_PhamVanAt.pdf - Sentence 1363
1364,Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          249                                         tenshi3003@gmail.com  Do cin là m ột đối t ượng của lớp istream n ên với cin chung ta có thể sử dụng toán tử nhập >> v à  các phươ ng th ức nhập của các lớp ios v à istream.,LTHDT_PhamVanAt.pdf - Sentence 1364
1365,Cách dùng toán t ử nhập để đọc dữ liệu từ d òng cin nh ư sau:   cin >> Tham_s ố ;  Trong đó Tham_s ố có thể l à:  - Biến hoặc phần tử mảng nguy ên để nhận một số nguy ên  - Biến hoặc phần tử mảng thực để nhận một số thực   - Biến hoặc phần tử mảng ký tự để nhận một ký tự   - Con tr ỏ ký tự để nhận một dẫy các ký tự khác trống      Chú ý:  Các toán t ử nhập có thể viết nối đuôi để nhập nhiều giá trị tr ên m ột dòng l ệnh nh ư sau:   cin >> Tham_s ố_1 >> Tham_số_2 >> ...,LTHDT_PhamVanAt.pdf - Sentence 1365
1366,">> Tham_số_k ;   Cách th ức n hập nh ư sau:  Bỏ qua các ký tự trắng (dấu cách, dấu tab, dấu chuyển d òng) đứng  trước nếu có v à sau đó đ ọc vào các ký t ự tương ứng với kiểu y êu cầu.",LTHDT_PhamVanAt.pdf - Sentence 1366
1367,"Cụ thể đối với từng kiểu nh ư  sau:  Khi nh ập số nguy ên sẽ bỏ qua các ký tự trắng đứng tr ước nếu có, sau đó bắt đầu nhận các ký tự  biểu thị số nguy ên.",LTHDT_PhamVanAt.pdf - Sentence 1367
1368,Vi ệc nhập kết thúc khi gặp một ký tự trắng hoặc một ký tự không thể hiểu l à  thành ph ần của số nguy ên.,LTHDT_PhamVanAt.pdf - Sentence 1368
1369,Ví d ụ nếu tr ên dòng vào (gõ t ừ bàn phím) ch ứa các ký tự  <space><space>123X2 và Tham_s ố (bên ph ải cin) l à biến nguy ên n thì n s ẽ nhận giá trị 123.,LTHDT_PhamVanAt.pdf - Sentence 1369
1370,Con  trỏ nhập sẽ dừng tại ký tự X.,LTHDT_PhamVanAt.pdf - Sentence 1370
1371,"Phép nh ập một số thực cũng tiến h ành tương t ự: Bỏ qua các khoảng trắng đứng tr ước nếu có, sau  đó bắt đầu nhận các ký tự biểu thị số Thực.",LTHDT_PhamVanAt.pdf - Sentence 1371
1372,Việc nhập kết thúc khi gặp một ký tự trắng hoặc một k ý  tự không thể hiểu l à thành ph ần của số thực.,LTHDT_PhamVanAt.pdf - Sentence 1372
1373,"Phép nh ập một ký tự cũng vậy: Bỏ qua các khoảng trắng đứng tr ước nếu có, sau đó nhận một ký  tự khác ký tự trắng.",LTHDT_PhamVanAt.pdf - Sentence 1373
1374,Ví dụ nếu g õ <space><space>XY thì ký t ự X đ ược nhận v à con tr ỏ nhập dừng  tại ký tự Y.,LTHDT_PhamVanAt.pdf - Sentence 1374
1375,"Phép nh ập một dẫy ký tự: Bỏ qua các khoảng trắng đứng tr ước nếu có, sau đó bắt đầu nhận từ  một ký tự khác ký tự trắng.",LTHDT_PhamVanAt.pdf - Sentence 1375
1376,Việc nhập kết thúc khi gặp một ký tự trắng.,LTHDT_PhamVanAt.pdf - Sentence 1376
1377,"Ví dụ 1: Xét đo ạn ch ương tr ình:  char ten[10], que[12];   char ch;   int n;   float x;   cin >> n >> x >> ch >>  ten >> que ;   Nếu gõ các ký t ự:  123<s>3.14<s><s>ZHONG<s>HAI<s>PHONG<Enter>   (để cho gọn sẽ ký hiệu <s> l à <space>)   thì kết quả nhập nh ư sau:   n=123   x=3.14   ch=’Z’   ten=”HONG”   que = “HAI”  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          250                                         tenshi3003@gmail.com  Con tr ỏ nhập sẽ dừng tại ký tự <space> tr ước từ PHONG.",LTHDT_PhamVanAt.pdf - Sentence 1377
1378,Các ký tự c òn lại sẽ được nhận trong  các câu l ệnh nhập tiếp theo.,LTHDT_PhamVanAt.pdf - Sentence 1378
1379,Ví dụ 2: Xét  đo ạn ch ương tr ình:  int m;   float y;   cin >> m >> y;   Nếu gõ:  <s><s>456<s><s>4.5<Enter>   thì kết quả nhập l à:  m = 456   y = 4.5   Ký tự <Enter> vẫn c òn lại trên dòng nh ập.,LTHDT_PhamVanAt.pdf - Sentence 1379
1380,Bài 3.,LTHDT_PhamVanAt.pdf - Sentence 1380
1381,"Nh ập ký tự v à chu ỗi ký tự từ b àn phím   Chúng ta nh ận thấy toán tử nhập >> chỉ tiện lợi khi d ùng đ ể nhập các giá trị số (nguy ên, th ực).",LTHDT_PhamVanAt.pdf - Sentence 1381
1382,Để nhập ký tự v à chu ỗi ký tự n ên dùng các phương th ức sau (định nghĩa trong lớp istream):   cin.get     cin.getline    cin.ignore   3.1.,LTHDT_PhamVanAt.pdf - Sentence 1382
1383,Phương th ức get có 3 d ạng (thực chất có 3 ph ương th ức cùng có tên get):   Dạng 1:   int cin.get() ;   dùng đ ể đọc một ký tự (kể cả khoảng trắng).,LTHDT_PhamVanAt.pdf - Sentence 1383
1384,"Cách thức đọc của cin.get có thể minh hoạ qua ví dụ  sau:  Xét các câu l ệnh  char ch;   ch = cin.get()   + Nếu gõ  ABC<Enter>   thì bi ến ch nh ận m ã ký t ự A, các ký tự BC<Enter> c òn lại trên dòng vào.",LTHDT_PhamVanAt.pdf - Sentence 1384
1385,"+ Nếu gõ  A<Enter>   thì bi ến ch nhận m ã ký t ự A, ký tự <Enter> c òn lại trên dòng vào.",LTHDT_PhamVanAt.pdf - Sentence 1385
1386,+ Nếu gõ  <Enter>   thì bi ến ch nhận m ã ký t ự <Enter>  (bằng 10) v à dòng vào r ỗng.,LTHDT_PhamVanAt.pdf - Sentence 1386
1387,Dạng 2:   istream& cin.get(ch ar &ch) ;   dùng đ ể đọc một ký tự (kể cả khoảng trắng) v à đặt vào m ột biến kiểu  char đ ược tham chiếu bởi ch.,LTHDT_PhamVanAt.pdf - Sentence 1387
1388,"Chú ý:   + Cách th ức đọc của cin.get dạng 2 cũng giống nh ư dạng 1   + Do cin.get() d ạng 2 trả về tham chiếu tới cin, n ên có th ể sử dụng các ph ương th ức get() d ạng 2  nối đuôi nhau.",LTHDT_PhamVanAt.pdf - Sentence 1388
1389,"Ví dụ 2 nếu khai báo  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          251                                         tenshi3003@gmail.com  char ch1, ch2;   thì 2 câu l ệnh:  cin.get(ch1);   cin.get(ch2);   có th ể viết chung tr ên m ột câu lệnh sau:   cin.get(ch1).get(ch2);   Dạng 3:   istream& cin.get(char *str, int n, char delim = ‘ \n’);  dùng đ ể đọc một dẫy ký tự (kể cả khoảng trắng) v à đưa vào vùng nh ớ do str trỏ tới.",LTHDT_PhamVanAt.pdf - Sentence 1389
1390,Quá tr ình đọc  kết thúc khi xẩy ra một trong 2 t ình hu ống sau:   + Gặp ký tự giới hạn (cho trong delim).,LTHDT_PhamVanAt.pdf - Sentence 1390
1391,Ký tự giới hạn mặc định l à ‘\n’ (Enter)   + Đã nhận đủ (n -1) ký t ự  Chú ý:   + Ký t ự kết thúc ch uỗi ‘\0’ đư ợc bổ sung v ào dẫy ký tự nhận đ ược  + ký t ự giới hạn vẫn c òn lại trên dòng nh ập để d ành cho các l ệnh nhập tiếp theo.,LTHDT_PhamVanAt.pdf - Sentence 1391
1392,"Chú ý:   + Cũng giống nh ư get() d ạng 2, có thể viết các ph ương th ức get() dạng 3 nối đuôi nhau tr ên m ột  dòng l ệnh.",LTHDT_PhamVanAt.pdf - Sentence 1392
1393,+ Ký t ự <Enter> còn l ại trên dòng nh ập có thể l àm trôi phương th ức get() dạng 3.,LTHDT_PhamVanAt.pdf - Sentence 1393
1394,"Ví dụ xét đoạn  chương tr ình:  char ht[25], qq[20], cq[30];   cout << “ \nHọ tên: “ ;   cin.get(ht,25);   cout << “ \nQuê quán: “ ;   cin.get(qq,20);   cout << “ \nCơ quan: “ ;   cin.get(cq,30);   cout <<” \n” <<ht<<” “<<qq<<” “<<cq   Đoạn ch ương tr ình dùng để nhập họ t ên, quê quán và cơ quan.",LTHDT_PhamVanAt.pdf - Sentence 1394
1395,N ếu gõ:  Pham Thu Huong<Enter>   thì câu l ệnh get đầu ti ên sẽ nhận đ ược chuỗi “Pham Thu Huong” cất v ào m ảng ht.,LTHDT_PhamVanAt.pdf - Sentence 1395
1396,Ký tự <Enter>  còn l ại sẽ l àm trôi 2 câu l ệnh get tiếp theo.,LTHDT_PhamVanAt.pdf - Sentence 1396
1397,Do đó  câu l ệnh cuối c ùng s ẽ chỉ in ra Pham Thu Huong.,LTHDT_PhamVanAt.pdf - Sentence 1397
1398,"Để khắc phục t ình tr ạng tr ên, có th ể dùng m ột trong các cách sau:   + Dùng phương th ức get() dạng 1 hoặc dạng 2 để lấy ra ký tự <Enter> tr ên dòng nh ập trước khi  dùng get (d ạng 3).",LTHDT_PhamVanAt.pdf - Sentence 1398
1399,+ Dùng phương th ức ignore để lấy ra một số ký tự không cần thiết tr ên dòng nh ập trước khi d ùng  get d ạng 3.,LTHDT_PhamVanAt.pdf - Sentence 1399
1400,Ph ương th ức này vi ết nh ư sau:   cin.ignore(n) ; // L ấy ra (loại ra hay bỏ qua) n ký tự tr ên   // dòng nh ập.,LTHDT_PhamVanAt.pdf - Sentence 1400
1401,"Như v ậy để có thể nhập đ ược cả qu ê quán và cơ quan, c ần sửa lại đoạn ch ương trình trên nh ư  sau: Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          252                                         tenshi3003@gmail.com  char ht[25], qq[20], cq[30];   cout << “ \nHọ tên: “ ;   cin.get(ht,25);   cin.get();  // Nh ận <Enter>   cout << “ \nQuê quán: “ ;   cin.get(qq,20);   ignore(1);  // B ỏ qua <Enter>   cout << “ \nCơ quan: “ ;   cin.get(cq,30);   cout <<” \n” <<ht<<” “<<qq <<” “<<cq   3.2.",LTHDT_PhamVanAt.pdf - Sentence 1401
1402,"Phương th ức getline   Tương t ự như get d ạng 3, có thể d ùng getline đ ể nhập một dẫy ký tự từ b àn phím.",LTHDT_PhamVanAt.pdf - Sentence 1402
1403,"Phương th ức  này đư ợc mô tả nh ư sau:   istream& cin.getline(char *str, int n, char delim = ‘ \n’);  Phương th ức đầu ti ên làm vi ệc nh ư get d ạng 3, sau đó nó lo ại <Enter> ra khỏi d òng nh ập (ký tự  <Enter> không đưa vào d ẫy ký tự nhận đ ược).",LTHDT_PhamVanAt.pdf - Sentence 1403
1404,Nh ư vậy có thể d ùng getline đ ể nhập nhiều chuối ký  tự (m à không lo ng ại các câu lệnh nhập tiếp theo bị trôi).,LTHDT_PhamVanAt.pdf - Sentence 1404
1405,"Ví d ụ đoạn ch ương tr ình nh ập họ t ên, quê quán và cơ quan bên trên có th ể viết nh ư sau (b ằng  cách dùng getline):   char ht[25], qq[20], cq[30];   cout << “ \nHọ tên: “ ;   cin.getline(ht,25);   cout << “ \nQuê quán: “ ;   cin.getline(qq,20);   cout << “ \nCơ quan: “ ;   cin.get(cq,30);   cout <<” \n” <<ht<<” “<<qq<<” “<<cq   Chú ý: Cũng giống nh ư get() d ạng 2 v à get() d ạng 3, có thể viết các ph ương th ức getline() nối  đuôi nhau trên m ột dòng l ệnh.",LTHDT_PhamVanAt.pdf - Sentence 1405
1406,"Ví dụ đoạn ch ương tr ình trên có th ể viết lại nh ư sau:   char ht[25], qq[20], cq[30];   cout << “ \nHọ tên, Quê quán và Cơ quan:  “ ;   cin.getl ine(ht,25).getline(qq,20).get(cq,30);   cout <<” \n” <<ht<<” “<<qq<<” “<<cq   3.3.",LTHDT_PhamVanAt.pdf - Sentence 1406
1407,Phương th ức ignore   Phương th ức ignore d ùng đ ể bỏ qua (loại bỏ) một số ký tự tr ên dòng nh ập.,LTHDT_PhamVanAt.pdf - Sentence 1407
1408,"Trong nhiều tr ường  hợp, đây l à việc làm c ần thiết để không l àm ảnh h ưởng đến các phép nhập tiếp theo.",LTHDT_PhamVanAt.pdf - Sentence 1408
1409,Phương th ức ignore đ ược mô tả nh ư sau:   istream& cin.ignore(int n=1);   Phương th ức sẽ bỏ qua (loại bỏ) n ký tự tr ên dòng nh ập.,LTHDT_PhamVanAt.pdf - Sentence 1409
1410,3.4.,LTHDT_PhamVanAt.pdf - Sentence 1410
1411,"Nh ập đồng thời giá trị số v à ký t ự  Như đ ã nói trong §2, toán t ử nhập >> bao giờ cũng để lại ký tự <Enter> tr ên dòng nh ập.",LTHDT_PhamVanAt.pdf - Sentence 1411
1412,Ký tự  <Enter> này s ẽ làm trôi các l ệnh nhập ký tự hoặc chuỗi ký tự b ên dư ới.,LTHDT_PhamVanAt.pdf - Sentence 1412
1413,Do vậy cần d ùng: Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          253                                         tenshi3003@gmail.com  hoặc ignore()   hoặc get() dạng 1   hoặc get() dạng 2   để loại bỏ ký tự <Enter> c òn sót l ại ra khỏi d òng nh ập tr ước khi thực hiện việc nhập ký tự hoặc  chuỗi ký tự.,LTHDT_PhamVanAt.pdf - Sentence 1413
1414,3.5.,LTHDT_PhamVanAt.pdf - Sentence 1414
1415,Ví d ụ: Chương tr ình d ưới đây sử dụng lớp TSINH (Thí sinh) với 2 ph ương th ức xuat v à nhap.,LTHDT_PhamVanAt.pdf - Sentence 1415
1416,"//CT7_04.CPP   // Nh ập dữ li êu số và ký t ự  #include <iostream.h>   #include <conio.h>   struct TS   {  int sobd;   char ht[25];   float dt,dl,dh,td;   } ;  class TSIN H  {  private:   TS *ts;   int sots;   public:   TSINH()   {  ts=NULL;   sots=0;   }  TSINH(int n)   {  ts=new TS[n+1];   sots=n;   }  ~TSINH()   {  if (sots)   {  sots=0;   ts = NULL;   } Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          254                                         tenshi3003@gmail.com  }  void nhap();   void xuat();   } ;  void TSINH::nhap()   {  if (sots)   for (int i=1; i<=sots; ++i)   {  cout << "" \nThi sinh ""<< i << "": "" ;   cout << "" \nSo bao danh: "" ;   cin >> ts[i].sobd;   cin.ignore();   cout << ""Ho ten: "" ;   cin.get(ts[i].ht,25);   cout << ""Diem toan, ly , hoa: "" ;   cin >> ts[i].dt >> ts[i].dl >> ts[i].dh;   ts[i].td = ts[i].dt + ts[i].dl + ts[i].dh;   }  }  void TSINH::xuat()   {  if (sots)   {  cout << "" \nDanh sach thi sinh:"" ;   for (int i=1; i<=sots; ++i)   cout << "" \nHo ten: "" << ts[i].ht << "" So BD: ""<< ts[i].sobd   <<"" Tong diem: ""<< ts[i].td;   }  }  void main()   {  int n;   clrscr();   cout << "" \nSo thi sinh: "";   cin>>n;   TSINH *t = new TSINH(n);   t->nhap() ;  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          255                                         tenshi3003@gmail.com  t->xuat();   getch();   delete t;   }  Bài 4.",LTHDT_PhamVanAt.pdf - Sentence 1416
1417,Dòng cout  và toán t ử xuất   4.1.,LTHDT_PhamVanAt.pdf - Sentence 1417
1418,Dòng cout   Dòng cout là m ột đối t ượng kiểu ostream đ ã định nghĩa trong C++.,LTHDT_PhamVanAt.pdf - Sentence 1418
1419,Đó l à dòng xu ất (output)  chuẩn gắn với m àn hình (t ương t ự như stdout c ủa C).,LTHDT_PhamVanAt.pdf - Sentence 1419
1420,Các thao tác xuất tr ên dòng cout đồng nghĩa  với xuất dữ liệu ra m àn hình.,LTHDT_PhamVanAt.pdf - Sentence 1420
1421,Do cout là m ột đố i tượng của lớp ostream n ên với cout chung ta có thể sử dụng toán tử xuất <<  và các phương th ức xuất của các lớp ios v à ostream.,LTHDT_PhamVanAt.pdf - Sentence 1421
1422,4.2.Toán t ử xuất   C++ đ ịnh nghĩa chồng toán tử dịch trái << để gửi các ký tự ra d òng xu ất.,LTHDT_PhamVanAt.pdf - Sentence 1422
1423,Cách dùng toán t ử xuất để xuất dữ li ệu từ bộ nhớ ra d òng cout nh ư sau:   cout << Tham_s ố ;  Trong đó Tham_s ố biểu thị một giá trị cần xuất ra m àn hình.,LTHDT_PhamVanAt.pdf - Sentence 1423
1424,Giá tr ị sẽ đ ược biến đổi th ành m ột  dẫy ký tự tr ước khi đ ưa ra d òng xu ất.,LTHDT_PhamVanAt.pdf - Sentence 1424
1425,Kiểu của Tham_số có thể nh ư sau:   - Nguyên (xu ất giá trị nguy ên)  - Thực (xu ất giá trị thực)   - ký tự - char (xu ất một ký tự)   - con tr ỏ ký tự - char* (xu ất chuỗi ký tự)   Chú ý:  Các toán t ử xuất có thể viết nối đuôi nhau (để xuất nhiều giá trị) tr ên m ột dòng l ệnh nh ư  sau:   cout << Tham_s ố_1 << Tham_số_2 << ...,LTHDT_PhamVanAt.pdf - Sentence 1425
1426,<< Tham_số_k ;   Chú ý: Toán t ử xuất đ ược định nghĩa chồng (tr ùng tên) v ới toán tử dịch trái v à nó cùng có m ức  độ ưu tiên như toán t ử dịch trái.,LTHDT_PhamVanAt.pdf - Sentence 1426
1427,Xem phụ lục 1 chúng ta thấy toán tử xuất có thứ tự ưu tiên l ớn hơn  các toán t ử trong biểu thức điều kiện.,LTHDT_PhamVanAt.pdf - Sentence 1427
1428,"V ì vậy nếu d ùng toán t ử xuất để in một biểu thức điều kiện  như sau:   int a=5, b=10;   cout << “ \nMax= “ << a>b?a:b ;   thì Trình biên d ịch sẽ báo lỗi.",LTHDT_PhamVanAt.pdf - Sentence 1428
1429,"Để tránh lỗi cần d ùng các d ấu ngoặc tr òn để bao biểu thức điều kiện  như sau:   int a=5, b=10;   cout << “ \nMax= “ << (a>b?a:b) ;   Tóm l ại: Nên bao các bi ểu thức trong 2 dấu ngoặc tr òn.",LTHDT_PhamVanAt.pdf - Sentence 1429
1430,4.3.,LTHDT_PhamVanAt.pdf - Sentence 1430
1431,Đ ịnh dạng (tạo khuôn dạng cho) dữ liệu xuất   Việc định dạng dữ liệu xuất hay tạo khuôn dạng cho dữ liệu xuất l à một việc cần thiết.,LTHDT_PhamVanAt.pdf - Sentence 1431
1432,Ví dụ cần  in các giá tr ị thực tr ên 10 v ị trí trong đó có 2 vị trí d ành cho  phần phân.,LTHDT_PhamVanAt.pdf - Sentence 1432
1433,"Bản thân toán tử xuất ch ưa có kh ả năng định dạng, m à cần sử dụng các công cụ sau:   + Các phương th ức định dạng  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          256                                         tenshi3003@gmail.com  + Các các c ờ định dạng   + Các hàm và b ộ phận định dạng   Mục sau sẽ tr ình b ầy cách định dạng giá trị xuất.",LTHDT_PhamVanAt.pdf - Sentence 1433
1434,Bài 5.,LTHDT_PhamVanAt.pdf - Sentence 1434
1435,Các phương th ức định dạng  5.1.,LTHDT_PhamVanAt.pdf - Sentence 1435
1436,"N ội dung định dạng giá trị xuất   Nội dung định dạng l à xác đ ịnh các thông số:   - Độ rộng quy định   - Độ chính xác   - Ký tự độn   - Và các thông s ố khác    + Độ rộng thực tế của giá trị xuất: Như đ ã nói ở trên, C++ s ẽ biến đổi giá trị cần xuất th ành  một chuỗi ký tự rồi đ ưa chu ỗi này ra màn hình.",LTHDT_PhamVanAt.pdf - Sentence 1436
1437,Ta s ẽ gọi số ký tự của chuỗi n ày là đ ộ rộng thực tế  của giá trị xuất.,LTHDT_PhamVanAt.pdf - Sentence 1437
1438,"Ví dụ với các câu lệnh:   int n=4567, m= -23 ;  float  x = -3.1416 ;   char ht[] = “Tran Van Thong” ;   thì:  Độ rộng thực tế của n l à 4, c ủa m l à 3, c ủa x là 7, c ủa ht l à 14.",LTHDT_PhamVanAt.pdf - Sentence 1438
1439,+ Độ rộng quy đinh là số vị trí tối thiểu tr ên màn hình dành để in giá trị.,LTHDT_PhamVanAt.pdf - Sentence 1439
1440,"Theo mặc định, độ  rộng quy định bằng 0.",LTHDT_PhamVanAt.pdf - Sentence 1440
1441,Chúng ta có thể d ùng phương th ức cout.width() để thiết lập rộng n ày.,LTHDT_PhamVanAt.pdf - Sentence 1441
1442,Ví d ụ  câu l ệnh:  cout.width(8);   sẽ thiết lập độ rộng quy định l à 8.,LTHDT_PhamVanAt.pdf - Sentence 1442
1443,+ Mối quan hệ giữa độ rộng thực tế v à độ rộng quy định   - Nếu độ rộng thực tế lớn h ơn ho ặc bằng độ rộng quy định th ì số vị trí tr ên màn hình ch ứa giá trị   xuất sẽ bằng độ rộng thực tế.,LTHDT_PhamVanAt.pdf - Sentence 1443
1444,- Nếu độ rộng thực tế nhỏ h ơn độ rộng quy định th ì số vị trí tr ên màn hình ch ứa giá trị  xuất sẽ  bằng độ rộng quy định.,LTHDT_PhamVanAt.pdf - Sentence 1444
1445,Khi đó sẽ có một số vị trí d ư thừa.,LTHDT_PhamVanAt.pdf - Sentence 1445
1446,Các vị trí d ư thừa sẽ đ ược độn (lấp đầy)  bằng khoảng trống.,LTHDT_PhamVanAt.pdf - Sentence 1446
1447,+ Xác đ ịnh ký tự độn: Ký tự độn mặc định l à dấu cách (khoảng trống).,LTHDT_PhamVanAt.pdf - Sentence 1447
1448,Tuy nhi ên có th ể dùng  phương th ức cout.fill() để chọn một ký tự độn khác.,LTHDT_PhamVanAt.pdf - Sentence 1448
1449,Ví dụ với các câu lệnh sau:   int n=123;    // Đ ộ rộng thực tế l à 3  cout.fill(‘*’); // Ký t ự độn l à *  cout.width(5); // Đ ộ rộng quy định l à 5  cout << n ;   thì kết quả in ra l à:  **123   + Độ chính xác là số vị t rí dành cho ph ần phân (khi in số thực).,LTHDT_PhamVanAt.pdf - Sentence 1449
1450,Độ chính xác mặc định l à 6.,LTHDT_PhamVanAt.pdf - Sentence 1450
1451,Tuy  nhiên có th ể dùng phương th ức cout.precision() để chọn độ chính xác.,LTHDT_PhamVanAt.pdf - Sentence 1451
1452,Ví dụ với các câu lệnh:   float  x = 34.455 ;  // Đ ộ rộng thực tế 6   cout.precision(2) ; // Đ ộ chính xác 2  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          257                                         tenshi3003@gmail.com  cout.width( 8);       // Đ ộ rộng quy ước 8  cout.fill(‘0’) ;       // Ký t ự độn l à số 0  cout << x ;   thì kết quả in ra l à:  0034.46   5.2.,LTHDT_PhamVanAt.pdf - Sentence 1452
1453,Các phương th ức định dạng   1.,LTHDT_PhamVanAt.pdf - Sentence 1453
1454,Phương th ức  int cout.width()   cho bi ết độ rộng quy định hiện tại.,LTHDT_PhamVanAt.pdf - Sentence 1454
1455,2.,LTHDT_PhamVanAt.pdf - Sentence 1455
1456,Phương th ức  int cout.width(int n)   Thiết lập độ rộng quy định mới l à n và tr ả về độ rộng quy định tr ước đó.,LTHDT_PhamVanAt.pdf - Sentence 1456
1457,Chú ý:  Độ rộng quy định n chỉ có tác dụng cho một giá trị xuất.,LTHDT_PhamVanAt.pdf - Sentence 1457
1458,Sau đó C++ lại áp dụng độ rộng  quy đ ịnh bằng 0.,LTHDT_PhamVanAt.pdf - Sentence 1458
1459,"Ví dụ với các câu lệnh:   int m=1234, n=56;   cout << “ \nAB”   cout.width(6);   cout << m ;   cout << n ;   thì kết quả in ra l à:  AB  123456   (giữa B v à số 1 có 2 dấu cách).",LTHDT_PhamVanAt.pdf - Sentence 1459
1460,3.,LTHDT_PhamVanAt.pdf - Sentence 1460
1461,Phương th ức  int cout.precision()   Cho bi ết độ chính xác hiện tại (đang áp dụng để xuất các giá trị thức).,LTHDT_PhamVanAt.pdf - Sentence 1461
1462,4.,LTHDT_PhamVanAt.pdf - Sentence 1462
1463,Phương th ức  int cout.precision(int n)   Thiết lập độ chính  xác s ẽ áp dụng l à n và cho bi ết độ chính xác tr ước đó.,LTHDT_PhamVanAt.pdf - Sentence 1463
1464,Độ chính xác đ ược thiết  lập sẽ có hiệu lực cho tới khi gặp một câu lệnh thiết lập độ chính xác mới.,LTHDT_PhamVanAt.pdf - Sentence 1464
1465,5.,LTHDT_PhamVanAt.pdf - Sentence 1465
1466,Phương th ức  char cout.fill()   Cho bi ết ký tự độn hiện tại đang đ ược áp dụng.,LTHDT_PhamVanAt.pdf - Sentence 1466
1467,6.,LTHDT_PhamVanAt.pdf - Sentence 1467
1468,Phương th ức  char c out.fill(char ch)   Quy đ ịnh ký tự độn mới sẽ đ ược dùng là ch và cho bi ết ký tự độn đang d ùng trư ớc đó.,LTHDT_PhamVanAt.pdf - Sentence 1468
1469,Ký tự độn  được thiết lập sẽ có hiệu lực cho tới khi gặp một câu lệnh chọn ký tự độn mới.,LTHDT_PhamVanAt.pdf - Sentence 1469
1470,"Ví dụ xét chương tr ình:  //CT7_06.CPP  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          258                                         tenshi3003@gmail.com  // Cac phuong thuc dinh dang   #include <iostream.h>   #include <conio.h>   void main()   {  clrscr();   float x= -3.1551, y= -23.45421;   cout.precision(2);   cout.fill('*');   cout << "" \n"" ;  cout.width(8);   cout << x;   cout << "" \n"" ;  cout.width(8);   cout << y;   getch();   }  Sau khi th ực hiện, ch ương tr ình in ra màn hình 2 dòng sau:   ***-3.16  **-23.45   Bài 6.",LTHDT_PhamVanAt.pdf - Sentence 1470
1471,Cờ định dạng   6.1.,LTHDT_PhamVanAt.pdf - Sentence 1471
1472,Khái ni ệm chung về cờ   Mỗi cờ chứa trong một bit.,LTHDT_PhamVanAt.pdf - Sentence 1472
1473,"Cờ có 2 trạng thái:   Bật (on)  -  có giá tr ị 1  Tắt (off) - có giá tr ị 0  (Trong 6.3 s ẽ trình b ầy các ph ương th ức dùng đ ể bật, tắt các cờ)   Các c ờ có thể chứa trong một biến kiểu long.",LTHDT_PhamVanAt.pdf - Sentence 1473
1474,Trong tệp <iostream.h> đ ã định nghĩa các cờ sau:   ios::left         ios::right  ios::internal   ios::dec          ios::oct       ios::hex   ios::fixed       ios::scientific  ios::showpos            ios::uppercase  ios::s howpoint    ios::showbase   6.2.,LTHDT_PhamVanAt.pdf - Sentence 1474
1475,"Công d ụng của các cờ   Có th ể chia các cờ th ành các  nhóm:   Nhóm 1 g ồm các cờ định vị (căn lề) :   ios::left  ios::right  ios::internal   Cờ ios::left : Khi b ật cờ ios:left  th ì giá tr ị in ra nằm b ên trái vùng quy đ ịnh, các ký tự độ n nằm  sau, ví d ụ:  35***   -89**   Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          259                                         tenshi3003@gmail.com  Cờ ios::right : Khi b ật cờ ios:right th ì giá tr ị in ra nằm b ên ph ải vùng quy đ ịnh, các ký tự độn  nằm tr ước, ví dụ:   ***35   **-89  Chú ý:  Mặc định cờ ios::right bật.",LTHDT_PhamVanAt.pdf - Sentence 1475
1476,"Cờ ios::internal : Cờ ios:internal có tác dụng giống nh ư cờ ios: :right ch ỉ khác l à dấu (nếu có) in  đầu tiên, ví d ụ:  ***35   -**89   Chương tr ình sau minh ho ạ cách d ùng các c ờ định vị:   //CT7_06.CPP   // Cac phuong thuc dinh dang   // Co dinh vi   #include <iostream.h>   #include <conio.h>   void main()   {  clrscr();   float x= -87.1551, y =23.45421;   cout.precision(2);   cout.fill('*');   cout.setf(ios::left);  // B ật cờ ios::left   cout << "" \n"" ;  cout.width(8);   cout << x;   cout << "" \n"" ;  cout.width(8);   cout << y;   cout.setf(ios::right); // B ật cờ ios::right   cout << "" \n"" ;  cout.width(8);   cout << x;   cout << "" \n"" ;  cout.width(8);   cout << y;   cout.setf(ios::internal);  // // B ật cờ ios::internal   cout << "" \n"" ;  cout.width(8);   cout << x;   cout << "" \n"" ;  cout.width(8);   cout << y;  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          260                                         tenshi3003@gmail.com  getch();   }  Sau khi th ực hiện ch ương tr ình in ra 6 dòng nh ư sau:   -87.16**   23.45* **  **-87.16   ***23.45   -**87.16   ***23.45   Nhóm 2 g ồm  các cờ định dạng số nguy ên:   ios::dec ios::oct   ios::hex   + Khi ios::dec b ật (mặc định): Số nguy ên đư ợc in d ưới dạng c ơ số 10  + Khi ios::oct b ật :  Số nguy ên đư ợc in d ưới dạng c ơ số 8  + Khi ios::hex b ật :  Số nguy ên đư ợc in d ưới dạng c ơ số 16  Nhóm 3 g ồm các cờ định dạng số thực :   ios::f ĩxed   ios::scientific ios::showpoint   Mặc định: Cờ ios::fixed bật (on) v à  cờ ios::showpoint tắt (off).",LTHDT_PhamVanAt.pdf - Sentence 1476
1477,"+ Khi ios::fixed b ật và cờ ios::showpoint tắt  th ì số thực in ra d ưới dạng thập phân, số chữ số  phần phân (sau dấu chấm)  đ ược tính bằng độ chính xác n nh ưng khi in th ì bỏ đi các chữ số 0 ở  cuối.",LTHDT_PhamVanAt.pdf - Sentence 1477
1478,"Ví dụ nếu độ chính xác n = 4 th ì:  Số thực -87.1500   đư ợc in:     -87.15   Số thực 23.45425   đ ược in:     23.4543   Số thực 678.0   đ ược in:           678   + Khi ios::fixed b ật và cờ ios::showpoint bật  th ì số thực in ra d ưới dạng thập phân, số chữ số  phần phân (sau dấu chấm) đ ược in ra đúng bằng độ chính xác n.",LTHDT_PhamVanAt.pdf - Sentence 1478
1479,Ví dụ nếu độ chính xác n = 4 th ì:  Số thực -87.1500   được in:    -87.1500   Số thực 23.45425   được in:     23.4543   Số thực 678.0    được in:     678.0000   + Khi ios::scientific b ật và cờ ios::showpoint tắt th ì số thực in ra d ưới dạng mũ (dạng khoa học).,LTHDT_PhamVanAt.pdf - Sentence 1479
1480,Số chữ số phần phân (sau dấu chấm) của phần định trị  đ ược tính bằng độ chính x ác n nhưng khi in  thì bỏ đi các chữ số 0 ở cuối.,LTHDT_PhamVanAt.pdf - Sentence 1480
1481,Ví dụ nếu độ chính xác n = 4 th ì:  Số thực -87.1500   được in:    -8.715e+01   Số thực 23.45425   được in:     2.3454e+01   Số thực 678.0    được in:     6.78e+02   + Khi ios::scientific b ật và cờ ios::showpoint bậ t  thì s ố thực in ra d ưới dạng mũ.,LTHDT_PhamVanAt.pdf - Sentence 1481
1482,Số chữ số phần  phân (sau d ấu chấm) của phần định trị  đ ược in đúng bằng độ chính xác n.,LTHDT_PhamVanAt.pdf - Sentence 1482
1483,Ví dụ nếu độ chính xác n = 4 th ì: Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          261                                         tenshi3003@gmail.com  Số thực -87.1500   được in:    -8.7150e+01   Số thực 23.45425   được in:     2.3454e+01   Số thực 678.,LTHDT_PhamVanAt.pdf - Sentence 1483
1484,0    được in:     6.7800e+01   Nhóm 4 g ồm các hiển thị:   ios::showpos   ios::showbase  ios::uppercase   Cờ  ios::showpos   + Nếu cờ ios::showpos tắt (mặc định) th ì dấu cộng không đ ược in tr ước số d ương.,LTHDT_PhamVanAt.pdf - Sentence 1484
1485,+ Nếu cờ ios::showpos bật th ì dấu cộng đ ược in tr ước số d ương.,LTHDT_PhamVanAt.pdf - Sentence 1485
1486,Cờ  ios::showbase   + Nếu cờ ios::showbase bật th ì số nguy ên hệ 8 đ ược in bắt đầu bằng ký tự 0 v à số nguy ên hệ 16  được bắt đầu bằng các ký tự 0x.,LTHDT_PhamVanAt.pdf - Sentence 1486
1487,Ví dụ nếu a = 40 th ì:  dạng in hệ 8 l à:    050   dạng in hệ 16 l à   0x28   + Nếu cờ ios::showbase  tắt (mặc định ) thì không in 0 tr ước số nguy ên hệ 8 v à không in 0x trư ớc  số nguy ên hệ 16.,LTHDT_PhamVanAt.pdf - Sentence 1487
1488,"Ví dụ nếu a = 40 th ì:  dạng in hệ 8 l à:    50   dạng in hệ 16 l à   28   Cờ  ios::uppercase   + Nếu cờ ios::uppercase  bật th ì các ch ữ số hệ 16 (nh ư A, B, C, ...) đư ợc in d ưới dạng chữ ho a.",LTHDT_PhamVanAt.pdf - Sentence 1488
1489,"+ Nếu cờ ios::uppercase  tắt (mặc định) th ì các ch ữ số hệ 16 (nh ư A, B, C, ...) đư ợc in d ưới dạng  chữ thường.",LTHDT_PhamVanAt.pdf - Sentence 1489
1490,6.3.,LTHDT_PhamVanAt.pdf - Sentence 1490
1491,Các phương th ức bật tắt cờ   Các phương th ức này định nghĩa trong lớp ios.,LTHDT_PhamVanAt.pdf - Sentence 1491
1492,+ Phương th ức  long cout.setf(long f) ;   sẽ bật các cờ liệt k ê trong f và tr ả về một giá trị long biểu thị các cờ đang bật.,LTHDT_PhamVanAt.pdf - Sentence 1492
1493,Thông th ường giá trị f  được xác định bằng cách tổ hợp các cờ tr ình b ầy trong  mục 6.1.,LTHDT_PhamVanAt.pdf - Sentence 1493
1494,Ví dụ câu l ệnh:  cout.setf(ios::showpoint | ios::scientific) ;   sẽ bật các cờ ios::showpoint v à ios::scientific.,LTHDT_PhamVanAt.pdf - Sentence 1494
1495,+ Phương th ức  long cout.unsetf(long f) ;   sẽ tắt các cờ liệt k ê trong f và tr ả về một giá trị long biểu thị các cờ đang bật.,LTHDT_PhamVanAt.pdf - Sentence 1495
1496,Thông th ường giá trị f  được xác định bằng cách tổ hợp các cờ tr ình b ầy trong mục 6.1.,LTHDT_PhamVanAt.pdf - Sentence 1496
1497,Ví dụ câu l ệnh:  cout.unsetf(ios::showpoint | i os::scientific) ;   sẽ tắt các cờ ios::showpoint v à ios::scientific.,LTHDT_PhamVanAt.pdf - Sentence 1497
1498,+ Phương th ức  long cout.flags(long f) ;   có tác d ụng giống nh ư cout.setf(long).,LTHDT_PhamVanAt.pdf - Sentence 1498
1499,Ví d ụ câu lệnh:  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          262                                         tenshi3003@gmail.com  cout.flags(ios::showpoint | ios::scientific) ;   sẽ bật các cờ ios::showpoint v à ios::scientific .,LTHDT_PhamVanAt.pdf - Sentence 1499
1500,+ Phương th ức  long cout.flags() ;   sẽ trả về một giá trị long biểu thị các cờ đang bật.,LTHDT_PhamVanAt.pdf - Sentence 1500
1501,Bài 7.,LTHDT_PhamVanAt.pdf - Sentence 1501
1502,Các b ộ phận định dạng v à các hàm đ ịnh dạng   7.1.,LTHDT_PhamVanAt.pdf - Sentence 1502
1503,Các b ộ phận định dạng (định nghĩa trong <iostream.h>)   Các b ộ phận định dạng gồm:   dec    // như c ờ ios::dec   oct    // như c ờ  ios::oct   hex   // như c ờ  ios::hex   endl   // xu ất ký tự ‘ \n’  (chuy ển dòng)  flush  // đ ẩy dữ liệu ra thiết bị xuất   Chúng có tác d ụng nh ư cờ định dạng nh ưng đư ợc viết nối đuôi trong toán tử xuất n ên tiện sử  dụng h ơn.,LTHDT_PhamVanAt.pdf - Sentence 1503
1504,"Ví dụ xét chương tr ình đơn giản sau:           //CT7_08.CPP   // Bo phan dinh dang   #include <iostream.h>   #include <conio.h>   void main()   {  clrscr();   cout.setf(ios::showbase)   cout << ""ABC"" << endl << hex << 40 << "" "" << 41;   getch();   }  Chương tr ình s ẽ in 2 d òng sau ra màn hình:   ABC   0x28 0x29   7.2.",LTHDT_PhamVanAt.pdf - Sentence 1504
1505,Các hàm đ ịnh dạng (định nghĩa trong <iomanip.h>)   Các hàm đ ịnh dạng gồm:   setw(int n)               // như cout.width(int n)   setpecision(int n)     // như cout.pecision(int n)   setfill(char ch)         // như cout.,LTHDT_PhamVanAt.pdf - Sentence 1505
1506,fill(char ch)       setiosflags(l ong l)    // như cout.setf(long f)   resetiosflags(long l)  // như cout.unsetf(long f)   Các hàm đ ịnh dạng có tác dụng nh ư các phương th ức định dạng nh ưng đư ợc viết nối đuôi trong  toán t ử xuất n ên tiện sử dụng h ơn.,LTHDT_PhamVanAt.pdf - Sentence 1506
1507,Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          263                                         tenshi3003@gmail.com  Chú ý 1:  Các hàm đ ịnh dạng (cũng nh ư các b ộ phận định dạng) cần viết trong các toán tử xuất.,LTHDT_PhamVanAt.pdf - Sentence 1507
1508,Một hàm đ ịnh dạng đứng một m ình nh ư một câu lệnh sẽ không có tác dụng định dạng.,LTHDT_PhamVanAt.pdf - Sentence 1508
1509,"Chú ý 2:  Muốn sử dụng các h àm đ ịnh dạng cần bổ sung v ào đầu ch ương tr ình câu l ệnh:  #include <iomanip.h>   Ví dụ có th ể thay ph ương th ức  cout.setf(ios::showbase) ;   trong chương tr ình c ủa mục 7.1 bằng h àm   cout << setiosflags(ios::showbase);   (chú ý hàm ph ải viết trong toán tử xuất)   Như v ậy ch ương tr ình trong 7.1 có th ể viết lại theo các ph ương án sau:   Phương án 1:   #include <iostrea m.h>   #include <iomanip.h>   #include <conio.h>   void main()   {  clrscr();   cout << setiosflags(ios::showbase) ;   cout << ""ABC"" << endl << hex << 40 << "" "" << 41;   getch();   }  Phương án 2:   #include <iostream.h>   #include <iomanip.h>   #include <conio.h>   void main()   {  clrscr();   cout << ""ABC"" << endl << setiosflags(ios::showbase)   << hex << 40 << "" "" << 41;   getch();   }  Dưới đây l à ví d ụ khác về việc d ùng các hàm và b ộ phận định dạng.",LTHDT_PhamVanAt.pdf - Sentence 1509
1510,Các câu lệnh:   int i = 23;   cout << i  << endl << setiosflags(ios::showbase)   << hex << i << dec << setfill(‘*’)   << endl << setw(4) << i << setfill(‘0’)   << endl << setw(5) << i ;   sẽ in ra m àn hình nh ư sau:   23  0x17   **23   00023  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          264                                         tenshi3003@gmail.com  7.3.,LTHDT_PhamVanAt.pdf - Sentence 1510
1511,"Ví d ụ: Chương tr ình d ưới đây minh hoạ cách d ùng các hàm đ ịnh dạng v à phương th ức định  dạng để in danh sách thí sinh dưới dạng bảng với các y êu cầu sau: Số báo danh in 4 ký tự (ch èn  thêm s ố 0 v ào trư ớc ví dụ 0003), tổng điểm in với đúng một chữ số phần phân.",LTHDT_PhamVanAt.pdf - Sentence 1511
1512,"//CT7_08.CPP   // Bo phan dinh dang   // Ham dinh dang   // Co dinh dang   #include <iostream.h>   #include <iomanip.h>   #include <conio.h>   struct TS   {  int sobd;   char ht[25];   float dt,dl,dh,td;   };  class TSINH   {  private:   TS *ts;   int sots;   public:   TSINH()   {  ts=NULL;   sots=0;   }  TSINH(int n)   {  ts=new TS[n+1];   sots=n;   }  ~TSINH()   {  if (sots)   {  sots=0;   ts = NULL;   }  } Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          265                                         tenshi3003@gmail.com  void nhap();   void s apxep();   void xuat();    } ;  void TSINH::nhap()   {  if (sots)   for (int i=1; i<=sots; ++i)   {  cout << "" \nThi sinh ""<< i << "": "" ;   cout << "" \nSo bao danh: "" ;   cin >> ts[i].sobd;   cin.ignore();   cout << ""Ho ten: "" ;   cin.get(ts[i].ht,25);   cout << ""Diem toan, ly , hoa : "" ;  cin >> ts[i].dt >> ts[i].dl >> ts[i].dh;   ts[i].td = ts[i].dt + ts[i].dl + ts[i].dh;   }  }  void TSINH::sapxep()   {  int i,j;   for (i=1; i< sots; ++i)   for (j=i+1; j<= sots; ++j)   if (ts[i].td < ts[j].td)   {  TS tg;   tg=ts[i];   ts[i]=ts[j];   ts[j]=tg;   }  }  void TSI NH::xuat()   {  if (sots)   {  cout << "" \nDanh sach thi sinh:"" ;   cout.precision(1);   cout << setiosflags(ios::left);  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          266                                         tenshi3003@gmail.com  cout << "" \n"" << setw(20) << ""Ho ten"" << setw(8)   << ""So BD"" << setw(10)   << ""Tong diem"";   for (int i=1; i<=sots; ++i)   cout << "" \n"" << setw(20)<<se tiosflags(ios::left) << ts[i].ht   << setw(4) << setfill('0') << setiosflags(ios::right)   << ts[i].sobd << ""    "" << setfill(32)   << setiosflags(ios::left|ios::showpoint)   << setw(10) << ts[i].td;   }  }  void main()   {  int n;   clrscr();   cout << "" \nSo thi sinh: "";   cin>>n;   TSINH *t = new TSINH(n);   t->nhap() ;   t->sapxep();   t->xuat();   getch();   delete t;   }  Bài 8.",LTHDT_PhamVanAt.pdf - Sentence 1512
1513,"Các dòng tin chu ẩn  Có 4 dòng tin ( đối tượng của các lớp Stream) đ ã định nghĩa tr ước, đ ược cài đặt khi ch ương tr ình  khởi động.",LTHDT_PhamVanAt.pdf - Sentence 1513
1514,"Hai trong số đó đ ã nói ở trên là:   cin  dòng input chu ẩn gắn với b àn phím, gi ống nh ư stdin c ủa C.",LTHDT_PhamVanAt.pdf - Sentence 1514
1515,"cout dòng output chu ẩn gắn với m àn hình, gi ống nh ư stdout c ủa C.",LTHDT_PhamVanAt.pdf - Sentence 1515
1516,"Hai dòng tin chu ẩn khác l à:  cerr dòng output l ỗi chuẩn gắn với m àn hình, gi ống nh ư stderr c ủa C.",LTHDT_PhamVanAt.pdf - Sentence 1516
1517,clog gi ống cerr nh ưng có thêm b ộ đệm.,LTHDT_PhamVanAt.pdf - Sentence 1517
1518,Chú ý 1:  Có th ể dùng các dòng cerr và clog để xuất ra m àn hình nh ư đã dùng đối với cout.,LTHDT_PhamVanAt.pdf - Sentence 1518
1519,"Chú ý 2:   Vì cl og có thêm b ộ đệm, n ên dữ liệu đ ược đưa vào b ộ đệm.",LTHDT_PhamVanAt.pdf - Sentence 1519
1520,Khi đầy bộ đệm th ì đưa d ữ  liệu từ bộ đệm ra d òng clog.,LTHDT_PhamVanAt.pdf - Sentence 1520
1521,Vì v ậy trước khi kết thúc xuất cần d ùng phương th ức:  clog.flush();   để đẩy dữ liệu từ bộ đệm ra clog.,LTHDT_PhamVanAt.pdf - Sentence 1521
1522,Chương tr ình sau minh ho ạ cách d ùng dòng clog.,LTHDT_PhamVanAt.pdf - Sentence 1522
1523,"Chúng ta nh ận thấy, nếu bỏ câu lệnh  clog.flush() thì s ẽ không nh ìn thấy kết quả xuất ra m àn hình khi ch ương tr ình tạm dừng bởi câu lệnh  getch().",LTHDT_PhamVanAt.pdf - Sentence 1523
1524,"// Dùng clog và flush   #include <iostream.h>   #include <conio.h>  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          267                                         tenshi3003@gmail.com  void main()   {  clrscr();   float x= -87.1500, y=23.4 5425,z=678.0;   clog.setf(ios::scientific);   clog.precision(4);   clog.fill('*');   clog << "" \n"";  clog.width(10);   clog << x;   clog << "" \n"";  clog.width(10);   clog << y;   clog << "" \n"";  clog.width(10);   clog << z;   clog.flush();   getch();   }  Bài 9.",LTHDT_PhamVanAt.pdf - Sentence 1524
1525,Xu ất ra máy in   Trong s ố 4 dòng tin chu ẩn không d òng nào g ắn với máy in.,LTHDT_PhamVanAt.pdf - Sentence 1525
1526,Nh ư vậy không thể d ùng các dòng  này đ ể xuất dữ liệu ra máy in.,LTHDT_PhamVanAt.pdf - Sentence 1526
1527,"Để xuất dữ liệu ra máy in (cũng nh ư nhập, xuất tr ên tệp) cần tạo ra  các dòng tin m ới và cho nó g ắn với thiết bị cụ thể.",LTHDT_PhamVanAt.pdf - Sentence 1527
1528,"C++ cung cấp 3 lớp stream  để làm đi ều này, đó  là các l ớp:  ifstream    dùng đ ể tạo d òng nh ập  ofstream   dùng đ ể tạo d òng xu ất       fstream    dùng đ ể tạo  d òng nh ập, d òng xu ất hoặc d òng nh ập-xuất  Mỗi lớp có 4 h àm tạo dùng đ ể khai báo các d òng tin ( đối tượng d òng tin).",LTHDT_PhamVanAt.pdf - Sentence 1528
1529,Trong m ục sau sẽ  nói  thêm v ề các h àm tạo này.,LTHDT_PhamVanAt.pdf - Sentence 1529
1530,"Để tạo một d òng xu ất và gắn nó với máy in ta có thể d ùng m ột trong các h àm tạo sau:   ofstream  Tên_dòng_tin(int fd) ;   ofstream  Tên_dòng_tin(int fd, char *buf, int n) ;   Trong đó:   + Tên_dòng_tin là tên bi ến đối t ượng kiểu ofstre am hay g ọi là tên dòng xu ất do chúng ta tự đặt.",LTHDT_PhamVanAt.pdf - Sentence 1530
1531,+ fd (file descriptor) là ch ỉ số tập tin.,LTHDT_PhamVanAt.pdf - Sentence 1531
1532,Chỉ số tập tin định sẵn đối với stdprn (máy in chuẩn) l à 4.,LTHDT_PhamVanAt.pdf - Sentence 1532
1533,+ Các tham s ố buf v à n xác đ ịnh một v ùng nh ớ n byte do buf trỏ tới.,LTHDT_PhamVanAt.pdf - Sentence 1533
1534,V ùng nh ớ sẽ đ ược dùng làm  bộ đệm cho d òng xu ất.,LTHDT_PhamVanAt.pdf - Sentence 1534
1535,Ví dụ 1  câu l ệnh:  ofstream  prn(4) ;  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          268                                         tenshi3003@gmail.com  sẽ tạo d òng tin xu ất prn v à gắn nó với máy in chuẩn.,LTHDT_PhamVanAt.pdf - Sentence 1535
1536,D òng prn s ẽ có bộ đệm mặc định.,LTHDT_PhamVanAt.pdf - Sentence 1536
1537,"Dữ liệu  trước hết chuyển v ào bộ đệm, khi đầy bộ đệm th ì dữ liệu sẽ đ ược đẩy từ bộ đệm ra d òng prn.",LTHDT_PhamVanAt.pdf - Sentence 1537
1538,Để  chủ động y êu cầu đẩy dữ liệu từ bộ đệm ra d òng prn có th ể sử dụng ph ương th ức flush hoặc bộ  phận định dạng flush.,LTHDT_PhamVanAt.pdf - Sentence 1538
1539,"Cách viết nh ư sau:   prn.flush();  // Phương th ức  prn << flush ; // B ộ phận định dạng   Các câu l ệnh sau sẽ xuất dữ liệu ra prn (máy in) v à ý ngh ĩa của chúng nh ư sau:  prn << “ \nTong = “ <<  (4+9) ;  // Đưa m ột dòng vào b ộ đệm   prn << “ \nTich =“ << (4*9); // Đưa ti ếp dòng th ứ 2 v ào bộ đệm   prn.flush();  // Đ ẩy dữ liệu từ bộ đệm ra máy in  (in 2 d òng)                         Các câu l ệnh d ưới đây cũng xuất dữ liệu ra máy in nhưng s ẽ in từng d òng m ột:   prn << “ \nTong = “ <<  (4+9) << flush ;  // In m ột dòng  prn << “ \nTich =  “ << (4*9) ;  << flush  // In dòng th ứ hai   Ví dụ 2:  Các câu l ệnh  char buf[1000] ;   ofstream  prn(4,buf,1000) ;   sẽ tạo d òng tin xu ất prn v à gắn nó với máy in chu ẩn.",LTHDT_PhamVanAt.pdf - Sentence 1539
1540,D òng xu ất prn sử dụng 1000 byte của mảng  buf làm b ộ đệm.,LTHDT_PhamVanAt.pdf - Sentence 1540
1541,"Các câu lệnh d ưới đây cũng xuất dữ liệu ra máy in:   prn << “ \nTong = “ <<  (4+9) ;  // Đưa d ữ liệu v ào bộ đệm   prn << “ \nTich =  “ << (4*9) ;   // Đưa d ữ liệu v ào bộ đệm   prn.flush() ;  / / Xuất 2 d òng ( ở bộ đệm) ra máy in   Chú ý:  Trước khi kết thúc ch ương tr ình, d ữ liệu từ bộ đệm sẽ đ ược tự động đẩy ra máy in.",LTHDT_PhamVanAt.pdf - Sentence 1541
1542,Chương trinh minh ho ạ: Chương tr ình d ưới đây t ương t ự như chương tr ình trong m ục 7.3 (chỉ  sửa đổi ph ương th ức xuất) nh ưng thay vi ệc xuất ra m àn hình b ằng xuất ra máy in.,LTHDT_PhamVanAt.pdf - Sentence 1542
1543,"//CT7_08B.CPP   // Xuat ra may in   // Bo phan dinh dang   // Ham dinh dang   #include <iostream.h>   #include <iomanip.h>   #include <conio.h>   struct TS   {  int sobd;   char ht[25];   float dt,dl,dh,td;   } ;  class TSINH   {  private:   TS *ts; Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          269                                         tenshi3003@gmail.com  int sots;   public:   TSINH()   {  ts=NULL;   sots=0;   }  TSINH(int n)   {  ts=new TS[n+1];   sots=n;   }  ~TSINH()   {  if (sots)   {  sots=0;   ts = NULL;   }  }  void nhap();   void sapxep();   void xuat();   } ;  void TSINH::nhap()   {  if (sots)   for (int i=1; i<=sots; ++i)   {  cout << "" \nThi sinh ""<< i << "": "" ;   cout << "" \nSo bao danh: "" ;   cin >> ts[i].sobd;   cin.ignore();   cout << ""Ho ten: "" ;   cin.get(ts[i].ht,25);   cout << ""Diem toan, ly , hoa: "" ;   cin >> ts[i].dt >> ts[i].dl >> ts[i].dh;   ts[i].td = ts[i].dt + ts[i].dl + ts[i].dh;   } Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          270                                         tenshi3003@gmail.com  }  void T SINH::sapxep()   {  int i,j;   for (i=1; i< sots; ++i)   for (j=i+1; j<= sots; ++j)   if (ts[i].td < ts[j].td)   {  TS tg;   tg=ts[i];   ts[i]=ts[j];   ts[j]=tg;   }  }  void TSINH::xuat()   {  ostream prn(4);   if (sots)   {  prn << "" \nDanh sach thi sinh:"" ;   prn.precision(1);   prn << s etiosflags(ios::left);   prn << "" \n"" << setw(20) <<""Ho ten"" << setw(8)   << ""So BD""<< setw(10)   << ""Tong diem"";   for (int i=1; i<=sots; ++i)   prn << "" \n"" << setw(20)<<setiosflags(ios::left) <<ts[i].ht <<   setw(4) << setfill('0')<<setiosflags(ios::right)<< ts[i] .sobd   << ""    "" << setfill(32) <<setiosflags(ios::left|ios::showpoint)   <<setw(10)<< ts[i].td;   }  }  void main()   {  int n;   clrscr();   cout << "" \nSo thi sinh: "";   cin>>n;   TSINH *t = new TSINH(n);   t->nhap() ;   t->sapxep();   t->xuat();  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          271                                         tenshi3003@gmail.com  getch();   delete t;   }  Bài 10.",LTHDT_PhamVanAt.pdf - Sentence 1543
1544,Là m việc với tệp   10.1.,LTHDT_PhamVanAt.pdf - Sentence 1544
1545,"Các l ớp d ùng đ ể nhập, xuất dữ liệu l ên tệp  Như đ ã nói ở trên, C++ cung c ấp 4 d òng tin chu ẩn để l àm vi ệc với  b àn phím và màn hình.",LTHDT_PhamVanAt.pdf - Sentence 1545
1546,Mu ốn  nhập xuất l ên tệp chúng ta cần tạo các d òng tin m ới (khai báo các đối t ượng Stream) v à gắn chúng  với một tệp cụ thể.,LTHDT_PhamVanAt.pdf - Sentence 1546
1547,"C++ cung cấp 3 lớp stream để l àm đi ều này, đó là các l ớp:  ofstream  dùng đ ể tạo các d òng xu ất (ghi tệp)             ifstream   dùng đ ể tạo các d òng nh ập (đọc tệp)   fstream     dùng đ ể tạo các d òng nh ập, d òng xu ất hoặc d òng nh ập-xuất  Sơ đồ dẫn xuất các lớp nh ư sau:       ios          ostream   fstreambase   istream         ofstream     ifstream           fstream     10.2.",LTHDT_PhamVanAt.pdf - Sentence 1547
1548,Ghi d ữ liệu l ên tệp  Thủ tục ghi dữ liệu l ên tệp nh ư sau:   1.,LTHDT_PhamVanAt.pdf - Sentence 1548
1549,Dùng l ớp ofstream để tạo ra một d òng xu ất và gắn nó với một tệp  cụ thể.,LTHDT_PhamVanAt.pdf - Sentence 1549
1550,Khi đó việc xuất dữ  liệu ra d òng này đồng nghĩa với việc ghi dữ liệu l ên tệp.,LTHDT_PhamVanAt.pdf - Sentence 1550
1551,2.,LTHDT_PhamVanAt.pdf - Sentence 1551
1552,Th ực hiện xuất dữ liệu ra d òng xu ất vừa tạo nh ư thể xuất dữ liệu ra d òng xu ất chuẩn cout.,LTHDT_PhamVanAt.pdf - Sentence 1552
1553,10.3.,LTHDT_PhamVanAt.pdf - Sentence 1553
1554,Đ ọc dữ liệu từ tệp   Thủ tục đọc dữ liệu từ tệp nh ư sau:   1.,LTHDT_PhamVanAt.pdf - Sentence 1554
1555,Dùng l ớp ifs tream đ ể tạo ra một d òng nh ập và gắn nó với một tệp cụ thể.,LTHDT_PhamVanAt.pdf - Sentence 1555
1556,Khi đó việc nhập dữ  liệu từ d òng này đồng nghĩa với việc đọc dữ liệu từ tệp.,LTHDT_PhamVanAt.pdf - Sentence 1556
1557,2.,LTHDT_PhamVanAt.pdf - Sentence 1557
1558,Th ực hiện nhập dữ liệu từ d òng nh ập vừa tạo nh ư thể nhập dữ liệu từ d òng nh ập chuẩn cin.,LTHDT_PhamVanAt.pdf - Sentence 1558
1559,10.4.,LTHDT_PhamVanAt.pdf - Sentence 1559
1560,Đ ọc - ghi d ữ liệu đồn g thời  tr ên tệp  Thủ tục đọc -ghi d ữ liệu đồng thời tr ên tệp nh ư sau:    1.,LTHDT_PhamVanAt.pdf - Sentence 1560
1561,Dùng l ớp fstream để tạo ra một d òng nh ập-xuất và gắn nó với một tệp cụ thể.,LTHDT_PhamVanAt.pdf - Sentence 1561
1562,2.,LTHDT_PhamVanAt.pdf - Sentence 1562
1563,Th ực hiện nhập dữ liệu từ d òng nh ập-xuất vừa tạo nh ư thể nhập dữ liệu từ d òng nh ập chuẩn  cin.,LTHDT_PhamVanAt.pdf - Sentence 1563
1564,3.,LTHDT_PhamVanAt.pdf - Sentence 1564
1565,Th ực hiện xuất dữ liệu ra d òng nh ập-xuất vừa tạo nh ư thể xuất dữ liệu ra d òng xu ất chuẩn  cout.,LTHDT_PhamVanAt.pdf - Sentence 1565
1566,Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          272                                         tenshi3003@gmail.com  Nhận xét:  Như v ậy:  1.,LTHDT_PhamVanAt.pdf - Sentence 1566
1567,Vi ệc xuất dữ liệu ra máy in hoặc l ên tệp được thực hiện ho àn toàn gi ống nh ư xuất dữ liệu ra  dòng xu ất chuẩn cout (m àn hình).,LTHDT_PhamVanAt.pdf - Sentence 1567
1568,2.,LTHDT_PhamVanAt.pdf - Sentence 1568
1569,Vi ệc đọc dữ liệu từ tệp đ ược thực hiện ho àn toàn gi ống nh ư nhập dữ liệu từ d òng nh ập chuẩn  cin (bàn phím).,LTHDT_PhamVanAt.pdf - Sentence 1569
1570,Bài 11.,LTHDT_PhamVanAt.pdf - Sentence 1570
1571,Ghi  d ữ liệu l ên tệp  11.1.,LTHDT_PhamVanAt.pdf - Sentence 1571
1572,L ớp ofstream   Để ghi dữ liệu l ên tệp chúng ta sử dụng lớp ofstream.,LTHDT_PhamVanAt.pdf - Sentence 1572
1573,Lớp ofstream thừa kế các ph ương th ức  của các lớp ios v à ostream .,LTHDT_PhamVanAt.pdf - Sentence 1573
1574,Nó c ũng thừa kế ph ương th ức:  close   của lớp fstreambase.,LTHDT_PhamVanAt.pdf - Sentence 1574
1575,Ngo ài ra l ớp ofstream có th êm các hàm t ạo và các phương th ức sau:   1.,LTHDT_PhamVanAt.pdf - Sentence 1575
1576,"Hàm t ạo:  ofstream() ;   // Không đ ối  dùng đ ể tạo một đối t ượng ofstream (d òng xu ất), ch ưa gắn với tệp.",LTHDT_PhamVanAt.pdf - Sentence 1576
1577,2.,LTHDT_PhamVanAt.pdf - Sentence 1577
1578,"Hàm t ạo:  ofstream(const char *fn, int mode = ios::out,                  int prot = filebuf::openprot); dùng đ ể tạo một đối t ượng ofstream, mở tệp có t ên fn  để ghi v à gắn đối t ượng vừa tạo với tệp đ ược mở.",LTHDT_PhamVanAt.pdf - Sentence 1578
1579,+ Tham  s ố  fn cho biết t ên tệp.,LTHDT_PhamVanAt.pdf - Sentence 1579
1580,+ Tham s ố mode có giá trị mặc định l à ios::o ut (m ở để ghi).,LTHDT_PhamVanAt.pdf - Sentence 1580
1581,"Tham số n ày có th ể là một hợp của  các giá tr ị sau:   ios::binary ghi theo ki ểu nhị phân (mặc định theo kiểu văn bản)   ios::out   ghi t ệp, nếu tệp đ ã có thì nó b ị xoá   ios::app   ghi b ổ sung v ào cu ối tệp   ios::ate    chuy ển con trỏ tệp tới cuối t ệp sau khi mở tệp   ios::trunc  xoá n ội dung của tệp nếu nó tồn tại   ios::nocreate    n ếu tệp ch ưa có th ì không làm gì (b ỏ qua)   ios::noreplace    n ếu tệp đ ã có thì không làm gì (b ỏ qua)   + Tham s ố thứ ba prot quy định cấp bảo vệ của d òng tin, tham s ố này có t hể bỏ qua v ì nó đã  được gán một giá trị mặc định.",LTHDT_PhamVanAt.pdf - Sentence 1581
1582,3.,LTHDT_PhamVanAt.pdf - Sentence 1582
1583,Hàm t ạo:  ofstream(int fd);   dùng đ ể tạo một đối t ượng ofstream v à gắn nó với một tệp có chỉ số fd đang mở.,LTHDT_PhamVanAt.pdf - Sentence 1583
1584,"(Để mở v à lấy chỉ số (số hiệu) tệp có thể d ùng hàm _open, xem cu ốn Kỹ thuật Lập tr ình C c ủa  tác g iả).",LTHDT_PhamVanAt.pdf - Sentence 1584
1585,4.,LTHDT_PhamVanAt.pdf - Sentence 1585
1586,"Hàm t ạo:  ofstream(int fd, char *buf, int n);   dùng đ ể tạo một đối t ượng ofstream , gắn nó với một tệp có chỉ số fd đang mở v à sử dùng m ột vùng  nhớ n byte do buf trỏ tới l àm b ộ đệm.",LTHDT_PhamVanAt.pdf - Sentence 1586
1587,5.,LTHDT_PhamVanAt.pdf - Sentence 1587
1588,"Phương th ức:  void open(const char *fn, int mode = ios::out,  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          273                                         tenshi3003@gmail.com                   int prot = filebuf::openprot); dùng đ ể mở tệp có t ên fn đ ể ghi v à gắn nó với đối  tượng ofstream.",LTHDT_PhamVanAt.pdf - Sentence 1588
1589,Các tham số của ph ương th ức có c ùng ý ngh ĩa nh ư trong hàm t ạo    thứ 2.,LTHDT_PhamVanAt.pdf - Sentence 1589
1590,11.2.,LTHDT_PhamVanAt.pdf - Sentence 1590
1591,"Các cách ghi t ệp  Có 2 cách chính sau:   + Cách 1:  Dùng hàm t ạo 2 để xâ y dựng một d òng xu ất, mở một tệp để ghi v à gắn tệp với d òng  xuất.",LTHDT_PhamVanAt.pdf - Sentence 1591
1592,Sau đó d ùng toán t ử xuất << v à các phương th ức để xuất dữ liệu ra d òng xu ất vừa tạo nh ư thể  xuất dữ liệu ra cout (xem các mục tr ên).,LTHDT_PhamVanAt.pdf - Sentence 1592
1593,+ Cách 2:  Dùng hàm t ạo 1 để xây dựng một d òng xu ất.,LTHDT_PhamVanAt.pdf - Sentence 1593
1594,Sau đ ó dùng phương th ức open để mở  một tệp cụ thể v à cho g ắn với d òng xu ất vừa xây dựng.,LTHDT_PhamVanAt.pdf - Sentence 1594
1595,"Khi không cần l àm vi ệc với tệp n ày nữa,  chúng ta có th ể dùng phương th ức close để chấm dứt mọi r àng bu ộc giữa d òng xu ất và tệp.",LTHDT_PhamVanAt.pdf - Sentence 1595
1596,Sau đó  có th ể gắn d òng xu ất với tệp khác.,LTHDT_PhamVanAt.pdf - Sentence 1596
1597,"Th eo cách này, có th ể dùng m ột dòng xu ất (đối t ượng ofstream)  để xuất dữ liệu l ên nhi ều tệp khác nhau.",LTHDT_PhamVanAt.pdf - Sentence 1597
1598,11.3.,LTHDT_PhamVanAt.pdf - Sentence 1598
1599,Ví d ụ  Chương tr ình 1:  Chương tr ình d ưới đây sẽ nhập danh sách n thí sinh.,LTHDT_PhamVanAt.pdf - Sentence 1599
1600,"Thông tin thí sinh gồm:  Họ tên, tỉnh hoặc th ành ph ố cư trú, s ố báo danh, các điểm toán lý hoá.",LTHDT_PhamVanAt.pdf - Sentence 1600
1601,"Dữ liệu thí sinh đ ược ghi tr ên  2 tệp: Tệp DS1.DL ghi thí sinh theo thứ tự nhập  từ b àn phím, t ệp DS2.DL ghi thí sinh theo th ứ tự  giảm của tổng điểm.",LTHDT_PhamVanAt.pdf - Sentence 1601
1602,Cấu trúc của 2 tệp nh ư sau:   Dòng đầu ghi một số nguy ên bằng số thí sinh.,LTHDT_PhamVanAt.pdf - Sentence 1602
1603,Các dòng ti ếp theo ghi dữ liệu của thí sinh.,LTHDT_PhamVanAt.pdf - Sentence 1603
1604,"Mỗi thí sinh ghi tr ên 2 dòng, dòng 1 ghi h ọ tên trên  24 vị trí v à tên t ỉnh tr ên 20 v ị trí.",LTHDT_PhamVanAt.pdf - Sentence 1604
1605,"D òng 2 ghi s ố báo danh (6 vị trí), các điểm toán, lý , hoá v à tổng  điểm (mỗi điểm ghi tr ên 6 v ị trí trong đó một vị trí chứa phần phân).",LTHDT_PhamVanAt.pdf - Sentence 1605
1606,"Ch ương tr ình s ử dụng lớp TS  (Thí sinh) có 3 phương th ức: Nhập, sắp xếp v à ghi t ệp.",LTHDT_PhamVanAt.pdf - Sentence 1606
1607,Cách ghi tệp sử dụng ở đây l à cách 1: Dùn g  hàm t ạo dạng 2 của lớp ofstream.,LTHDT_PhamVanAt.pdf - Sentence 1607
1608,"Chương tr ình 2 ngay bên d ưới cũng giải quyết c ùng bài toán nêu trên nhưng s ử dụng cách ghi tệp  thứ 2 (d ùng hàm t ạo 1 v à phương th ức open)   Một điều đáng nói ở đây l à việc nhập một chuỗi ký tự (nh ư họ tên và tên t ỉnh) bằng các phương  thức get hoặc getline ch ưa đư ợc thuận tiện, v ì 2 lý do sau: th ứ  nhất l à các phương th ức này có th ể  bị ký tự chuyển d òng (còn sót trên cin) làm trôi.",LTHDT_PhamVanAt.pdf - Sentence 1608
1609,Th ứ hai l à các phương th ức này có th ể để lại một  số ký tự  tr ên dòng cin (n ếu số ký tự g õ nhi ều hơn so v ới quy định) v à các ký t ự này sẽ gây ảnh  hưởng đến các phép nhập tiếp theo.,LTHDT_PhamVanAt.pdf - Sentence 1609
1610,"Để khắc phục các nh ược điểm tr ên, chúng ta đưa vào 2 chương  trình trên hàm getstr để nhập chuỗi ký tự từ b àn phím.",LTHDT_PhamVanAt.pdf - Sentence 1610
1611,"//CT7_10.CPP   // Ghi Tep   #include <iostream.h>   #include <iomanip.h>   #include <fstream.h>   #include <conio.h>   #include <stdlib.h>   #include <ctype.h>   void getstr(char *str,int n)   {  char tg[21];   while(1)  // B ỏ qua Enter v à nhập tối đa n -1 ký t ự Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          274                                         tenshi3003@gmail.com  {  cin.get(str,n);   if (str[0])   break;   else  cin.ignore();   }  while(1) // Loại các ký tự c òn lại ra khỏi d òng nh ập cin   {  cin.get(tg,20);   if (tg[0]==0)   {  cin.ignore();   break;   }  }  }    struct TSINH   {  char ht[25];   char ttinh[21];   int sobd;   float dt,dl,dh,td;   } ;  class TS   {  private:   int sots;   TSINH *ts;   public:   TS()  {  sots=0;   ts = NUL L;  }  void nhap();   void sapxep();   void ghitep(char *ttep);   }; Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          275                                         tenshi3003@gmail.com  void TS::nhap()   {  cout << "" \n So thi sinh: "" ;   cin >> sots ;   int n=sots;   ts = new TSINH[n+1];   for (int i=1; i<=n; ++i)   {  cout << "" \n Nhap thi sinh thu: "" << i << endl;   cout << ""Ho ten: "" ;   getstr (ts[i].ht,25);   cout << ""Tinh hoac thanh pho: "" ;   getstr(ts[i].ttinh,21);   cout << ""So bao danh: "" ;   cin >> ts[i].sobd ;   cout << ""Cac diem toan, ly, hoa: "" ;   cin >> ts[i].dt >> ts[i].dl >> ts[i].dh ;   ts[i].td =ts[i].dt + ts[i].dl + ts[i].dh ;   }  }  void TS::sa pxep()   {  int n = sots;   for (int i=1; i< n; ++i)   for (int j=i+1; j<= n; ++j)   if (ts[i].td < ts[j].td)   {  TSINH tg = ts[i];   ts[i] = ts[j];   ts[j] = tg;   }  }  void TS::ghitep(char *ttep)   {  ofstream f(ttep);   f << sots ;   f << setprecision(1) << setiosflags(ios::sho wpoint);   for (int i=1; i<=sots; ++i)   {  f << endl << setw(24) << ts[i].ht << setw(20) << ts[i].ttinh ;  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          276                                         tenshi3003@gmail.com  f << endl << setw(6) << ts[i].sobd   << setw(6) << ts[i].dt   << setw(6) << ts[i].dl   << setw(6) << ts[i].dh   << setw(6) << ts[i].td ;   }  f.close();   }  void main( )  {  clrscr();   TS t;   t.nhap();   t.ghitep(""DS1.DL"");   t.sapxep();   t.ghitep(""DS2.DL"");   cout << "" \n Hoan thanh"";   getch();   }  Chương tr ình 2:   //CT7_11.CPP   // Ghi Tep   #include <iostream.h>   #include <iomanip.h>   #include <fstream.h>   #include <conio.h>   #include <stdl ib.h>   #include <ctype.h>   void getstr(char *str,int n)   {  char tg[21];   while(1)   {  cin.get(str,n);   if (str[0])   break;   else  cin.ignore();   } Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          277                                         tenshi3003@gmail.com  while(1)   {  cin.get(tg,20);   if (tg[0]==0)   {  cin.ignore();   break;   }  }  }  struct TSINH   {  char ht[25];   char ttinh[21];   int so bd;  float dt,dl,dh,td;   } ;  class TS   {  private:   int sots;   TSINH *ts;   public:   TS()  {  sots=0;   ts = NULL;   }  void nhap();   void sapxep();   void ghitep(char *ttep);   };  void TS::nhap()   {  cout << "" \n So thi sinh: "" ;   cin >> sots ;   int n=sots;   ts = new TSINH[n+1];   for (int i=1; i<=n; ++i)   { Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          278                                         tenshi3003@gmail.com  cout << "" \n Nhap thi sinh thu: "" << i << endl;   cout << ""Ho ten: "" ;   getstr(ts[i].ht,25);   cout << ""Tinh hoac thanh pho: "" ;   getstr(ts[i].ttinh,21);   cout << ""So bao danh: "" ;   cin >> ts[i].sobd ;   cout << ""Cac diem toan, ly, hoa: "" ;   cin >> ts[i].dt >> ts[i].dl >> ts[i].dh ;   ts[i].td =ts[i].dt + ts[i].dl + ts[i].dh ;   }  }  void TS::sapxep()   {  int n = sots;   for (int i=1; i< n; ++i)   for (int j=i+1; j<= n; ++j)   if (ts[i].td < ts[j].td)   {  TSINH tg = ts[i];   ts[i] = ts[j];   ts[j] = tg;   }  }  void TS::ghitep(char *ttep)   {  ofstream f;   f.open(ttep,ios::out|ios::noreplace);   if (f.bad())   {  cout << "" \nTep "" << ttep << "" da ton tai"";   cout << "" \nCo ghi de?",LTHDT_PhamVanAt.pdf - Sentence 1611
1612,"- C/K"";   int ch=getch();   if (toupper(ch)=='C')   {  f.close();   f.open(ttep) ;   }  else  exit(1);  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          279                                         tenshi3003@gmail.com  }  f << sots  ;  f << setprecision(1) << setiosflags(ios::showpoint);   for (int i=1; i<=sots; ++i)   {  f << endl << setw(24) << ts[i].ht << setw(20) << ts[i].ttinh ;   f << endl << setw(6) << ts[i].sobd   << setw(6) << ts[i].dt   << setw(6) << ts[i].dl   << setw(6) << ts[i].dh   << setw(6) << ts[i].td ;   }  f.close();   }  void main()   {  clrscr();   TS t;   t.nhap();   t.ghitep(""DS1.DL"");   t.sapxep();   t.ghitep(""DS2.DL"");   cout << "" \n Hoan thanh"";   getch();   }  Bài 12.",LTHDT_PhamVanAt.pdf - Sentence 1612
1613,Đ ọc dữ liệu từ tệp   12.1.,LTHDT_PhamVanAt.pdf - Sentence 1613
1614,L ớp ifstream   Để đọc dữ liệu từ tệp chúng ta sử dụng lớp if stream.,LTHDT_PhamVanAt.pdf - Sentence 1614
1615,L ớp ifstream thừa kế các ph ương th ức của  các lớp ios v à istream.,LTHDT_PhamVanAt.pdf - Sentence 1615
1616,Nó c ũng thừa kế ph ương th ức:  close   của lớp fstreambase.,LTHDT_PhamVanAt.pdf - Sentence 1616
1617,Ngo ài ra l ớp ifstream có th êm các hàm t ạo và các phương th ức sau:   1.,LTHDT_PhamVanAt.pdf - Sentence 1617
1618,"Hàm t ạo:  ifstream() ;   // Không đ ối  dùng đ ể tạo một đối t ượng ifstream (d òng nh ập), ch ưa gắn với tệp.",LTHDT_PhamVanAt.pdf - Sentence 1618
1619,2.,LTHDT_PhamVanAt.pdf - Sentence 1619
1620,"Hàm t ạo:  ifstream(const char *fn, int mode = ios::in,                       int prot = filebuf::openprot);   dùng đ ể tạo một đối t ượng ifstream, mở tệp có t ên fn đ ể đọc v à gắn đối t ượng vừa tạo với tệp đ ược  mở.",LTHDT_PhamVanAt.pdf - Sentence 1620
1621,Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          280                                         tenshi3003@gmail.com  + Tham  s ố  fn cho biết t ên tệp.,LTHDT_PhamVanAt.pdf - Sentence 1621
1622,+ Tham s ố mode có giá trị mặc định l à ios::in (m ở để đọc).,LTHDT_PhamVanAt.pdf - Sentence 1622
1623,"Tham số n ày có th ể là một hợp của  các giá tr ị sau:   ios::binary đ ọc theo kiểu nhị phân (mặc định theo kiểu văn bản)   ios::ate      chuy ển con trỏ tệp tới cuối tệp sau  khi m ở tệp   + Tham s ố thứ ba prot quy định cấp bảo vệ của d òng tin, tham s ố này có th ể bỏ qua v ì nó đã  được gán một giá trị mặc định.",LTHDT_PhamVanAt.pdf - Sentence 1623
1624,3.,LTHDT_PhamVanAt.pdf - Sentence 1624
1625,Hàm t ạo:  ifstream(int fd);   dùng đ ể tạo một đối t ượng ifstream v à gắn nó với một tệp có chỉ số fd đang mở.,LTHDT_PhamVanAt.pdf - Sentence 1625
1626,"(Để mở v à lấy chỉ số (số hiệu) tệp có thể d ùng hàm _open, xem cu ốn Kỹ thuật Lập tr ình C c ủa  tác gi ả)  4.",LTHDT_PhamVanAt.pdf - Sentence 1626
1627,"Hàm t ạo:  ifstream(int fd, char *buf, int n);   dùng đ ể tạo một đối t ượng ifstream , gắn nó với một tệp có chỉ số fd đang mở v à sử dùng m ột vùng  nhớ n byte do buf trỏ t ới làm b ộ đệm.",LTHDT_PhamVanAt.pdf - Sentence 1627
1628,5.,LTHDT_PhamVanAt.pdf - Sentence 1628
1629,"Phương th ức:  void open(const char *fn, int mode = ios::in,                        int prot = filebuf::openprot);   dùng đ ể mở tệp có t ên fn đ ể đọc v à gắn nó với đối t ượng ifstream.",LTHDT_PhamVanAt.pdf - Sentence 1629
1630,Các tham số của ph ương th ức có  cùng ý ngh ĩa nh ư trong hàm t ạo   thứ 2.,LTHDT_PhamVanAt.pdf - Sentence 1630
1631,12.2.,LTHDT_PhamVanAt.pdf - Sentence 1631
1632,"Các cách đ ọc tệp   Có 2 cách chính sau:   + Cách 1:  Dùng hàm t ạo 2 để xây dựng một d òng nh ập, mở một tệp để đọc v à gắn tệp với d òng  nhập.",LTHDT_PhamVanAt.pdf - Sentence 1632
1633,Sau đó d ùng toán t ử nhập >> v à các phương th ức để nhập dữ liệu từ d òng nh ập vừa tạo nh ư  thể nhập dữ liệu  từ cin (xem các mục tr ên)  + Cách 2:  Dùng hàm t ạo 1 để xây dựng một d òng nh ập.,LTHDT_PhamVanAt.pdf - Sentence 1633
1634,Sau đó d ùng phương th ức open để mở  một tệp cụ thể v à cho g ắn với d òng nh ập vừa xây dựng.,LTHDT_PhamVanAt.pdf - Sentence 1634
1635,"Khi không cần l àm vi ệc với tệp n ày nữa,  chúng ta có th ể dùng phương th ức close để chấm d ứt mọi r àng bu ộc giữa d òng nh ập và tệp.",LTHDT_PhamVanAt.pdf - Sentence 1635
1636,Sau đó  có th ể gắn d òng nh ập với tệp khác.,LTHDT_PhamVanAt.pdf - Sentence 1636
1637,"Theo cách n ày, có th ể dùng m ột dòng nh ập (đối t ượng ifstream)  để nhập dữ liệu từ nhiều tệp khác nhau.",LTHDT_PhamVanAt.pdf - Sentence 1637
1638,12.3.,LTHDT_PhamVanAt.pdf - Sentence 1638
1639,"Ki ểm tra sự tồn tại của tệp, kiểm tra cuối tệp   + Khi m ở một tệp để  đọc m à tệp không tồn tại th ì sẽ phát sinh lỗi, khi đó ph ương th ức bad trả về  giá tr ị khác không.",LTHDT_PhamVanAt.pdf - Sentence 1639
1640,"Ví dụ để kiểm tra xem tệp DSTS (Danh sách thí sinh) đ ã  tồn tại hay không có  thể dùng đo ạn ch ương tr ình:  ifstream fin(“DSTS”);   if (fin.bad())   {  cout << “ \nTep  DSTS không t ồn tai”;   exit(1);   }  + Trong quá trình đọc, con trỏ tệp sẽ chuyển dần về cuối tệp.",LTHDT_PhamVanAt.pdf - Sentence 1640
1641,Khi con trỏ tệp đ ã ở cuối tệp (hết  dữ liệu) m à vẫn thực hiện một lệnh đọc th ì phương th ức eof sẽ cho giá trị khác không.,LTHDT_PhamVanAt.pdf - Sentence 1641
1642,"Ch ương tr ình Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          281                                         tenshi3003@gmail.com  dưới đây d ùng phương th ức eof để xác định độ d ài (số byte) của tệp TC.EXE (chú ý cần d ùng ki ểu  đọc nhị phân):   //CT7_14.CPP   // Do dai tep   #include <iostream.h>   #include <fstream.h>   #include <conio.h>   #include <stdlib.h>   void main()   {  clrscr();   long dd=0;     char ch;   ifstream f(""TC.E XE"",ios::in | ios::binary);   if (f.bad())   {  cout << "" \nTep TC.EXE khong ton tai"";   getch();   exit(1);   }  while(f.get(ch),!f.eof()) ++dd;   cout << "" \n Do dai TC.EXE: "" << dd;   getch();   }  12.4.",LTHDT_PhamVanAt.pdf - Sentence 1642
1643,Ví d ụ  Chương tr ình d ưới đây sẽ:   + Đọc danh sách thí sinh từ tệp D S1.DL  do chương tr ình trong muc bài 11 tạo ra.,LTHDT_PhamVanAt.pdf - Sentence 1643
1644,+ In danh sách thí sinh v ừa đọc.,LTHDT_PhamVanAt.pdf - Sentence 1644
1645,+ Sắp xếp dẫy thí sinh (vừa nhập từ tệp) theo thứ tự giảm của tổng điểm.,LTHDT_PhamVanAt.pdf - Sentence 1645
1646,"+ Ghi danh sách thí sinh sau khi s ắp xếp l ên tệp DS3.DL   + Đọc danh sách thí sinh từ tệp DS3.DL   + In danh  sách thí sinh đ ọc từ tệp DS3.DL   Chương tr ình s ử dụng lớp TS (Thí sinh) có 4 ph ương th ức:  void xuat();   void sapxep();   void ghitep(char *ttep);   void doctep(char *ttep);   //CT7_12.CPP   // Doc tep   #include <iostream.h>   #include <iomanip.h>  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          282                                         tenshi3003@gmail.com  #include <fstream.h>   #include <conio.h>   #include <stdlib.h>   #include <ctype.h>   struct TSINH   {  char ht[25];   char ttinh[21];   int sobd;   float dt,dl,dh,td;   } ;  class TS   {  private:   int sots;   TSINH *ts;   public:   TS()  {  sots=0;   ts = NULL;   }  void xuat();   void sapxep();   void ghitep(char  *ttep);   void doctep(char *ttep);   };  void TS::xuat()   {  cout << "" \n\nSo thi sinh: "" << sots;   cout << setprecision(1) << setiosflags(ios::showpoint);   for (int i=1; i<=sots; ++i)   {  cout << "" \nThi sinh thu: "" << i ;   cout << "" \nHo ten: "" << ts[i].ht ;   cout << "" \nTinh - thanh pho: "" << ts[i].ttinh ;   cout << "" \nSo bao danh: "" << ts[i].sobd ;   cout << "" \nCac diem toan, ly, hoa: ""   << setw(5) << ts[i].dt   << setw(5) << ts[i].dl  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          283                                         tenshi3003@gmail.com  << setw(5) << ts[i].dh ;   cout << "" \nTong diem: "" << ts[i].td ;   }  }  void TS::sapxep()   {  int n = sots;   for (int i=1; i< n; ++i)   for (int j=i+1; j<= n; ++j)   if (ts[i].td < ts[j].td)   {  TSINH tg = ts[i];   ts[i] = ts[j];   ts[j] = tg;   }  }  void TS::ghitep(char *ttep)   {  ofstream f;   f.open(ttep,ios::out|ios::noreplace);   if (f.bad())   {  cout << "" \nTep "" << tte p << "" da ton tai"";   cout << "" \nCo ghi de?",LTHDT_PhamVanAt.pdf - Sentence 1646
1647,"- C/K"";   int ch=getch();   if (toupper(ch)=='C')   {  f.close();   f.open(ttep) ;   }  else  exit(1);   }  f << sots ;   f << setprecision(1) << setiosflags(ios::showpoint);   for (int i=1; i<=sots; ++i)   {  f << endl << setw(24) << ts [i].ht << setw(20) << ts[i].ttinh ;   f << endl << setw(6) << ts[i].sobd   << setw(6) << ts[i].dt  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          284                                         tenshi3003@gmail.com  << setw(6) << ts[i].dl   << setw(6) << ts[i].dh   << setw(6) << ts[i].td ;   }  f.close();   }  void TS::doctep(char *ttep)   {  ifstream f;   f.open(ttep);   if (f.bad())   {  cout << "" \nTep "" << ttep << "" khong ton tai"";   getch();   exit(1);   }  f >> sots ;   f.ignore();   if (ts!=NULL) delete ts;   ts = new TSINH[sots+1];   for (int i=1; i<=sots; ++i)   {  f.get(ts[i].ht,25).get(ts[i].ttinh,21); ;   f >> ts[i].sobd >> ts[i].dt >> ts[i].dl   >> ts[i].d h  >> ts[i].td ;   f.ignore();   }  f.close();   }  void main()   {  clrscr();   TS t;   t.doctep(""DS1.DL"");   t.xuat();   t.sapxep();   t.ghitep(""DS3.DL"");   t.doctep(""DS3.DL"");   t.xuat();   cout << "" \n Hoan thanh"";   getch();  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          285                                         tenshi3003@gmail.com  }  Bài 13.",LTHDT_PhamVanAt.pdf - Sentence 1647
1648,Đ ọc ghi đồng thời tr ên  tệp  13.1.,LTHDT_PhamVanAt.pdf - Sentence 1648
1649,"L ớp fstream   Để đọc ghi đồng thời tr ên tệp, chúng ta sử dụng lớp fstream.",LTHDT_PhamVanAt.pdf - Sentence 1649
1650,Lớp fstream thừa kế các ph ương  thức của các lớp ofstream v à ifstream.,LTHDT_PhamVanAt.pdf - Sentence 1650
1651,Ngoài ra l ớp fstream có các h àm tạo và phương th ức sau:   1.,LTHDT_PhamVanAt.pdf - Sentence 1651
1652,"Hàm t ạo:  fstream() ;   // Không đ ối  dùng đ ể tạo một đối t ượng fstr eam (dòng nh ập-xuất), ch ưa gắn với tệp.",LTHDT_PhamVanAt.pdf - Sentence 1652
1653,2.,LTHDT_PhamVanAt.pdf - Sentence 1653
1654,"Hàm t ạo:  fstream(const char *fn, int mode,                 int prot = filebuf::openprot);   dùng đ ể tạo một đối t ượng fstream, mở tệp có t ên fn và g ắn đối t ượng vừa tạo với tệp đ ược mở.",LTHDT_PhamVanAt.pdf - Sentence 1654
1655,+ Tham  s ố  fn cho biết t ên tệp.,LTHDT_PhamVanAt.pdf - Sentence 1655
1656,+ Tham s ố mode quy định các kiểu truy nhập v à có th ể là tổ hợp của các giá trị sau:   ios::binary  đ ọc-ghi theo ki ểu nhị phân (mặc định theo kiểu văn bản).,LTHDT_PhamVanAt.pdf - Sentence 1656
1657,"ios::out   ghi t ệp, nếu tệp đ ã có thì nó b ị xoá   ios::in    đ ọc tệp   ios::app   ghi b ổ sung v ào cu ối tệp  ios::ate    chuy ển con trỏ tệp về cuối sau khi mở   ios::trunc  xoá n ội dung của tệp nếu nó tồn tạI   ios::nocreate    n ếu tệp ch ưa có th ì không làm gì (b ỏ qua)   ios::noreplace    n ếu tệp đ ã có thì không làm gì (b ỏ qua)   Chú ý:    + Tham s ố mode không có giá t rị mặc định.",LTHDT_PhamVanAt.pdf - Sentence 1657
1658,"+ Tham s ố thứ ba prot quy định cấp bảo vệ của d òng tin, tham s ố này có th ể bỏ qua v ì nó đã  được gán một giá trị mặc định.",LTHDT_PhamVanAt.pdf - Sentence 1658
1659,3.,LTHDT_PhamVanAt.pdf - Sentence 1659
1660,Hàm t ạo:  fstream(int fd);   dùng đ ể tạo một đối t ượng fstream v à gắn nó với một tệp có chỉ số fd đang mở.,LTHDT_PhamVanAt.pdf - Sentence 1660
1661,"(Để mở v à lấy chỉ số (số hiệu) tệp có thể d ùng hàm _open, xem cu ốn Kỹ thuật Lập tr ình C c ủa  tác gi ả)  4.",LTHDT_PhamVanAt.pdf - Sentence 1661
1662,"Hàm t ạo:  fstream(int fd, char *buf, int n);   dùng đ ể tạo một đối t ượng fstream , gắn nó với một tệp có chỉ số fd đang mở v à sử dùng m ột vùng  nhớ n byte do buf trỏ tới làm b ộ đệm.",LTHDT_PhamVanAt.pdf - Sentence 1662
1663,5.,LTHDT_PhamVanAt.pdf - Sentence 1663
1664,"Phương th ức:  void open(const char *fn, int mode,                     int prot = filebuf::openprot);   dùng đ ể mở tệp có t ên fn và g ắn nó với đối t ượng fstream.",LTHDT_PhamVanAt.pdf - Sentence 1664
1665,Các tham số của ph ương th ức có c ùng ý  nghĩa nh ư trong hàm t ạo thứ 2.,LTHDT_PhamVanAt.pdf - Sentence 1665
1666,Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          286                                         tenshi3003@gmail.com  Chú ý:  Tham s ố mode không có giá tr ị mặc định.,LTHDT_PhamVanAt.pdf - Sentence 1666
1667,13.2.,LTHDT_PhamVanAt.pdf - Sentence 1667
1668,"Các cách đ ọc-ghi đ ồng thời tr ên tệp  Có 2 cách chính sau:   + Cách 1:  Dùng hàm t ạo 2 để xây dựng một d òng nh ập-xuất, mở một tệp để đọc -ghi và g ắn tệp  với dòng nh ập-xuất.",LTHDT_PhamVanAt.pdf - Sentence 1668
1669,"Sau đó d ùng toán t ử nhập >>  ,  toán tử xuất >> v à các phương th ức nhập, xuất  để nhập, xuất dữ liệu ra d ùng nh ập-xuất vừa tạo (nh ư đối với các d òng chu ẩn cin v à cout).",LTHDT_PhamVanAt.pdf - Sentence 1669
1670,"Ví d ụ:  fstream f(“DU_LIEU”, ios::in | ios::out) ;   + Cách 2:  Dùng hàm t ạo 1 để xây dựng một d òng nh ập-xuất.",LTHDT_PhamVanAt.pdf - Sentence 1670
1671,Sau đó d ùng phương th ức open để   mở một tệp cụ thể (để đọc v à ghi) và cho g ắn với d òng nh ập-xuất vừa xây dựng.,LTHDT_PhamVanAt.pdf - Sentence 1671
1672,"Khi không cần l àm  việc với tệp n ày nữa, chúng ta có thể d ùng phương th ức close để chấm dứt mọi r àng bu ộc giữa d òng  nhập-xuất và tệp.",LTHDT_PhamVanAt.pdf - Sentence 1672
1673,Sau đó có thể gắn d òng nh ập-xuất với tệp khá c.,LTHDT_PhamVanAt.pdf - Sentence 1673
1674,"Theo cách này, có th ể dùng m ột  dòng nh ập-xuất (đối t ượng fstream) để đọc -ghi d ữ liệu từ nhiều tệp khác nhau.",LTHDT_PhamVanAt.pdf - Sentence 1674
1675,"Ví dụ:  fstream f;   f.open(“DU_LIEU”, ios::in | ios::out) ;   13.3.",LTHDT_PhamVanAt.pdf - Sentence 1675
1676,Di chuy ển con trỏ tệp   13.3.1.,LTHDT_PhamVanAt.pdf - Sentence 1676
1677,"Đ ể di chuyển con trỏ tệp tr ên dòng xu ất, chúng t a sử dụng các ph ương th ức sau (của  lớp ostream) :   1.",LTHDT_PhamVanAt.pdf - Sentence 1677
1678,Phương th ức  ostream& seekp(long n) ;      sẽ chuyển con trỏ tệp tới vị trí  (byte) thứ n (số thứ tự các byte tính   từ 0).,LTHDT_PhamVanAt.pdf - Sentence 1678
1679,2.,LTHDT_PhamVanAt.pdf - Sentence 1679
1680,"Phương th ức  ostream& seekp(long offset, seek_dir dir) ;       sẽ chuyển con trỏ  tệp tới vị trí offset  kể từ vị trí xuất phát dir.",LTHDT_PhamVanAt.pdf - Sentence 1680
1681,"Giá tr ị của offset  có th ể âm, c òn dir  có th ể nhận một trong các giá trị sau:   ios::beg   xu ất phát từ đầu tệp   ios::end   xu ất phát từ cuối tệp   ios::cur    xu ất phát từ vị trí hiện tại của con trỏ tệp   3.",LTHDT_PhamVanAt.pdf - Sentence 1681
1682,Phư ơng th ức  long teelp() ;       cho bi ết vị trí hiện tại của con trỏ tệp.,LTHDT_PhamVanAt.pdf - Sentence 1682
1683,13.3.2.,LTHDT_PhamVanAt.pdf - Sentence 1683
1684,"Đ ể di chuyển con trỏ tệp tr ên dòng nh ập, chúng ta s ử dụng các ph ương th ức sau (của  lớp istream):   4.",LTHDT_PhamVanAt.pdf - Sentence 1684
1685,Phương th ức  istream& seekg(long n) ;      sẽ chuyển con trỏ tệp tới vị trí  (b yte) th ứ n (số thứ tự các byte tính   từ 0)   5.,LTHDT_PhamVanAt.pdf - Sentence 1685
1686,"Phương th ức  istream& seekg(long offset, seek_dir dir) ;       sẽ chuyển con trỏ tệp tới vị trí offset  kể từ vị trí xuất phát dir.",LTHDT_PhamVanAt.pdf - Sentence 1686
1687,"Giá tr ị của offset  có th ể âm, c òn dir  có th ể nhận một trong các giá trị sau:  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          287                                         tenshi3003@gmail.com  ios::beg   xu ất phát từ đầu tệp   ios::end   xu ất phát từ cuối tệp   ios::cur    xu ất phát vị trí hiện tại của con trỏ tệp   6.",LTHDT_PhamVanAt.pdf - Sentence 1687
1688,Phương th ức  long teelg() ;       cho bi ết vị trí hiện tại của con trỏ tệp.,LTHDT_PhamVanAt.pdf - Sentence 1688
1689,13.3.3.,LTHDT_PhamVanAt.pdf - Sentence 1689
1690,"Đ ể di chuyển con trỏ tệp tr ên dòng nh ập-xuất, chúng ta có th ể sử dụng cả 6 ph ương  thức nêu trên.",LTHDT_PhamVanAt.pdf - Sentence 1690
1691,13.4.,LTHDT_PhamVanAt.pdf - Sentence 1691
1692,Ví d ụ  Ví d ụ 1.,LTHDT_PhamVanAt.pdf - Sentence 1692
1693,Trong §12 đ ã viết ch ương tr ình xác định độ d ài của tệp TC.EXE.,LTHDT_PhamVanAt.pdf - Sentence 1693
1694,"D ưới đây l à một  phương án khác đơn gi ản hơn:  fstream  f(“TC.EXE”);   f.seekg(0,ios::end);   do_dai = f.teelg();   Ví dụ 2.",LTHDT_PhamVanAt.pdf - Sentence 1694
1695,Chương tr ình dưới đây sẽ nhập danh sách n thí sinh từ b àn phím và ghi lên t ệp.,LTHDT_PhamVanAt.pdf - Sentence 1695
1696,Sau đó  đưa con tr ỏ tệp về đầu tệp v à bắt đầu đọc dữ liệu thí sinh từ  tệp để in ra m àn hình.,LTHDT_PhamVanAt.pdf - Sentence 1696
1697,"Thông tin thí  sinh g ồm: Họ t ên, tỉnh hoặc th ành ph ố cư trú, s ố báo danh, các điểm toán lý hoá.",LTHDT_PhamVanAt.pdf - Sentence 1697
1698,"//CT7_13.CPP   // ghi - đọc đồng thời   #include <iostream.h>   #include <iomanip.h>   #include <fstream.h>   #include <conio.h>   #include <stdlib.h>   #include <ctype.h>   #include <stdio.h>   void main()   {  char ht[25], ttinh[21], ttep[40];   int sobd,stt ;   float dt, dl, dh , td;  fstream f;   cout << "" \nTen tep: "" ;   cin >> ttep;   f.open(ttep,ios::out|ios::in|ios::noreplace);   if (f.bad())   {  cout << "" \nTep "" << ttep << "" da ton tai"";   cout << "" \nCo ghi de?",LTHDT_PhamVanAt.pdf - Sentence 1698
1699,"- C/K"";   int ch=getch();   if (toupper(ch)=='C')  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          288                                         tenshi3003@gmail.com  {  f.close();   f.open(ttep,ios:: out|ios::in|ios::trunc) ;   }  else  exit(1);   }  stt=0 ;   f << setprecision(1) << setiosflags(ios::showpoint);   while(1)   {  ++stt;   cout << "" \nNhap thi sinh thu: "" << stt ;   cout << "" \nHo ten (neu rong thi ket thuc nhap) : "";   cin.ignore();   cin.getline(ht,25);   if (ht [0]==0) break;   cout << ""Tinh - thanh pho: "";   cin.getline(ttinh,21);   cout << ""SoBD, diem toan, diem ly, diem hoa: "" ;   cin >> sobd >> dt>> dl >> dh ;   td = dt + dl + dh ;   if (stt>1) f << endl;   f << setw(24) << ht << setw(20) << ttinh ;   f << endl << setw(6) <<  sobd   << setw(6) << dt   << setw(6) << dl   << setw(6) << dh   << setw(6) << td ;   }  f.seekg(0);   stt=0;   clrscr();   cout << "" \nDanh sach thi sinh \n"";  cout << setprecision(1) <<   setiosflags(ios::showpoint);   while(1)   {  f.getline(ht,25).getline(ttinh,21);   if (f.eof())  break;   ++stt;  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          289                                         tenshi3003@gmail.com  f >> sobd >> dt >> dl >> dh >> td;   f.ignore();   cout << "" \nThi sinh thu: "" << stt ;   cout << "" \nHo ten: ""<< ht;   cout << "" \nTinh - thanh pho: "" << ttinh;   cout << "" \nSo bao danh: "" << sobd;   cout << "" \nDiem toan, ly, hoa va tong diem: ""    <<setw( 6)<< dt << setw(6) <<dl << setw(6) << dh    << setw(6) << td ;   }  f.close();   cout << "" \n Hoan thanh"";   getch();   }    Bài 14.",LTHDT_PhamVanAt.pdf - Sentence 1699
1700,"X ử lý lỗi   Khi làm vi ệc với tệp không phải mọi việc đều trôi chẩy m à thư ờng xẩy ra nhiều điều trục trặc,  chẳng hạn:   1.",LTHDT_PhamVanAt.pdf - Sentence 1700
1701,M ở một tệp để đọc  nhưng t ệp không tồn tại.,LTHDT_PhamVanAt.pdf - Sentence 1701
1702,2.,LTHDT_PhamVanAt.pdf - Sentence 1702
1703,Đọc dữ liệu nh ưng con tr ỏ tệp đ ã ở cuối tệp   3.,LTHDT_PhamVanAt.pdf - Sentence 1703
1704,Ghi d ữ liệu nh ưng h ết không gian đĩa (đĩa đầy).,LTHDT_PhamVanAt.pdf - Sentence 1704
1705,4.,LTHDT_PhamVanAt.pdf - Sentence 1705
1706,"Tạo tệp nh ưng đia h ỏng, hoặc đĩa cấm ghi hoặc đĩa đầy.",LTHDT_PhamVanAt.pdf - Sentence 1706
1707,5.,LTHDT_PhamVanAt.pdf - Sentence 1707
1708,Dùng tên t ệp không hợp lệ   6.,LTHDT_PhamVanAt.pdf - Sentence 1708
1709,Định thực hiện một thao tác nh ưng t ệp lại không đư ợc mở ở mode ph ù hợp để thực hiện thao  tác đó.,LTHDT_PhamVanAt.pdf - Sentence 1709
1710,"Tóm l ại khi l àm vi ệc với tệp th ường gặp nhiều lỗi khác nhau, nếu không biết cách phát hiện xử  lý thì ch ương tr ình s ẽ dẫn đến rối loạn hoặc cho kết quả sai.",LTHDT_PhamVanAt.pdf - Sentence 1710
1711,Trong lớp ios của C++ có nhiều  phương th ức cho phép phát hi ện lỗi khi l àm vi ệc với tệp.,LTHDT_PhamVanAt.pdf - Sentence 1711
1712,Đó l à:  1.,LTHDT_PhamVanAt.pdf - Sentence 1712
1713,"Phương th ức  int eof() ;   Nếu con trỏ tệp đ ã ở cuối tệp m à lại thực hiện một lệnh đọc dữ liệu th ì phương th ức eof() trả về  giá tr ị khác không, trái lại ph ương th ức có giá trị bằng 0.",LTHDT_PhamVanAt.pdf - Sentence 1713
1714,2.,LTHDT_PhamVanAt.pdf - Sentence 1714
1715,"Phương th ức  int fa il() ;  Phương th ức fail() trả về giá trị khác không nếu lần nhập xuất cuối c ùng có l ỗi, trái lại ph ương  thức có giá trị bằng 0.",LTHDT_PhamVanAt.pdf - Sentence 1715
1716,3.,LTHDT_PhamVanAt.pdf - Sentence 1716
1717,"Phương th ức  int bad() ;  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          290                                         tenshi3003@gmail.com  Phương th ức bad() trả về giá trị khác không khi một phép nhập xuất không hợp lệ hoặc có lỗi m à  chưa p hát hi ện được, trái lại ph ương th ức có giá trị bằng 0.",LTHDT_PhamVanAt.pdf - Sentence 1717
1718,4.,LTHDT_PhamVanAt.pdf - Sentence 1718
1719,Phương th ức  int good() ;   Phương th ức good() trả về giá trị khác không nếu mọi việc đều tốt đẹp ( không có lỗi n ào xẩy  ra).,LTHDT_PhamVanAt.pdf - Sentence 1719
1720,Khi có m ột lỗi n ào đó th ì phương th ức có giá trị bằng 0.,LTHDT_PhamVanAt.pdf - Sentence 1720
1721,5.,LTHDT_PhamVanAt.pdf - Sentence 1721
1722,Phương th ức  void  clear() ;   dùng đ ể tắt tất cả các bit lỗi.,LTHDT_PhamVanAt.pdf - Sentence 1722
1723,Ví dụ 1.,LTHDT_PhamVanAt.pdf - Sentence 1723
1724,Khi m ở tệp để đọc cần kiểm tra xem tệp có tồn tại không.,LTHDT_PhamVanAt.pdf - Sentence 1724
1725,"Để l àm đi ều đó, chúng ta có  thể dùng đo ạn ch ương sau:   char ten_tep[40] ;   cout << “ \n Cho bi ết tên tệp: “ ;   cin >> ten_tep ;   ifstream f(ten_tep);   if (f.bad())   {  cout << “ \n Tệp << ten_tep << “không tồn tại” ;   exit(1) ;   }  Ví dụ 2.",LTHDT_PhamVanAt.pdf - Sentence 1725
1726,Khi t ạo tệp mới để ghi cần kiểm tra xem có tạo đ ược tệp hay không.,LTHDT_PhamVanAt.pdf - Sentence 1726
1727,"Để l àm đi ều đó,  chúng ta có th ể dùng đo ạn ch ương sau:   char ten_tep[40] ;   cout << “ \n Cho bi ết tên tệp: “ ;  cin >> ten_tep ;   ofstream f(ten_tep);   if (f.bad())   {  cout << “ \n Không t ạo được tệp << ten_tep ;   exit(1) ;   }  Ví dụ 3.",LTHDT_PhamVanAt.pdf - Sentence 1727
1728,"Để xác định độ d ài của tệp, có thể d ùng phương th ức eof() v à thu ật toán  sau:   + Đọc một byte (chú ý phải đọc theo kiểu nhị phân)   + Nếu việc đọc th ành công ( eof()=0 ) thì c ộng th êm m ột vào bộ đếm.",LTHDT_PhamVanAt.pdf - Sentence 1728
1729,Nếu việc đọc không th ành  ( eof() != 0 ) thì k ết thúc v ùng l ặp.,LTHDT_PhamVanAt.pdf - Sentence 1729
1730,"Thuật toán tr ên đư ợc thể hiện bằng đoạn ch ương tr ình sau:   ifstream  f(ten_tep, ios::in | ios::binary) ;   long dem = 0 ; char ch;   while (1)   {  f.get(ch) ;   if (!eof()) dem++ ;   else break;  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          291                                         tenshi3003@gmail.com  }  Bài 15.",LTHDT_PhamVanAt.pdf - Sentence 1730
1731,Nh ập xuất nhị  phân   15.1.,LTHDT_PhamVanAt.pdf - Sentence 1731
1732,Ch ọn kiểu nhập xuất nhị phân   Kiểu nhập xuất mặc định l à văn b ản.,LTHDT_PhamVanAt.pdf - Sentence 1732
1733,"Để chọn kiểu nhập xuất nhị phân, th ì trong tham s ố mode  (của hàm tạo dạng 2 v à phương th ức open) cần chứa giá trị:   ios::binary   Ví dụ muốn mở tệp “DSTS.DL” để đọc -ghi theo ki ểu nhị phân v à gắn tệp với d òng nh ập-xuất fs  , ta dùng câu l ệnh sau:   fstream fs(“DSTS.DL” , ios::in | ios::out | ios::binary) ;   15.2.",LTHDT_PhamVanAt.pdf - Sentence 1733
1734,"Đ ọc, ghi ký tự   + Để ghi một ký tự l ên tệp có thể dùng phương th ức:  ostream & put(char) ;   + Để đọc một ký tự từ tệp có thể d ùng phương th ức:  istream & get(char &) ;   Cần chú ý rằng : Cách đ ọc ghi ký tự theo kiểu văn bản khác với cách đọc ghi ký tự theo kiểu nhị  phân (xem chương 10, cu ốn Kỹ thuật lập tr ình C  của tác giả)   Ví dụ để sao tệp có thể d ùng thu ật toán đ ơn gi ản sau:   + Đọc một ký tự từ tệp nguồn   + Nếu đọc th ành công ( phương th ức eof() = 0) th ì ghi lên t ệp đích v à lại tiếp tục đọc ký tự tiếp  theo.",LTHDT_PhamVanAt.pdf - Sentence 1734
1735,+ Nếu đọc không th ành công ( phương th ức eof() != 0) th ì kết thúc.,LTHDT_PhamVanAt.pdf - Sentence 1735
1736,Chú ý  là ph ải dùng ki ểu nhập xuất nhị phân th ì thu ật toán mới cho kết quả chính xác.,LTHDT_PhamVanAt.pdf - Sentence 1736
1737,Ch ương  trình sao t ệp dưới đây viết theo thuật toán tr ên.,LTHDT_PhamVanAt.pdf - Sentence 1737
1738,"//CT7_15.CPP   // Sao tep   #include <iostream.h>   #include <fstream.h>   #include <conio.h>   #include <stdlib .h>  void main()   {  clrscr();   char tep_nguon[40], tep_dich[40] ;   char ch;   fstream fnguon, fdich;   cout << "" \nTen tep nguon: "" ; cin >> tep_nguon;   cout << "" \nTen tep dich: "" ; cin >> tep_dich;   fnguon.open(tep_nguon,ios::in | ios::binary);   fdich.open(tep_dich,i os::out | ios::binary);   if (fnguon.bad() || fdich.bad() )  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          292                                         tenshi3003@gmail.com  {  cout << "" \n Loi mo tep nguon hoac dich "" ;   getch();   exit(1);   }  while(fnguon.get(ch),!fnguon.eof())   fdich.put(ch) ;   fnguon.close();   fdich.close();   cout << "" \nHoan thanh"" ;   getch();   }  15.3.",LTHDT_PhamVanAt.pdf - Sentence 1738
1739,"Đ ọc, ghi  một dẫy ký tự theo kiểu nhị phân   + Phương th ức:  ostream &  write(char *buf, int n) ;   sẽ xuất  n  ký tự (byte) chứa trong buf ra d òng xu ất.",LTHDT_PhamVanAt.pdf - Sentence 1739
1740,"+ Phương th ức:  istream &  read(char *buf, int n) ;   sẽ nhập  n  ký tự (byte) từ d òng nh ập và  ch ứa vào buf.",LTHDT_PhamVanAt.pdf - Sentence 1740
1741,+ Phương thức   int gcount   cho bi ết số ký tự thực sự đọc đ ược trong ph ương th ức read.,LTHDT_PhamVanAt.pdf - Sentence 1741
1742,"Chú ý:  Các phương th ức write, read chỉ l àm vi ệc một cách chính xác trong kiểu nhập -xuất nhị  phân.",LTHDT_PhamVanAt.pdf - Sentence 1742
1743,"Dưới đây l à chương tr ình sao t ệp sử dụng các ph ương th ức write, read v à gcount.",LTHDT_PhamVanAt.pdf - Sentence 1743
1744,"//CT7_16.CPP   // Sao tep dung write, read va gcount   #include <iostream.h>   #include <fstream.h>   #include <conio.h>   #include <stdlib.h>   void main()   {  clrscr();   char tep_nguon[40], tep_dich[40] ;   char buf[5000];   int n;   fstream fnguon, fdich;   cout << "" \nTen tep n guon: "" ; cin >> tep_nguon;   cout << "" \nTen tep dich: "" ; cin >> tep_dich;   fnguon.open(tep_nguon,ios::in | ios::binary);  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          293                                         tenshi3003@gmail.com  fdich.open(tep_dich,ios::out | ios::binary);   if (fnguon.bad() || fdich.bad() )   {  cout << "" \n Loi mo tep nguon hoac dich "" ;   getch();   exit(1);  }  while(fnguon.read(buf,5000),(n=fnguon.gcount()))   fdich.write(buf,n) ;   fnguon.close();   fdich.close();   cout << "" \nHoan thanh"" ;   getch();   }  Bài 16.",LTHDT_PhamVanAt.pdf - Sentence 1744
1745,Đ ọc ghi đồng thời theo kiểu nhị phân   Chương tr ình d ưới đây minh hoạ cách đọc ghi đồng thời tr ên tệp the o kiểu nhị phân.,LTHDT_PhamVanAt.pdf - Sentence 1745
1746,"Ch ương  trình s ử dụng các ph ương th ức write, read, các ph ương th ức di chuyển con trỏ tệp v à các phương  thức kiểm tra lỗi.",LTHDT_PhamVanAt.pdf - Sentence 1746
1747,Ch ương tr ình g ồm 3 chức năng:   1.,LTHDT_PhamVanAt.pdf - Sentence 1747
1748,Nh ập một danh sách thí sinh mới v à ghi vào t ệp TS.DL   2.,LTHDT_PhamVanAt.pdf - Sentence 1748
1749,Bổ sung thí sinh v ào tệp TS.,LTHDT_PhamVanAt.pdf - Sentence 1749
1750,DL  3.,LTHDT_PhamVanAt.pdf - Sentence 1750
1751,"Xem s ửa thí sinh tr ên tệp TS.DL   //CT7_18.CPP   // Doc tep   #include <iostream.h>   #include <iomanip.h>   #include <fstream.h>   #include <conio.h>   #include <stdlib.h>   #include <ctype.h>   #include <string.h>   #include <stdio.h>   struct TSINH   {  char ht[25];   int sobd;  float td;   };  class TS   {  private:   TSINH ts;  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          294                                         tenshi3003@gmail.com  char ten_tep[40];   int sots;   static int size;   public:   TS(char *ttep);   void tao_ds();   void bo_sung();   void xem_sua();   };  int TS::size = sizeof(TSINH);   TS::TS(char *ttep)   {  strcpy(ten_tep,ttep);   fstream f;   f.ope n(ten_tep,ios::binary|ios::in|ios::ate);   if (!f.good())   sots = 0 ;   else  {  sots=f.tellg()/size ;   }  }  void TS::tao_ds()   {  fstream f;   f.open(ten_tep,ios::binary|ios::out|ios::noreplace);   if (!f.good())   {  cout << "" \nDanh sach da ton tai"" ;   cout << "" \nCo tao la i khong?",LTHDT_PhamVanAt.pdf - Sentence 1751
1752,"- C/K"" ;   char ch=getch();   if (toupper(ch) != 'C')   return;   else  {  f.close();   f.open(ten_tep,ios::binary|ios::out|ios::trunc);   }  }  sots=0;   while(1)   { Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          295                                         tenshi3003@gmail.com  cout << "" \nThi sinh thu: "" << (sots+1) ;   cout << "" \nHo ten (Bam Enter de ket thuc): "";   fflush(stdin );  gets(ts.ht);   if (ts.ht[0]==0) break;   cout << "" \nSo bao danh: "";   cin >> ts.sobd;   cout << "" \nTong diem: "";   cin >> ts.td;   f.write((char*)(&ts),size) ;   sots++ ;   }  f.close();   }  void TS::bo_sung()   {  fstream f;   f.open(ten_tep,ios::binary|ios::app|ios::nocreate );  if (!f.good())   {  cout << "" \nDanh sach chua tao"" ;   cout << "" \nCo tao moi khong?",LTHDT_PhamVanAt.pdf - Sentence 1752
1753,"- C/K"" ;   char ch=getch();   if (toupper(ch) != 'C')   return;   else  {  f.close();   f.open(ten_tep,ios::binary|ios::out);   }  }  int stt=0;   while(1)   {  cout << "" \nBo sung thi sinh thu: ""  << (stt+1);   cout << "" \nHo ten (Bam Enter de ket thuc): "";   fflush(stdin);   gets(ts.ht);   if (ts.ht[0]==0) break;   cout << "" \nSo bao danh: "";  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          296                                         tenshi3003@gmail.com  cin >> ts.sobd;   cout << "" \nTong diem: "";   cin >> ts.td;   f.write((char*)(&ts),size) ;   ++stt;   }  sots += stt ;   f.close();   }  void TS::xem_sua()   {  fstream f; int ch;   f.open(ten_tep,ios::binary|ios::out|ios::in|ios::nocreate);   if (!f.good())   {  cout << "" \nDanh sach chua tao"" ;   getch();   return ;   }  cout << "" \nDanh sach gom: "" << sots << ""thi sinh"" ;   int stt;   while(1)   {  cout << "" \nCan xem -sua thi sinh thu (Bam 0 de ket thuc): "" ;   cin >> stt ;   if (stt<1 || stt > sots) break;   f.seekg((stt -1)*size,ios::beg);   f.read((char*)(&ts),size);   cout << "" \nHo ten : "" << ts.ht;   cout << "" \nSo ba danh: "" << ts.sobd ;   cout << "" \nTong diem: "" << ts.td ;  cout << "" \nCo sua khong?",LTHDT_PhamVanAt.pdf - Sentence 1753
1754,"- C/K"" ;   ch=getch();   if (toupper(ch)=='C')   {  f.seekg( -size,ios::cur) ;   cout << "" \nHo ten: "";   fflush(stdin);   gets(ts.ht);   cout << "" \nSo bao danh: "";   cin >> ts.sobd;  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          297                                         tenshi3003@gmail.com  cout << "" \nTong diem: "";   cin >> ts.td;   f.write((char*)(&ts),size)  ;  }  }  f.close();   }  void main()   {  int chon;   clrscr();   TS t(""TS.DL"");   while(1)   {  clrscr();   cout << "" \n1.",LTHDT_PhamVanAt.pdf - Sentence 1754
1755,"Tao danh sach thi sinh moi"" ;   cout << "" \n2.",LTHDT_PhamVanAt.pdf - Sentence 1755
1756,"Bo sung danh sach thi sinh"" ;   cout << "" \n3.",LTHDT_PhamVanAt.pdf - Sentence 1756
1757,"Xem -sua danh sach thi sinh"" ;   cout << "" \n4.",LTHDT_PhamVanAt.pdf - Sentence 1757
1758,"Ket thuc chuong trin h     "" ;   chon = getch();   chon = chon - 48;  clrscr();   if (chon==1) t.tao_ds();   else if(chon==2) t.bo_sung();   else if(chon==3) t.xem_sua();   else break;   }    clrscr();     cout << "" \n Hoan thanh"";     getch();    }  Bài 17.",LTHDT_PhamVanAt.pdf - Sentence 1758
1759,"Xây d ựng toán tử nhâp x uất đối tượng tr ên tệp  Trong các m ục trên đã trình b ầy cách d ùng các toán t ử nhập >> v à xuất << để ghi dữ liệu kiểu  chuẩn (nguy ên, th ực, ký tự, chuỗi ký tự) tr ên tệp.",LTHDT_PhamVanAt.pdf - Sentence 1759
1760,Mục n ày trình b ầy cách xây dựng các toán tử  dùng đ ể đọc ghi các đối t ượng của một lớp bất kỳ do ng ười dùng định nghĩa.,LTHDT_PhamVanAt.pdf - Sentence 1760
1761,Giả sử chúng ta muốn sử dụng các toán tử nhập xuất để đọc ghi các đối t ượng của lớp TS.,LTHDT_PhamVanAt.pdf - Sentence 1761
1762,"Khi  đó ta đưa vào các hàm b ạn toán tử nhập xuất nh ư sau:   class TS   {  private:   // Khai báo các thu ộc tính  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          298                                         tenshi3003@gmail.com  public:   friend fstream& operator<<(fstream& fs,cons t TS &t);   friend fstream& operator>>(fstream& fs,TS &t);   ...",LTHDT_PhamVanAt.pdf - Sentence 1762
1763,} ;  Về kiểu ghi: Có th ể xây dựng các toán tử để thực hiện các phép đọc ghi theo kiểu văn bản cũng  như nh ị phân.,LTHDT_PhamVanAt.pdf - Sentence 1763
1764,"Ví dụ 1: Ghi theo ki ểu văn bản   Chương tr ình d ưới đây minh hoạ cách xây dựng v à sử dụng các toán tử nhập xuất đối t ượng tr ên  màn hình, bàn phím và t ệp.",LTHDT_PhamVanAt.pdf - Sentence 1764
1765,"Ch ương tr ình đưa vào l ớp TS (Thí sinh) v à các hàm toán t ử cho phép  nhập xuất các đối t ượng TS tr ên màn hình, bàn phím và t ệp.",LTHDT_PhamVanAt.pdf - Sentence 1765
1766,Ch ương tr ình g ồm các nội dung sau:   + Tạo tệp TS.DL d ùng đ ể đọc  và ghi theo ki ểu văn bản.,LTHDT_PhamVanAt.pdf - Sentence 1766
1767,"+ Nh ập 3 thí sinh từ b àn phím và ch ứa vào 3 bi ến đối t ượng  t1, t2, t3.",LTHDT_PhamVanAt.pdf - Sentence 1767
1768,"+ Ghi n ội dung của 3 biến đối t ượng t1, t2, t3 l ên tệp TS.DL   + Đọc các đối t ượng  từ tệp TS.DL v à chứa vào 3 bi ến t4, t5, t6   + In các bi ến đối t ượng t4, t5, t6 ra màn hình   + Chuy ển con trỏ về đầu tệp, d ùng chu trình while để lần l ượt đọc các đối t ượng từ tệp v à in ra  màn hình.",LTHDT_PhamVanAt.pdf - Sentence 1768
1769,Dùng ph ương th ức eof để kiểm tra xem đ ã đọc hết dữ liệu hay ch ưa.,LTHDT_PhamVanAt.pdf - Sentence 1769
1770,"//CT7_17.CPP   // Cac toan tu doc ghi doi tuong tren  Tep   #include <ios tream.h>   #include <iomanip.h>   #include <fstream.h>   #include <conio.h>   #include <stdlib.h>   #include <ctype.h>   class TS   {  private:   char ht[25];   float td;   public:   friend ostream& operator<<(ostream& os,const TS &t);   friend istream& operator>>(istream& is,TS & t);  friend fstream& operator<<(fstream& fs,const TS &t);   friend fstream& operator>>(fstream& fs,TS &t);   };  fstream& operator>>(fstream& fs,TS &t)   {  fs.getline(t.ht,25);   fs >> t.td;   fs.ignore();  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          299                                         tenshi3003@gmail.com  return fs;   }  ostream& operator<<(ostream& os,const TS &t)   {  os << "" \nHo ten: "" << t.ht ;   os << "" \nTong diem: "" << t.td;   return os;   }  fstream& operator<<(fstream& fs,const TS &t)   {  fs <<  t.ht << endl;   fs <<  t.td << endl;   return fs;   }  istream& operator>>(istream& is,TS &t)   {  cout << "" \nHo ten: "" ;   is.get(t.ht,25);   cout << ""Tong diem: "" ;   is >> t.td ;   is.ignore();   return is;   }  void main()   {  clrscr();   fstream f(""TS.DL"",ios::out | ios::in | ios::trunc);   TS t1,t2,t3,t4,t5,t6,t;   cin >> t1 >> t2 >> t3;   f << t1 << t2 <<t3;   f.seekg(0);   f>>t4>>t5>>t6;   cout << t4 << t5 << t6;   f.seekg(0);   while (f>>t ,!f.eof())   cout << t;   f.close();   cout << "" \n Xong"";   getch();  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          300                                         tenshi3003@gmail.com  }    Ví dụ 2 :  Ghi theo ki ểu nhị phân   Chương tr ình d ưới đây cũng có các chức năng nh ư chương tr ình trong ví d ụ 1 b ên trên, nhưng  cách ghi đ ọc tệp theo kiểu nhị phân.",LTHDT_PhamVanAt.pdf - Sentence 1770
1771,"//CT7_ 19.CPP   // Cac toan tu doc ghi doi tuong tren Tep   // Kieu nhi phan   #include <iostream.h>   #include <iomanip.h>   #include <fstream.h>   #include <conio.h>   #include <stdlib.h>   #include <ctype.h>   class TS   {  private:   char ht[25];   float td;   static int size;   public:   friend ostream& operator<<(ostream& os,const TS &t);   friend istream& operator>>(istream& is,TS &t);   friend fstream& operator<<(fstream& fs,const TS &t);   friend fstream& operator>>(fstream& fs,TS &t);   };  int TS::size= sizeof(TS);   fstream& operator>>(fstream & fs,TS &t)   {  fs.read( (char*)(&t) , t.size);   return fs;   }  fstream& operator<<(fstream& fs,const TS &t)   {  fs.write( (char*)(&t) , t.size);   return fs;   }  ostream& operator<<(ostream& os,const TS &t)   {  os <<  t.ht << endl;   os <<  t.td << endl;  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          301                                         tenshi3003@gmail.com  return os;   }  istream& operator>>(istream& is,TS &t)   {  cout << "" \nHo ten: "" ;   is.get(t.ht,25);   cout << ""Tong diem: "" ;   is >> t.td ;   is.ignore();   return is;   }  void main()   {  clrscr();   fstream f(""THU.DL"",ios::binary | ios::out|ios::in|ios::trunc);   TS t1,t2,t3,t4,t5,t6,t;   cin >> t1 >> t2 >> t3;   f << t1 << t2 <<t3;   f.seekg(0);   f>>t4>>t5>>t6;   cout << t4 << t5 << t6;   f.seekg(0);   while( f>>t ,!f.eof() )   cout << t;   f.close();   cout << "" \n Xong"";   getch();   }  Bài 18.",LTHDT_PhamVanAt.pdf - Sentence 1771
1772,"H ệ thống các lớp stream   Mục này hệ thống lại các lớp stream m à chúng ta đã sử dụng b ên trên đ ể tổ chức xuất nhập tr ên  màn hình, bàn phím, máy in và t ệp  18.1.",LTHDT_PhamVanAt.pdf - Sentence 1772
1773,Sơ đ ồ quan hệ giữa các lớp     ios          istream   fstreambase   ostream        Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          302                                         tenshi3003@gmail.com  ifstream     ofstream           fstream     18.2.,LTHDT_PhamVanAt.pdf - Sentence 1773
1774,Các phương th ức của lớp ios   1.,LTHDT_PhamVanAt.pdf - Sentence 1774
1775,int bad()   2.,LTHDT_PhamVanAt.pdf - Sentence 1775
1776,void clear(int=0)   3.,LTHDT_PhamVanAt.pdf - Sentence 1776
1777,int eof()   4.,LTHDT_PhamVanAt.pdf - Sentence 1777
1778,int fail()   5.,LTHDT_PhamVanAt.pdf - Sentence 1778
1779,int fill()   6.,LTHDT_PhamVanAt.pdf - Sentence 1779
1780,int fill(char)   7.,LTHDT_PhamVanAt.pdf - Sentence 1780
1781,long flags()   8.,LTHDT_PhamVanAt.pdf - Sentence 1781
1782,long flags(long)   9.,LTHDT_PhamVanAt.pdf - Sentence 1782
1783,int good()   10.,LTHDT_PhamVanAt.pdf - Sentence 1783
1784,int precision()   11.,LTHDT_PhamVanAt.pdf - Sentence 1784
1785,int precision(int)   12.,LTHDT_PhamVanAt.pdf - Sentence 1785
1786,long setf(long)   13.,LTHDT_PhamVanAt.pdf - Sentence 1786
1787,"long setf(long setbits, long field)   14.",LTHDT_PhamVanAt.pdf - Sentence 1787
1788,long unset f(long)   15.,LTHDT_PhamVanAt.pdf - Sentence 1788
1789,int width()   16.,LTHDT_PhamVanAt.pdf - Sentence 1789
1790,int width(int)   18.3.,LTHDT_PhamVanAt.pdf - Sentence 1790
1791,Các phương th ức của lớp istream   1.,LTHDT_PhamVanAt.pdf - Sentence 1791
1792,operator>>    2.,LTHDT_PhamVanAt.pdf - Sentence 1792
1793,int gcount()   3.,LTHDT_PhamVanAt.pdf - Sentence 1793
1794,int get()   4.,LTHDT_PhamVanAt.pdf - Sentence 1794
1795,"istream& get(char*, int, char = ‘ \n’)  5.",LTHDT_PhamVanAt.pdf - Sentence 1795
1796,istream& get(char&)   6.,LTHDT_PhamVanAt.pdf - Sentence 1796
1797,"istream& getline(char*, int, char = ‘ \n’)  7.",LTHDT_PhamVanAt.pdf - Sentence 1797
1798,"istream& ignore(i nt n = 1, int delim = EOF)   8.",LTHDT_PhamVanAt.pdf - Sentence 1798
1799,int peek()   9.,LTHDT_PhamVanAt.pdf - Sentence 1799
1800,istream& putback(char)   10.,LTHDT_PhamVanAt.pdf - Sentence 1800
1801,"istream& read(char*, int)   11.",LTHDT_PhamVanAt.pdf - Sentence 1801
1802,istream& seekg(long)   12.,LTHDT_PhamVanAt.pdf - Sentence 1802
1803,"istream& seekg(long, seek_dir)   13.",LTHDT_PhamVanAt.pdf - Sentence 1803
1804,long tellg()     18.4.,LTHDT_PhamVanAt.pdf - Sentence 1804
1805,Các phương th ức của lớp ostream   1.,LTHDT_PhamVanAt.pdf - Sentence 1805
1806,operator<<    2.,LTHDT_PhamVanAt.pdf - Sentence 1806
1807,ostream& flush()  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          303                                         tenshi3003@gmail.com  3.,LTHDT_PhamVanAt.pdf - Sentence 1807
1808,ost ream& put(char)   4.,LTHDT_PhamVanAt.pdf - Sentence 1808
1809,ostream& seekp(long)   5.,LTHDT_PhamVanAt.pdf - Sentence 1809
1810,"ostream& seekp(long, seek_dir)   6.",LTHDT_PhamVanAt.pdf - Sentence 1810
1811,long tellp()   7.,LTHDT_PhamVanAt.pdf - Sentence 1811
1812,"ostream& write(char*, int)   18.5.",LTHDT_PhamVanAt.pdf - Sentence 1812
1813,Các phương th ức của lớp fstreambase   void  close()   18.6.,LTHDT_PhamVanAt.pdf - Sentence 1813
1814,Các phương th ức của lớp  ifstream   1.,LTHDT_PhamVanAt.pdf - Sentence 1814
1815,ifstream()   2.,LTHDT_PhamVanAt.pdf - Sentence 1815
1816,"ifstream(const char*, i nt = ios::in, int = filebuf::openprot)   3.",LTHDT_PhamVanAt.pdf - Sentence 1816
1817,ifstream(int )   4.,LTHDT_PhamVanAt.pdf - Sentence 1817
1818,"ifstream(int , char*, int)   5.",LTHDT_PhamVanAt.pdf - Sentence 1818
1819,"void open(const char*, int = ios::in, int = filebuf::openprot)   18.7.",LTHDT_PhamVanAt.pdf - Sentence 1819
1820,Các phương th ức của lớp  ofstream   1.,LTHDT_PhamVanAt.pdf - Sentence 1820
1821,ofstream()   2.,LTHDT_PhamVanAt.pdf - Sentence 1821
1822,"ofstream(const char*, int = ios::out, int = fi lebuf::openprot)   3.",LTHDT_PhamVanAt.pdf - Sentence 1822
1823,ofstream(int )   4.,LTHDT_PhamVanAt.pdf - Sentence 1823
1824,"ofstream(int , char*, int)   5.",LTHDT_PhamVanAt.pdf - Sentence 1824
1825,"void open(const char*, int = ios::out, int = filebuf::openprot)   18.8.",LTHDT_PhamVanAt.pdf - Sentence 1825
1826,Các phương th ức của lớp  fstream   1.,LTHDT_PhamVanAt.pdf - Sentence 1826
1827,fstream()   2.,LTHDT_PhamVanAt.pdf - Sentence 1827
1828,"fstream(const char*, int, int = filebuf::openprot)   3.",LTHDT_PhamVanAt.pdf - Sentence 1828
1829,fstream(int )   4.,LTHDT_PhamVanAt.pdf - Sentence 1829
1830,"fstream(int , char*, int)   5.",LTHDT_PhamVanAt.pdf - Sentence 1830
1831,"void open(const char*, int, int = filebuf::openprot)                          Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          304                                         tenshi3003@gmail.com  Chương 8   Đồ họa   Trong chương này s ẽ giới thiệu các h àm đ ể vẽ các đ ường v à hình c ơ bản nh ư đư ờng tr òn, cung  elip, hình qu ạt, đường gẫy khúc, h ình đa giác, đư ờng thẳng, đ ường chữ nhật, h ình ch ữ nhật, h ình  hộp chữ nhật, ...",LTHDT_PhamVanAt.pdf - Sentence 1831
1832,"Ngo ài ra còn đề cập tới các vấn đề rất lý thú khác nh ư: xử lý văn bản tr ên màn hình  đồ họa, cửa sổ v à kỹ thuật tạo ảnh di động.",LTHDT_PhamVanAt.pdf - Sentence 1832
1833,Các h àm đ ồ họa đ ược khai báo trong tệp graphics.h.,LTHDT_PhamVanAt.pdf - Sentence 1833
1834,Bài 1.,LTHDT_PhamVanAt.pdf - Sentence 1834
1835,"Khái ni ệm đồ họa   Để hiểu kỹ thuật lập tr ình đồ họa, đầu ti ên ph ải hiểu các yếu tố c ơ bản của đồ họa.",LTHDT_PhamVanAt.pdf - Sentence 1835
1836,Từ t rước đến  nay chúng ta ch ủ yếu l àm vi ệc với kiểu văn bản.,LTHDT_PhamVanAt.pdf - Sentence 1836
1837,"Nghĩa l à màn hình được thiết lập để hiển thị 25  dòng, m ỗi dòng có th ể chứa 80 ký tự.",LTHDT_PhamVanAt.pdf - Sentence 1837
1838,"Trong kiểu văn bản, các ký tự hiển thị tr ên màn hình đã được  phần cứng của máy PC ấn định tr ước và ta không th ể nào thay đ ổi được kích th ước, kiểu chữ.",LTHDT_PhamVanAt.pdf - Sentence 1838
1839,"ở màn hình đồ họa, ta có thể xử lý đến từng chấm điểm (pixel) tr ên màn hình và do v ậy muốn vẽ  bất kỳ thứ g ì cũng đ ược.",LTHDT_PhamVanAt.pdf - Sentence 1839
1840,Sự b ài trí và s ố pixel tr ên màn hình được gọi l à độ phân giải (resolution).,LTHDT_PhamVanAt.pdf - Sentence 1840
1841,Do m ỗi kiểu m àn hình đồ họa có một cách xử lý đồ họa ri êng nên TURBO C cung c ấp một tệp tin  điều khiển ri êng cho t ừng kiểu đồ họa.,LTHDT_PhamVanAt.pdf - Sentence 1841
1842,Bảng 8 -1 cho th ấy các kiểu đồ họa v à các t ệp tin điều khiển  chúng.,LTHDT_PhamVanAt.pdf - Sentence 1842
1843,"Ngoài các t ệp có đuôi BGI chứa ch ương tr ình điều khiển đồ họa, TURBO C c òn cung c ấp các  tệp tin đuôi CHR chứa các Font chữ để vẽ các kiểu chữ khác nhau tr ên màn hình đồ họa.",LTHDT_PhamVanAt.pdf - Sentence 1843
1844,Đó l à các  tệp:  GOTH.CHR   LITT.CHR   SANS.CHR   TRIP.CHR   Bảng 8 -1.,LTHDT_PhamVanAt.pdf - Sentence 1844
1845,"Các t ệp tin điều khiển đồ họa của TURBO C++   Tên t ệp tin  Kiểu m àn hình đồ họa   ATT.BGI   ATT & T6300 (400 dòng)   CGA.BGI   IBMCGA, MCGA và các máy tương thích   EGAVGA.BGI  IBM EGA, VGA và các máy tương thích   HERC.BGI  Hercules monochrome và các máy tương thích   IBM8514.BGI  IBM 8514 và các máy tương thích   PC3270.BGI  IBM 3270 PC   Màn hình đồ họa gồm nhiều  điểm ảnh đ ược sắp xếp tr ên các đư ờng thẳng ngang v à dọc.",LTHDT_PhamVanAt.pdf - Sentence 1845
1846,Điều  này đúng cho t ất cả các kiểu m àn hình đồ họa của máy tính.,LTHDT_PhamVanAt.pdf - Sentence 1846
1847,Khác biệt chủ yếu giữa chúng l à kích  thước và số các điểm ảnh.,LTHDT_PhamVanAt.pdf - Sentence 1847
1848,"Trong kiểu CGA (độ phân giải thấp), điểm ảnh có kích th ước lớn, chiều  ngang có 320 đi ểm ảnh, c òn theo chi ều dọc có 200 điểm ảnh.",LTHDT_PhamVanAt.pdf - Sentence 1848
1849,"M àn hình VGA có độ phân giải cao  hơn: đi ểm ảnh nhỏ h ơn, trên m ỗi hàng có 640 đi ểm ảnh v à trên m ỗi cột có 480 điểm ảnh.",LTHDT_PhamVanAt.pdf - Sentence 1849
1850,Điểm ảnh  càng nh ỏ thì số điểm ảnh tr ên màn hình càng nhi ều và chất lượng đồ họa  càng cao.,LTHDT_PhamVanAt.pdf - Sentence 1850
1851,Mỗi kiểu đồ họa d ùng m ột hệ tọa độ ri êng.,LTHDT_PhamVanAt.pdf - Sentence 1851
1852,"H ệ tọa độ cho m àn hình VGA là 640 x 480 nh ư sau :        Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          305                                         tenshi3003@gmail.com        (0,0)  (639,0)                                                                                                                                                                                                            (0,479)  (639,479)   Hình 8.1.",LTHDT_PhamVanAt.pdf - Sentence 1852
1853,"Hệ tọa độ VGA   Nhờ hệ tọa độ n ày, ta có th ể tác động hay tham chiếu đến bất kỳ điểm ảnh n ào trên màn hình đồ  họa.",LTHDT_PhamVanAt.pdf - Sentence 1853
1854,"Nếu dùng màn hình CGA thì góc d ưới phải có tọa độ (3 19, 199).",LTHDT_PhamVanAt.pdf - Sentence 1854
1855,"Đ ộc lập với kiểu đồ họa đang  sử dụng, các h àm getmaxx và getmaxy bao gi ờ cũng cho tọa độ x v à y lớn nhất trong kiểu đồ họa  đang dùng.",LTHDT_PhamVanAt.pdf - Sentence 1855
1856,Một ch ương tr ình đồ họa th ường gồm các phần sau:   - Khởi động hệ thống đồ họa.,LTHDT_PhamVanAt.pdf - Sentence 1856
1857,"- Xác đ ịnh mầu nền (mầu m àn hình),  mầu đường vẽ, mầu tô v à kiểu (mẫu) tô.",LTHDT_PhamVanAt.pdf - Sentence 1857
1858,"- Vẽ, tô mầu các h ình mà ta mong mu ốn.",LTHDT_PhamVanAt.pdf - Sentence 1858
1859,- Các thao tác đ ồ họa khác nh ư cho hi ện các d òng ch ữ...,LTHDT_PhamVanAt.pdf - Sentence 1859
1860,- Đóng h ệ thống đồ họa để trở về mode văn bản.,LTHDT_PhamVanAt.pdf - Sentence 1860
1861,Bài 2.,LTHDT_PhamVanAt.pdf - Sentence 1861
1862,Kh ởi động hệ đồ họa   Mục đích của việc khởi động hệ thống đồ họa l à xác đ ịnh thiết bị đồ họa (m àn hình) và m ốt đồ  họa sẽ sử dụng trong ch ương tr ình.,LTHDT_PhamVanAt.pdf - Sentence 1862
1863,"Để làm đi ều này ta dùng hàm:   void initgraph(int *graphdriver, int *graphmode,char *driverpath);   trong đó: driverpath là đư ờng dẫn của th ư mục chứa các tệp tin điều khiển đồ họ a, graphdriver,  graphmode cho bi ết màn hình và m ốt đồ họa sẽ sử dụng trong ch ương tr ình.",LTHDT_PhamVanAt.pdf - Sentence 1863
1864,B ảng 8 -2 cho th ấy các  giá tr ị khả dĩ của graphdriver v à graphmode.,LTHDT_PhamVanAt.pdf - Sentence 1864
1865,Ví d ụ 1.,LTHDT_PhamVanAt.pdf - Sentence 1865
1866,"Giả sử máy tính của ta có m àn hình EGA, các t ệp tin đồ họa chứa trong th ư mục C:  \TC, khi đ ó ta có th ể khởi động hệ thống đồ họa nh ư sau:   #include ""graphics.h""   main()   {  int mh=EGA, mode= EGALO;   initgraph(&mh, &mode, ""C: \TC"");   .",LTHDT_PhamVanAt.pdf - Sentence 1866
1867,.,LTHDT_PhamVanAt.pdf - Sentence 1867
1868,.,LTHDT_PhamVanAt.pdf - Sentence 1868
1869,}  Bảng 8 -2.,LTHDT_PhamVanAt.pdf - Sentence 1869
1870,"Các giá tr ị khả dĩ của graphdriver, graphmode  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          306                                         tenshi3003@gmail.com  graphdriver  graphmode  Độ phân giải   Detect (0)     CGA (1)  CGAC0 (0)  320 x 200    CGAC1 (1)  320 x 200    CGAC2 (2)  320 x 200    CGAC3 (3)  320 x 200    CGAHi (4)  640 x 200   MCGA (2)  MCGA0 (0)  320 x 200    MCGA1 (1)  320 x 200    MCGA2 (2)  320 x 200    MCGA3 (3)  320 x 200    MCGAMed (4)  640 x 200    MCGAHi (5)  640 x 480   EGA (3)  EGALO (0)  640 x 200    EGAHi (1)  640 x 350   EGA64 (4)  EGA64LO (0)  640 x 200    EGA64Hi (1)  640 x 350   EGAMONO (5)  EGAMONOHi (0)  640 x 350   VGA (9)  VGALO (0)  640 x 200    VGAMED (1)  640 x 350    VGAHI (2)  640 x 480   HERCMONO (7)  HERCMONO HI 720 x 348   ATT400 (8)  ATT400C0 (0)  320 x 200    ATT400C1 (1)  320 x 200    ATT400C2 (2)  320 x 200    ATT400C3 (3)  320 x 200    ATT400MED (4)  640 x 400    ATT400HI (5)  640 x 400   PC3270 (10)  PC3270HI (0)  720 x 350   IBM8514 (6)  IBM8514LO (0)  640 x 480, 256 m ầu    IBM8514HI (1)  1024 x 768, 256 m ầu    Chú ý 1.",LTHDT_PhamVanAt.pdf - Sentence 1870
1871,"Bảng 8 -2 cho các tên h ằng v à giá tr ị của chúng m à các bi ến graphdriver, graphmode có  thể nhận.",LTHDT_PhamVanAt.pdf - Sentence 1871
1872,"Chẳng hạn hằng DETECT có giá trị 0, hằng VGA có giá trị 9, hằng VGALO có giá trị 0...",LTHDT_PhamVanAt.pdf - Sentence 1872
1873,Khi l ập tr ình ta có  thể dùng tên h ằng hoặc giá trị t ương ứng của chúng.,LTHDT_PhamVanAt.pdf - Sentence 1873
1874,Chẳng hạn các phép gán  trong ví d ụ 1 có thể viết theo một cách khác t ương đương như sau:   mh=3;   mode=0;   Chú ý 2.,LTHDT_PhamVanAt.pdf - Sentence 1874
1875,Bảng 8.2 cho thấy độ phân giải phụ thuộc cả v ào màn hình và mode.,LTHDT_PhamVanAt.pdf - Sentence 1875
1876,"Ví d ụ trong m àn  hình EGA nếu dùng mode EGALO thì độ phân giải l à 640 x 200, hàm getmaxx cho giá tr ị 639, h àm  getmaxy cho giá tr ị 199 .",LTHDT_PhamVanAt.pdf - Sentence 1876
1877,"Nếu cũng m àn hình EGA mà dùng mode EGAHI thì độ phân giải l à 640x  350, hàm getmaxx cho giá tr ị 639, h àm getmaxy cho giá tr ị 349.",LTHDT_PhamVanAt.pdf - Sentence 1877
1878,Chú ý 3.,LTHDT_PhamVanAt.pdf - Sentence 1878
1879,Nếu khôn g biết chính xác kiểu m àn hình đang s ử dụng th ì ta gán cho bi ến graphdriver  hằng DETECT hay giá trị 0.,LTHDT_PhamVanAt.pdf - Sentence 1879
1880,"Khi đó kết quả của h àm initgraph s ẽ là:  - Kiểu của m àn hình đang s ử dụng đ ược phát hiện, giá trị số của nó đ ược gán cho biến  graphdriver.",LTHDT_PhamVanAt.pdf - Sentence 1880
1881,Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          307                                         tenshi3003@gmail.com  - Mode đ ồ họa ở  độ phân giải cao nhất ứng với m àn hình đang s ử dụng cũng đ ược phát hiện v à  giá tr ị số của nó đ ược gán cho biến graphmode.,LTHDT_PhamVanAt.pdf - Sentence 1881
1882,"Như v ậy việc d ùng h ằng số DETECT chẳng những có thể khởi động đ ược hệ thống đồ họa của  màn hình hi ện có theo mode có độ phân giải cao  nhất, m à còn giúp ta xác định chính xác kiểu m àn  hình đang s ử dụng.",LTHDT_PhamVanAt.pdf - Sentence 1882
1883,Ví dụ 2.,LTHDT_PhamVanAt.pdf - Sentence 1883
1884,"Chương tr ình d ưới đây xác định kiểu m àn hình đang s ử dụng:   #include ""graphics.h""   #include ""stdio.h""   main()   {  int mh=0, mode= 0;   initgraph(&mh, &mode, """");   printf("" \n Giá tr ị số c ủa m àn hình là: %d"", mh);   closegraph();   }  Nếu ch ương tr ình cho k ết quả:   Giá tr ị số của m àn hình là: 3   thì ta có th ể khẳng định loại m àn hình đang dùng là EGA.",LTHDT_PhamVanAt.pdf - Sentence 1884
1885,Chú ý 4.,LTHDT_PhamVanAt.pdf - Sentence 1885
1886,Nếu chuỗi d ùng đ ể xác định driverpath l à một chuỗi rỗng (nh ư trong ví d ụ 2) th ì  chương t rình d ịch sẽ t ìm các t ệp điều khiển đồ họa tr ên thư m ục chủ.,LTHDT_PhamVanAt.pdf - Sentence 1886
1887,Bài 3.,LTHDT_PhamVanAt.pdf - Sentence 1887
1888,Lỗi đồ họa   Khi kh ởi động hệ thống đồ họa nếu máy không t ìm th ấy các ch ương tr ình điều khiển đồ họa th ì  sẽ phát sinh lỗi đồ họa v à việc khởi động coi nh ư không thành.,LTHDT_PhamVanAt.pdf - Sentence 1888
1889,L ỗi đồ họa c òn phát si nh khi dùng  các hàm đ ồ hoạ.,LTHDT_PhamVanAt.pdf - Sentence 1889
1890,"Trong mọi tr ường hợp, h àm graphresult cho bi ết có lỗi hay không lỗi v à đó là l ỗi  gì.",LTHDT_PhamVanAt.pdf - Sentence 1890
1891,B ảng 8 -3 cho các mã l ỗi mà hàm này phát hi ện được.,LTHDT_PhamVanAt.pdf - Sentence 1891
1892,"Ta có thể d ùng hàm grapherrormsg v ới mã  lỗi do h àm graphresult tr ả về để biết đ ược đó l à lỗi gì, ví d ụ:  int maloi;   maloi = graphresult();   printf("" \nLỗi đồ họa l à: %d"", grapherrormsg(maloi));   Bảng 8 -3.",LTHDT_PhamVanAt.pdf - Sentence 1892
1893,Các mã l ỗi của Graphresult   Hằng Trị Lỗi phát hiện   grOk  0 Không có l ỗi  grNoInitGraph  -1 Chưa kh ởi động hệ đồ họa   grNotDetected  -2 Không có ph ần cứng đồ họa   grFileNotFound  -3 Không tìm th ấy trình điều khiển đồ họa   grInvalidDriver  -4 Trình điều khiển không hợp lệ   grNoLoadMem  -5 Không đ ủ RAM cho đồ họa   grNoScanMem  -6 Vượt vùng RAM trong Scan fill   grNoFloodMem  -7 Vượt vùng RAM trong flood fill   grFontNoFound  -8 Không tìm th ấy tập tin Font   grNoFontMem  -9 Không đ ủ RAM để nạp Font  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          308                                         tenshi3003@gmail.com  grInvalidMode  -10 Kiểu đồ họa không hợp lệ cho tr ình điều khiển   grError  -11 Lỗi đồ họa tổng quát   grIOerror  -12 Lỗi đồ họa v ào ra   grInvalidFont  -13 Tập tin Font không h ợp lệ   grInvalidFontNum  -14 Số hiệu Font không hợp lệ   Bài 4.,LTHDT_PhamVanAt.pdf - Sentence 1893
1894,M ầu và mẫu  1.,LTHDT_PhamVanAt.pdf - Sentence 1894
1895,Để chọn mầu nền ta sử dụng h àm  void setbkcolor(int color);   2.,LTHDT_PhamVanAt.pdf - Sentence 1895
1896,Để chọn mầu đ ường vẽ ta d ùng hàm   void setcolor(int color);   3.,LTHDT_PhamVanAt.pdf - Sentence 1896
1897,"Để chọn mẫu (kiểu) tô v à mầu tô ta d ùng hàm   void setfil lstyle(int pattern, int color);   Trong c ả 3 tr ường hợp color xác định m ã của mầu.",LTHDT_PhamVanAt.pdf - Sentence 1897
1898,"Các giá trị khả dĩ của color cho trong bảng 8 - 4, pattern xác đ ịnh m ã của mẫu tô (xem bảng 8 -5).",LTHDT_PhamVanAt.pdf - Sentence 1898
1899,"Mẫu tô v à mầu tô sẽ đ ược sử dụng trong các h àm pieslice, fillpoly, bar, bar3d v à floodfill (xem  §5 dưới đây).",LTHDT_PhamVanAt.pdf - Sentence 1899
1900,4.,LTHDT_PhamVanAt.pdf - Sentence 1900
1901,"Ch ọn giải mầu   Để thay đổi giải mầu đ ã được định nghĩa trong bảng 8.4 ta d ùng hàm   void setpalette(int colornum, int color);   Ví dụ câu l ệnh  setpalette(0, Lightcyan);   biến mầu đầu ti ên trong b ảng mầu th ành xanh lơ nh ạt.",LTHDT_PhamVanAt.pdf - Sentence 1901
1902,Các m ầu khác không bị ảnh h ưởng.,LTHDT_PhamVanAt.pdf - Sentence 1902
1903,Bảng 8 -4.,LTHDT_PhamVanAt.pdf - Sentence 1903
1904,Các giá tr ị khả dĩ của color   Tên h ằng Giá tr ị số Mầu hiển thị   BLACK  0 Đen  BLUE  1 Xanh da tr ời  GREEN  2 Xanh lá cây   CYAN  3 Xanh lơ   RED  4 Đỏ  MAGENTA  5 Tím   BROWN  6 Nâu  LIHGTGRAY  7 Xám nh ạt  DARKGRAY  8 Xám s ẫm  LIGHTBLUE  9 Xanh da tr ời nhạt   LIGHTGREEN  10 Xanh lá cây nh ạt  LIGHTCYAN  11 Xanh lơ nh ạt  LIGHTRED  12 Đỏ nhạt   LIGHTMAGENTA  13 Tím nh ạt  YELLOW  14 Vàng  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          309                                         tenshi3003@gmail.com  WHITE  15 Trắng   5.,LTHDT_PhamVanAt.pdf - Sentence 1904
1905,"Để nhận giải mầu hiện h ành ta dùng hàm   void getpalette (struct palettetype *palette);   ở đây palettetype l à kiểu đã định nghĩa tr ước nh ư sau:   #define MAXCOLORS 15   struct palettetype   {  unsigned char size;   unsigned char colors[MAXCOLORS+1];   };  ở đây: size l à số lượng mầu trong palette, colors l à mảng chứa mầu với chỉ số mảng chạy từ 0 đến  size - 1      Bảng 8 -5.",LTHDT_PhamVanAt.pdf - Sentence 1905
1906,Các giá tr ị khả dĩ của pattern   Tên h ằng Giá tr ị số Mô t ả kiểu tô   EMPTY_FILL  0 Tô bằng mầu nền   SOLID_FILL  1 Tô bằng đ ường nét liền   LINE_FILL  2 Tô bằng - - -  LTSLASH_FILL  3 Tô bằng ///   SLASH_FILL  4 Tô bằng /// in đậm   BKSLASH_FILL  5 Tô bằng \\\ in đậm  LTBKSLASH_FILL  6 Tô bằng \\\  HATCH_FILL  7 Tô bằng đ ường gạch bóng nhạt   XHATCH_FILL  8 Tô bằng đ ường gạch bóng chữ thập   INTERLEAVE_FILL  9 Tô bằng đ ường đứt qu ãng  WIDE_DOT_FILL  10 Tô bằng dấu chấm th ưa  CLOSE_DOT_FILL  11 Tô bằng dấu chấm  mau  6.,LTHDT_PhamVanAt.pdf - Sentence 1906
1907,Hàm getcolor  trả về mầu đ ã xác định tr ước đó bằng h àm setcolor.,LTHDT_PhamVanAt.pdf - Sentence 1907
1908,7.,LTHDT_PhamVanAt.pdf - Sentence 1908
1909,Hàm getbkcolor  trả về mầu đ ã xác định tr ước đó bằng h àm setbkcolor.,LTHDT_PhamVanAt.pdf - Sentence 1909
1910,8.,LTHDT_PhamVanAt.pdf - Sentence 1910
1911,Hàm getmaxcolor  trả về m ã mầu cực đại thuộc giải mầu hiện đang có hiệu lực.,LTHDT_PhamVanAt.pdf - Sentence 1911
1912,"Tr ên 256 K  EGA, hàm getmaxcolor l uôn cho giá tr ị 15.",LTHDT_PhamVanAt.pdf - Sentence 1912
1913,Bài 5.,LTHDT_PhamVanAt.pdf - Sentence 1913
1914,Vẽ và tô m ầu  Có th ể chia các đ ường v à hình thành b ốn nhóm chính:   - Đường tr òn và ellipse   - Đường gấp khúc v à hình đa giác   - Đường thẳng   - Hình ch ữ nhật   454 Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          310                                         tenshi3003@gmail.com  A.,LTHDT_PhamVanAt.pdf - Sentence 1914
1915,"Đư ờng tr òn và hình tròn   Nhóm này g ồm cung tr òn, đường tr òn, cung ellips e và hình qu ạt.",LTHDT_PhamVanAt.pdf - Sentence 1915
1916,1.,LTHDT_PhamVanAt.pdf - Sentence 1916
1917,Cung tròn.,LTHDT_PhamVanAt.pdf - Sentence 1917
1918,"Để vẽ một cung tr òn ta dùng hàm   void arc(int x, int y, int gd, int gc, int r);   ở đây:   (x, y) là t ọa độ của tâm cung tr òn,  r là bán kính    gd là góc đ ầu  gc là góc cu ối  Chú ý:  Trong t ất cả các h àm dư ới đây, góc tính theo độ v à có giá tr ị từ 0 đến 360.",LTHDT_PhamVanAt.pdf - Sentence 1918
1919,2.,LTHDT_PhamVanAt.pdf - Sentence 1919
1920,Đư ờng tr òn.,LTHDT_PhamVanAt.pdf - Sentence 1920
1921,"Để vẽ một đ ường tr òn ta dùng hàm   void circle(int x, int y, int r);   ở đây:   (x, y) là t ọa độ của tâm;   r là bán kính đư ờng tr òn.",LTHDT_PhamVanAt.pdf - Sentence 1921
1922,3.,LTHDT_PhamVanAt.pdf - Sentence 1922
1923,Cung ellipse.,LTHDT_PhamVanAt.pdf - Sentence 1923
1924,"Để vẽ một cung Ellipse ta d ùng hàm   void ellipse(int x,int y,int gd,int gc,i nt xr,int yr);   ở đây:   (x, y) là t ọa độ của tâm cung Ellipse   gd là góc đ ầu  gc là góc cu ối  xr là bán tr ục ngang    yr là bán tr ục đứng.",LTHDT_PhamVanAt.pdf - Sentence 1924
1925,4.,LTHDT_PhamVanAt.pdf - Sentence 1925
1926,Hình qu ạt.,LTHDT_PhamVanAt.pdf - Sentence 1926
1927,"Để vẽ v à tô màu m ột hình qu ạt ta d ùng hàm   void pieslice(int x,int y,int gd,int gc,int r);   ở đây:   (x,y) là t ọa độ tâm h ình qu ạt  gd là góc đ ầu  gc là góc cu ối  r là bán kính   Ví dụ 1.",LTHDT_PhamVanAt.pdf - Sentence 1927
1928,"Chương tr ình d ưới đây sẽ vẽ: một cung tr òn ở góc phần t ư thứ nhất, một cung ellipse ở  góc ph ần tư thứ ba, một đ ường tr òn và m ột hình qu ạt quét từ 90 đến 360 độ.",LTHDT_PhamVanAt.pdf - Sentence 1928
1929,"#include <graphics.h>   main ()  {  int mh, mode;   // Kh ởi động đồ họa, m àn hình EGA, mode EGALO   mh=EGA;   mode=EGALO;   initgraph(&mh, &mode,"""");  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          311                                         tenshi3003@gmail.com  // Mầu nền Green, mầu đ ường vẽ   //White, m ầu tô Red, kiểu tô SlashFill   setbkcolor (GREEN);   setcolor (WHITE);   setfillstyle (SLASH_FILL, RED);   // Vẽ: một cung tr òn ở góc phần t ư thứ nhất,   // một cung Ellipse ở góc phần t ư thứ ba,   // một đường tr òn, m ột quạt tr òn   arc(160, 50, 0, 90, 45);   ellipse(480, 50, 180, 270, 150, 45);   circle(160, 150, 45);   pieslice(480, 150, 90, 360, 45);   // Kết thúc chế độ đồ  họa   closegraph();   }  B.",LTHDT_PhamVanAt.pdf - Sentence 1929
1930,Đư ờng gấp khúc v à đa giác   5.,LTHDT_PhamVanAt.pdf - Sentence 1930
1931,"Mu ốn vẽ một đ ường gấp khúc đi qua n điểm : (x1,y1), ...",LTHDT_PhamVanAt.pdf - Sentence 1931
1932,", (xn,yn) thì tr ước hết ta phải đ ưa các  tọa độ v ào m ột mảng a n ào đó ki ểu int.",LTHDT_PhamVanAt.pdf - Sentence 1932
1933,"Nói một cách chính xác h ơn, c ần gán x1 cho a[0], y1 cho  a[1], x2 cho  a[2], y2 cho a[3],...",LTHDT_PhamVanAt.pdf - Sentence 1933
1934,"Sau đó ta vi ết lời gọi h àm:  drawpoly(n, a);   Khi đi ểm cuối (xn, yn) tr ùng v ới điểm đầu (x1, y1) ta nhận đ ược một đ ường gấp khúc khép kín.",LTHDT_PhamVanAt.pdf - Sentence 1934
1935,6.,LTHDT_PhamVanAt.pdf - Sentence 1935
1936,"Gi ả sử a l à mảng đ ã nói trong điểm 5, khi đó lời gọi h àm  fillpoly(n, a);   sẽ vẽ v à tô m ầu một đa giác có đ ỉnh là các đi ểm  (x1, y1), ...",LTHDT_PhamVanAt.pdf - Sentence 1936
1937,",(xn, yn).",LTHDT_PhamVanAt.pdf - Sentence 1937
1938,Ví dụ 2.,LTHDT_PhamVanAt.pdf - Sentence 1938
1939,Chương tr ình d ưới đây sẽ vẽ một đ ường gấp khúc v à hai hình tam giác.,LTHDT_PhamVanAt.pdf - Sentence 1939
1940,"#include <graphics.h>   // Xây d ựng các mảng chứa tọa độ các đỉnh   int poly1[]={5,200,190,5,100,300};   int poly2[]={205,200,390, 5,300,300};   int poly3[]={405,200,590,5,500,300,405,200};   main()   {  int mh=0, mode=0;   initgraph(&mh, &mode, """");   // Mầu nền CYAN, mầu đ ường vẽ   // YELLOW, m ầu tô MAGENTA, mẫu tô SolidFill   setbkcolor (CYAN); Setcolor (YELLOW);   setfillstyle (SOLID_FILL, MAGENT A); Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          312                                         tenshi3003@gmail.com  drawpoly (3, poly1); // Đư ờng gấp khúc   fillpoly (3, poly2); // Hình đa giác   fillpoly(4, poly3); // Hình đa giác   closegraph();   }  C.",LTHDT_PhamVanAt.pdf - Sentence 1940
1941,Đư ờng thẳng   7.,LTHDT_PhamVanAt.pdf - Sentence 1941
1942,"Hàm   void line(int x1,int y1,int x2,int y2);   vẽ đường thẳng nối hai điểm (x1, y1) v à (x2, y2) nhưng khôn g làm thay đ ổi vị trí con chạy.",LTHDT_PhamVanAt.pdf - Sentence 1942
1943,8.,LTHDT_PhamVanAt.pdf - Sentence 1943
1944,"Hàm   void lineto(int x,int y);   vẽ đường thẳng từ điểm hiện tại tới điểm (x, y) v à chuy ển con chạy đến điểm (x, y).",LTHDT_PhamVanAt.pdf - Sentence 1944
1945,9.,LTHDT_PhamVanAt.pdf - Sentence 1945
1946,"Hàm   void linerel(int dx,int dy);   vẽ một đ ường thẳng từ vị trí hiện tại (x, y) của con chạy đến điểm    ( x + dx,y + dy).",LTHDT_PhamVanAt.pdf - Sentence 1946
1947,Con ch ạy được  di chuy ển đến vị trí mới.,LTHDT_PhamVanAt.pdf - Sentence 1947
1948,10.,LTHDT_PhamVanAt.pdf - Sentence 1948
1949,"Hàm   void moveto(int x,int y);   sẽ di chuyển con chạy tới vị trí (x, y).",LTHDT_PhamVanAt.pdf - Sentence 1949
1950,Ví d ụ 3.,LTHDT_PhamVanAt.pdf - Sentence 1950
1951,Chương tr ình d ưới đây tạo l ên m ột đường gấp khúc bằng các đoạn thẳng.,LTHDT_PhamVanAt.pdf - Sentence 1951
1952,"Đ ường gấp  khúc đi qua các đ ỉnh: (20, 20), (620 , 20), (620, 180), (20, 180) và (320, 100).",LTHDT_PhamVanAt.pdf - Sentence 1952
1953,"#include <graphics.h>   main()   {  int mh=0, mode=0;   initgraph(&mh, &mode, """");   setbkcolor(GREEN);   setcolor(YELLOW);   moveto(320,100);   line(20,20,620,20);   linerel( -300,80);   lineto(620,180);   lineto(620,20);   closegraph( );  }  D.",LTHDT_PhamVanAt.pdf - Sentence 1953
1954,Hình ch ữ nhật   11.,LTHDT_PhamVanAt.pdf - Sentence 1954
1955,"Hàm   void rectangle(int x1,int y1,int x2,int y2);  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          313                                         tenshi3003@gmail.com  sẽ vẽ một đ ường chữ nhật có các cạnh song song với các cạnh của m àn hình.",LTHDT_PhamVanAt.pdf - Sentence 1955
1956,"T ọa độ đỉnh tr ên bên  trái c ủa hình ch ữ nhật l à (x1,y1) và đi ểm d ưới bên ph ải là (x2,y2).",LTHDT_PhamVanAt.pdf - Sentence 1956
1957,12.,LTHDT_PhamVanAt.pdf - Sentence 1957
1958,"Hàm   void bar(i nt x1,int y1,int x2,int y2);   sẽ vẽ v à tô m ầu một h ình ch ữ nhật.",LTHDT_PhamVanAt.pdf - Sentence 1958
1959,"Các giá trị x1,y1,x2 v à y2 có ý ngh ĩa nh ư đã nói trong điểm 11.",LTHDT_PhamVanAt.pdf - Sentence 1959
1960,13.,LTHDT_PhamVanAt.pdf - Sentence 1960
1961,"Hàm   void bar3d(int x1,int y1,int x2,int y2,int depth,int top);   sẽ vẽ một khối hộp chữ nhật, mặt ngo ài của nó l à hình ch ữ nhậ t xác đ ịnh bởi các tọa độ x1,y1,x2,y2  (như đ ã nói trong điểm 12).",LTHDT_PhamVanAt.pdf - Sentence 1961
1962,H ình ch ữ nhật n ày đư ợc tô mầu.,LTHDT_PhamVanAt.pdf - Sentence 1962
1963,Tham số depth ấn định số điểm ảnh  trên b ề sâu của khối 3 chiều.,LTHDT_PhamVanAt.pdf - Sentence 1963
1964,Tham số top có thể nhận trị 1 (TOPON) hay 0 (TOPOFF) v à khối 3  chiều sẽ có nắp hay không nắp (x em hình v ẽ).,LTHDT_PhamVanAt.pdf - Sentence 1964
1965,TOPON  TOPOFF   Ví dụ 4.,LTHDT_PhamVanAt.pdf - Sentence 1965
1966,"Chương tr ình d ưới đây sẽ vẽ một đ ường chữ nhật, một h ình ch ữ nhật v à một khối hộp  chữ nhật có nắp.",LTHDT_PhamVanAt.pdf - Sentence 1966
1967,"#include <graphics.h>   main()   {  int mh=0, mode=0;   initgraph(&mh, &mode, """");   setbkcolor(GREEN);   setcolor(RE D);  setfillstyle(CLOSE_DOT_FILL,YELLOW);   rectangle(5,5,300,160);   bar(5,175,300,340);   bar3d(320,100,500,340,100,1);   closegraph();   }  Bài 6.",LTHDT_PhamVanAt.pdf - Sentence 1967
1968,Ch ọn kiểu đ ường  1.,LTHDT_PhamVanAt.pdf - Sentence 1968
1969,"Hàm   void setlinestyle(int linestyle,int pattern,int thickness);   tác đ ộng đến nét vẽ của các thủ tục  line, lineto, rectange, drawpoly, circle,...",LTHDT_PhamVanAt.pdf - Sentence 1969
1970,"Hàm này cho phép ta  ấn định 3 yếu tố của đ ường thẳng l à dạng, bề dầy v à mẫu tự tạo.",LTHDT_PhamVanAt.pdf - Sentence 1970
1971,+ Dạng đ ường do tham số linestyle khống chế.,LTHDT_PhamVanAt.pdf - Sentence 1971
1972,Sau đây l à các giá tr ị khả dĩ của linestyle v à dạng  đường thẳng t ương ứng.,LTHDT_PhamVanAt.pdf - Sentence 1972
1973,SOLID_ LINE = 0  Nét li ền   DOTTED_LINE = 1  Nét ch ấm Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          314                                         tenshi3003@gmail.com  CENTER_LINE = 2  Nét ch ấm gạch   DASHED_LINE = 3  Nét g ạch  USERBIT_LINE = 4  Mẫu tự tạo   + Bề dầy do tham số thickness khống chế.,LTHDT_PhamVanAt.pdf - Sentence 1973
1974,Giá trị n ày có th ể là:  NORM_WIDTH = 1  Bề dầy b ình th ường  THICK_WIDTH = 3  Bề dầy g ấp ba   + Mẫu tự tạo: Nếu tham số thứ nhất l à USERBIT_LINE thì ta có th ể tạo ra mẫu đ ường thẳng  bằng tham số pattern.,LTHDT_PhamVanAt.pdf - Sentence 1974
1975,"Ví dụ xét đoạn ch ương tr ình:  int pattern= 0x1010;   setlinestyle(USERBIT_LINE, pattern, NORM_WIDTH);   line(0,0,100,200);   Giá tr ị của pattern t rong h ệ 16 l à 0x1010 hay trong h ệ 2 là  0001  0000  0001  0000   Chỗ nào có bit 1 đi ểm ảnh sẽ sáng, bit 0 l àm tắt điểm ảnh.",LTHDT_PhamVanAt.pdf - Sentence 1975
1976,2.,LTHDT_PhamVanAt.pdf - Sentence 1976
1977,Để nhận các giá trị hiện h ành c ủa 3 yếu tố tr ên ta dùng hàm:   void getlinesettings(struct linesettingstype *lineinfo);   với kiểu lines ettingstype đ ã được định nghĩa tr ước nh ư sau:   struct linesettingstype   {  int linestyle;   unsigned int upattern;   int thickness;   };  Ví d ụ 1.,LTHDT_PhamVanAt.pdf - Sentence 1977
1978,Chương tr ình d ưới đây minh họa cách d ùng các hàm setlinestyle và getlinesettings đ ể  vẽ đường thẳng.,LTHDT_PhamVanAt.pdf - Sentence 1978
1979,"// kiểu đường  #incl ude <graphics.h>   #include <conio.h>   main()   {  struct linesettingstype kieu_cu;   int mh=0, mode=0;   initgraph(&mh, &mode, """");   if (graphresult!= grOk) exit(1);   setbkcolor(GREEN); setcolor(RED);   line(0,0,100,0);   // Lưu l ại kiểu hiện tại   getlinesettings(kieu_c u);  // Thi ết lập kiểu mới   setlinestyle(DOTTED_LINE,0,THICK_WIDTH);   line(0,0,100,10);  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          315                                         tenshi3003@gmail.com  // Ph ục hồi kiểu cũ   setlinestyle(kieu_cu.linestyle,   kieu_cu.upattern, kieu_cu.thickness);   Line(0,20,100,20);   getch();   closegraph();   }  3.",LTHDT_PhamVanAt.pdf - Sentence 1979
1980,"Hàm   void setwritemode( int writ emode);   sẽ thiết lập kiểu thể hiện đ ường thẳng cho các h àm line, drawpoly, linerel, lineto, rectangle.",LTHDT_PhamVanAt.pdf - Sentence 1980
1981,"Ki ểu  thể hiện do tham số writemode khống chế:   - Nếu writemode bằng COPY_PUT = 0, th ì đường thẳng đ ược viết đ è lên dòng đang có trên màn  hình.",LTHDT_PhamVanAt.pdf - Sentence 1981
1982,"- Nếu write mode b ằng XOR_PUT = 1, th ì mầu của đ ường thẳng định vẽ sẽ kết hợp với mầu của  từng chấm điểm của đ ường hiện có tr ên màn hình theo phép toán XOR (ch ương 3, §3) để tạo l ên  một đường thẳng mới.",LTHDT_PhamVanAt.pdf - Sentence 1982
1983,Một ứng dụng của XOR_PUT l à: Khi thi ết lập kiểu writemode bằng XO R_PUT r ồi vẽ lại đ ường  thẳng c ùng m ầu th ì sẽ xóa đ ường thẳng cũ v à khôi ph ục trạng thái  của  m àn hình.,LTHDT_PhamVanAt.pdf - Sentence 1983
1984,Chương tr ình d ưới đây minh họa cách d ùng hàm setwritemode.,LTHDT_PhamVanAt.pdf - Sentence 1984
1985,Khi th ực hiện ta sẽ thấy h ình ch ữ  nhật thu nhỏ dần v ào tâm màn hình.,LTHDT_PhamVanAt.pdf - Sentence 1985
1986,"Ví dụ 2:  // Thu hình;   #include <graphics.h>   #include <conio.h>   main()   {  struct linesettingstype kieu_cu;   int mh=0, mode=0, x1, y1, x2, y2;   initgraph(&mh, &mode, """");   if (graphresult!= grOk) exit(1);   setbkcolor(GREEN);   setcolor(RED);   setfillstyle(CLOSE_DOT_FILL, YELLOW);   x1=0; y1 =0;  x2=getmaxx(); y2=getmaxy();   setwritemode(XOR_PUT);   tt: rectangle(x1,y1,x2,y2); // V ẽ hình ch ữ nhật   if ( (x1+1)<(x2 -1) && (y1+1)<(y2 -1) )  {  rectangle(x1,y1,x2,y2); // xóa hình ch ữ nhật   x1=x1+1; y1=y1+1; co hình ch ữ nhật   x2=x2 -1; y2=y2 -1; Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          316                                         tenshi3003@gmail.com  goto tt;   }  setwritemode(COPY_PUT); // Tr ở về overwrite mode   closegraph();   }  Bài 7.",LTHDT_PhamVanAt.pdf - Sentence 1986
1987,Cửa sổ (Viewpor t)  1.,LTHDT_PhamVanAt.pdf - Sentence 1987
1988,Viewport  là một vùng ch ữ nhật tr ên màn hình đồ họa tựa nh ư window trong textmode.,LTHDT_PhamVanAt.pdf - Sentence 1988
1989,"Đ ể thiết  lập viewport ta d ùng hàm   void setviewport(int x1,int y1,int x2,int y2,int clip);   trong đó (x1,y1) là t ọa độ góc tr ên bên trái và (x2,y2) là t ọa độ góc d ưới bên phải.",LTHDT_PhamVanAt.pdf - Sentence 1989
1990,Bốn giá trị n ày  phải thỏa m ãn:  0 <= x1 <= x2   0 <= y1 <= y2   Tham s ố clip có thể nhận một trong hai giá trị:   clip = 1 không cho phép v ẽ ra ngo ài viewport   clip = 0 Cho phép v ẽ ra ngo ài viewport.,LTHDT_PhamVanAt.pdf - Sentence 1990
1991,"Ví dụ câu l ệnh  setviewport(100,50,200,150, 1);   sẽ thiết lập viewport.",LTHDT_PhamVanAt.pdf - Sentence 1991
1992,"Sau khi lập viewport ta có hệ tọa độ mới m à góc trên bên trái c ủa viewport sẽ  có tọa độ (0,0).",LTHDT_PhamVanAt.pdf - Sentence 1992
1993,2.,LTHDT_PhamVanAt.pdf - Sentence 1993
1994,"Để nhận viewport hiện h ành ta dùng hàm   void getviewsettings(struct viewporttype *vp);   ở đây kiểu viewporttype đ ã được định nghĩa nh ư sau:   struct  viewporttype   {  int left, top, right, bottom;   int clip;   };  3.",LTHDT_PhamVanAt.pdf - Sentence 1994
1995,Để xóa viewport ta d ùng hàm   void clearviewport(void);   4.,LTHDT_PhamVanAt.pdf - Sentence 1995
1996,"Để xóa m àn hình và đưa con ch ạy về tọa độ (0,0) của m àn hình ta dùng hàm   void cleardevice(void);   Chú ý:  Câu l ệnh n ày sẽ xóa mọi thứ tr ên màn hình.",LTHDT_PhamVanAt.pdf - Sentence 1996
1997,5.,LTHDT_PhamVanAt.pdf - Sentence 1997
1998,Tọa độ âm d ương   Nhờ sử dụng Viewport có thể viết các ch ương tr ình đồ họa theo tọa độ âm d ương.,LTHDT_PhamVanAt.pdf - Sentence 1998
1999,Mu ốn vậy ta  thiết lập viewport sao cho tâm tuyệt đối của m àn hình là góc trên bên trái c ủa viewport v à cho clip =  0 để có thể vẽ ra ngo ài giới hạ n của viewport.,LTHDT_PhamVanAt.pdf - Sentence 1999
2000,"Sau đây l à đoạn ch ương tr ình th ực hiện công việc  trên  int xc, yc;   xc= getmaxx()/2; yc= getmaxy()/2;  464 Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          317                                         tenshi3003@gmail.com  setviewport(xc, yc, getmaxx(), getmaxy(), 0);   Như th ế màn hình s ẽ được chia l àm 4 ph ần với tọa độ âm d ương như sau:   Phần tư trái trên:  x âm, y âm   Phần tư trái dư ới:  x âm, y d ương   Phần tư phải trên:  x dương, y âm   Phần tư phải dưới:  x d ương, y dương   Chương tr ình d ưới đây vẽ đồ thị h àm sin(x) trong h ệ trục tọa độ âm d ương.",LTHDT_PhamVanAt.pdf - Sentence 2000
2001,Hoành đ ộ x lấy các  giá tr ị từ -4*PI đ ến 4*PI.,LTHDT_PhamVanAt.pdf - Sentence 2001
2002,Trong chương tr ình có dùng hai hàm m ới là: outtextxy và putpixel (xem  các m ục sau).,LTHDT_PhamVanAt.pdf - Sentence 2002
2003,"Ví dụ 1:  // đồ thị h àm sin   #include <graphics.h>   #include <conio.h>   #include <math.h>   #define SCALEX 20   #define SCALEY 60   main()   {  int mh=0, mode=0, x, y, i;   initgraph( &mh, &mode, """");   if (graphresult!= grOk) exit(1);   setviewport(getmaxx()/,getmaxy()/2,   getmaxx(),getmaxy(), 0);   // Kẻ hệ trục tọa độ   setcolor(BLUE);   line(-(getmaxx()/2),0,getmaxx()/2,0);   line(0, -(getmaxy()/2),0,getmaxy()/2);   settextjustify(1,1); setcolor( RED);   outtextxy(0,0,""(0,0)"");   for (i= -400;i<=400;++i)   {  x=round(2*M_PI*i*SCALEX/200);   y=round(sin(2*M_PI*i/200)*SCALEY);   putpixel(x,y,YELLOW);   }  getch();   }  Ví dụ 1 tạo lên m ột đồ thị từ các chấm điểm.",LTHDT_PhamVanAt.pdf - Sentence 2003
2004,"Bây giờ ta sửa ví dụ 1 đôi chút: giữ nguy ên từ đầu  đến outtextxy, thay ph ần cuối bởi đoạn ch ương tr ình d ưới đây.",LTHDT_PhamVanAt.pdf - Sentence 2004
2005,Ta sẽ đ ược đồ thị từ các đoạn thẳng  rất ngắn ghép lại.,LTHDT_PhamVanAt.pdf - Sentence 2005
2006,"Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          318                                         tenshi3003@gmail.com  Ví dụ 2:  // Ph ần đầu giống ví dụ 1   setcolor(YELLOW);   for (i= -400;i<=400;++i)   {  x=round(2*M_PI*i*SCALEX/200);   y=round(sin(2*M_PI*i/200)*SCALE Y);  if(i= -400) moveto(x,y);   else lineto(x,y);   }  getch();   }  Bài 8.",LTHDT_PhamVanAt.pdf - Sentence 2006
2007,"Tô đi ểm, tô miền   1.",LTHDT_PhamVanAt.pdf - Sentence 2007
2008,"Hàm   void putpixel(int x, int y, int color);   sẽ tô điểm (x,y) theo mầu xác định bởi color.",LTHDT_PhamVanAt.pdf - Sentence 2008
2009,2.,LTHDT_PhamVanAt.pdf - Sentence 2009
2010,"Hàm   unsigned getpixel(int x, int y);   sẽ trả về số hiệu mầu của điểm ảnh ở vị  trí (x,y).",LTHDT_PhamVanAt.pdf - Sentence 2010
2011,Chú ý: n ếu điểm n ày chưa đư ợc tô mầu bởi các  hàm v ẽ hoặc putpixel (m à chỉ mới đ ược tạo mầu nền bởi setbkcolor) th ì hàm cho giá tr ị bằng 0.,LTHDT_PhamVanAt.pdf - Sentence 2011
2012,V ì  vậy có thể d ùng hàm này theo m ẫu dưới đây để xác định các nét vẽ tr ên màn hình đồ hoạ v à vẽ ra  giấy.,LTHDT_PhamVanAt.pdf - Sentence 2012
2013,"if (getpixel(x,y)!=0)   {  // Điểm (x,y) đ ược vẽ , đặt một chấm điểm ra giấy   }  3.",LTHDT_PhamVanAt.pdf - Sentence 2013
2014,"Tô mi ền  Để tô mầu cho một miền n ào đó trên màn h ình ta dùng hàm   void floodfill(int x, int y, int border);   ở đây:   (x,y) là t ọa độ của một điểm n ào đó g ọi là điểm gieo.",LTHDT_PhamVanAt.pdf - Sentence 2014
2015,tham s ố bor der ch ứa m ã của một mầu.,LTHDT_PhamVanAt.pdf - Sentence 2015
2016,"Sự hoạt động của h àm floodfill ph ụ thuộc v ào giá tr ị của x,y, border v à trạng thái m àn hình.",LTHDT_PhamVanAt.pdf - Sentence 2016
2017,"a) Khi trên màn hình có m ột đường (cong hoặc gấp khúc) khép kín m à mã m ầu của nó bằng giá  trị của border th ì:  + Mi ền giới hạn bởi đ ường kí n sẽ được tô mầu nếu điểm gieo (x,y) nằm b ên trong mi ền này.",LTHDT_PhamVanAt.pdf - Sentence 2017
2018,"+ Nếu điểm gieo (x,y) nằm b ên ngoài thì ph ần m àn hình bên ngoài mi ền đóng nói tr ên đư ợc tô  màu.",LTHDT_PhamVanAt.pdf - Sentence 2018
2019,"b) Khi trên màn hình không có m ột đường n ào như v ậy, th ì cả màn hình được tô m àu.",LTHDT_PhamVanAt.pdf - Sentence 2019
2020,Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          319                                         tenshi3003@gmail.com  Ví dụ 1.,LTHDT_PhamVanAt.pdf - Sentence 2020
2021,Chương t rình d ưới đây sẽ vẽ một đ ường tr òn đỏ trên màn hình xanh.,LTHDT_PhamVanAt.pdf - Sentence 2021
2022,"T ọa độ (x,y) của  điểm gieo đ ược nạp v ào từ bàn phím.",LTHDT_PhamVanAt.pdf - Sentence 2022
2023,"Tùy thu ộc vào giá tr ị cụ thể của x,y, ch ương tr ình s ẽ tô mầu  vàng cho hình tròn ho ặc phần m àn hình bên ngoài hình tròn.",LTHDT_PhamVanAt.pdf - Sentence 2023
2024,"#include <graphics.h>   #include <stdio.h>   main()   {  int mh=0, mode=0, x, y;   initgraph(&mh, &mode, """");   if (graphresult!= grOk) exit(1);   setbkcolor(GREEN);   setcolor(RED);   setfillstyle(11,YELLOW);   circle(320,100,50);   moveto(1,150);   outtext("" Toa do diem gieo x,y "");   scanf(""%d%d"",&x,&y ); flooddfill(x,y,RED);   }    Ví dụ 2.",LTHDT_PhamVanAt.pdf - Sentence 2024
2025,Minh h ọa cách d ùng hàm Putpixel và hàm getpixel đ ể vẽ các điểm ảnh v à sau đó xóa  các đi ểm ảnh.,LTHDT_PhamVanAt.pdf - Sentence 2025
2026,Muốn kết thúc ch ương tr ình b ấm ESC.,LTHDT_PhamVanAt.pdf - Sentence 2026
2027,"#include <conio.h>   #include <graphics.h>   #include <stdio.h>   #include <stdlib.h>   int seed = 1962; // Nhân cho b ộ tạo số ngẫu nhi ên   int numpts = 2000; // V ẽ 2000 chấm điểm   int ESC = 27;   void putpixelplay(void);   main()   {  int mh=0, mode=0;   initgraph(&mh, &mode, """");   if (graphresult()!= grOk)   exit(1);   putpixelplay();   closegraph();   }  void putpix elplay(void)   {  int i,x,y,color,xmax,ymax,maxcolor,ch;  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          320                                         tenshi3003@gmail.com  struct viewporttype v;   getviewsettings(&v);   xmax=(v.right - v.left -1); ymax=(v.bottom - v.top -1);  maxcolor=getmaxcolor();   while (!kbhit())   {  //Vẽ các chấm điểm một cách ngẫu nhi ên   srand(seed);   i=0;  while(i<=numpts)   {  ++i;   x=random(xmax)+1;y=random(ymax)+1;   color=random(maxcolor);   putpixel(x,y,color);   }  // Xóa các đi ểm ảnh   srand(seed);   i=0;  while(i<=numpts)   {  ++i;   x= random(xmax) + 1; y= random(ymax) + 1;   color=random(maxcolor);   putpixel(x,y,0);   }  if(kbhit())   {  ch=getch();   if (ch==ESC) break;   }  }  } // K ết thúc h àm putpixelplay     Bài 9.",LTHDT_PhamVanAt.pdf - Sentence 2027
2028,Xử lý văn bản tr ên màn hình đồ hoạ   1.,LTHDT_PhamVanAt.pdf - Sentence 2028
2029,Hi ển thị văn bản tr ên màn hình đồ hoạ   Hàm   void outtext (char *s);  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          321                                         tenshi3003@gmail.com  sẽ  hiện chuỗi ký tự (do s trỏ tới) tại vị trí hiện tại của con trỏ.,LTHDT_PhamVanAt.pdf - Sentence 2029
2030,"Hàm   void outtextxy(int x,int y,char *s);   sẽ  hiện chuỗi ký tự (do s trỏ tới) tại ví trí (x,y).",LTHDT_PhamVanAt.pdf - Sentence 2030
2031,"Ví dụ 1: Hai cách sau đây s ẽ cho c ùng k ết quả   outtextxy (100,100,"" chao ban "");   và  moveto (100,100);   outtext ("" chao ban "");   Chú ý:  Trong m ốt đồ họa vẫn cho  phép dùng hàm nh ập dữ liệu scanf v à các hàm b ắt phím getch,  kbhit.",LTHDT_PhamVanAt.pdf - Sentence 2031
2032,2.,LTHDT_PhamVanAt.pdf - Sentence 2032
2033,Fonts   Như đ ã nói ở trên: Các Fonts n ằm trong các tệp tin .CHR tr ên đĩa.,LTHDT_PhamVanAt.pdf - Sentence 2033
2034,Các Font n ày cho các kích  thước và kiểu chữ khác nhau sẽ hiện thị tr ên màn hình đồ hoạ bằng outtext hay outtextxy .,LTHDT_PhamVanAt.pdf - Sentence 2034
2035,"Để chọn  và nạp Font chúng ta d ùng hàm:   void settextstyle(int font,int direction,int charsize);   (Chú ý:  hàm ch ỉ có tác dụng nếu tồn tại các tệp .CHR)   Với direction l à một trong hai hằng số:   HORIZ_DIR = 0   VERT_DIR = 1   Nếu direction l à HORIZ_DIR, văn b ản sẽ hiển thị theo h ướng nằm ngang từ trái sang phải.",LTHDT_PhamVanAt.pdf - Sentence 2035
2036,"Nếu  direction là VERT_DIR, văn b ản sẽ hiển thị theo chiều đứng từ d ưới lên trên.",LTHDT_PhamVanAt.pdf - Sentence 2036
2037,Đối charsize l à hệ số phóng to ký tự v à có giá tr ị trong khoảng từ 1 đến 10.,LTHDT_PhamVanAt.pdf - Sentence 2037
2038,"- Nếu charsize = 1, ký tự đ ược thể hiện trong h ình ch ữ nhật 8*8 pixel.",LTHDT_PhamVanAt.pdf - Sentence 2038
2039,"- Nếu charsize = 2, ký tự đ ược thể hiện trong h ình ch ữ nhật 16*16 pixel.",LTHDT_PhamVanAt.pdf - Sentence 2039
2040,.,LTHDT_PhamVanAt.pdf - Sentence 2040
2041,.,LTHDT_PhamVanAt.pdf - Sentence 2041
2042,.,LTHDT_PhamVanAt.pdf - Sentence 2042
2043,"- Nếu charsize = 10, ký tự đ ược thể hiện trong h ình ch ữ nhật 80*80 pixel.",LTHDT_PhamVanAt.pdf - Sentence 2043
2044,Cuối cùng là tham s ố font để chọn kiểu chữ v à nhận một trong các hằng sau:   DEFA ULT_FONT = 0   TRIPLEX_FONT = 1   SMALL_FONT = 2   SANS_SERIF_FONT = 3   GOTHIC_FONT = 4   Các giá tr ị do settextstyle thiết lập sẽ dữ nguy ên cho đ ến khi gọi một settextstyle mới.,LTHDT_PhamVanAt.pdf - Sentence 2044
2045,"Ví dụ 2:  settextstyle (3,VERT_DIR,2);   outtextxy (50,50,"" HELLO "");   3.",LTHDT_PhamVanAt.pdf - Sentence 2045
2046,"Vị trí hiển th ị  Hàm settextjustify cho phép ấn định n ơi hiển thị văn bản của outtext theo quan hệ với vị trí hiện  tại của con chạy hay của outtextxy theo quan hệ với toạ độ (x,y).",LTHDT_PhamVanAt.pdf - Sentence 2046
2047,"Hàm này có d ạng Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          322                                         tenshi3003@gmail.com  void settextjustify(int horiz, int vert);   Tham s ố horiz có thể l à một tron g các h ằng số sau:   LEFT_TEXT = 0 (Văn b ản xuất hiện b ên ph ải con chạy)   CENTER_TEXT = 1 (Ch ỉnh tâm văn bản theo vị trí con chạy)   RIGHT_TEXT = 2 (Văn b ản xuất hiện b ên trái con ch ạy)  Tham s ố Vert có thể l à một trong các hằng số sau:   BOTTOM_TEXT = 0 (Văn b ản xuất hiện phía tr ên con ch ạy)  CENTER_TEXT = 1 (Ch ỉnh tâm văn bản theo vị trí con chạy)   TOP_TEXT = 2 (Văn b ản xuất hiện phía d ưới con chạy)   Ví dụ 3:  settextjustify(1,1);   outtextxy(100,100,""ABC"");   Kết quả l à điểm (100,100) sẽ nằm giữa chữ B.",LTHDT_PhamVanAt.pdf - Sentence 2047
2048,4.,LTHDT_PhamVanAt.pdf - Sentence 2048
2049,Bề rộng v à bề cao c ủa văn bản   Hàm   void textheight (char *s);   trả về chiều cao (theo pixel) của chuỗi do s trỏ tới.,LTHDT_PhamVanAt.pdf - Sentence 2049
2050,"Ví dụ nếu ký tự có kích th ước  8*8 th ì  textheight (""H"") = 8   Ví dụ 4: Đoạn ch ương tr ình d ưới đây sẽ cho hiện 5 d òng ch ữ.",LTHDT_PhamVanAt.pdf - Sentence 2050
2051,"#include <graphics.h>   main()   {  int mh=0,mode=0,y,size;   initgraph(&mh,&mode,"""");   y=10;   settextjustify(0,0);   for (size=1; size<=5; ++size)   {  settextstyle(0,0,size);   outtextxy(0,y,""GRAPHICS"");   y += textheight(""GRAPHICS"") + 10;   }  getch();   closegraph();   }  Hàm   void textwidth(char *s);   sẽ dựa v ào chi ều dài của chuỗi, kích th ước Font chữ, hệ số khuyếch đại chữ để trả về bề rộng (theo  pixel) c ủa chuỗi do s trỏ tới.",LTHDT_PhamVanAt.pdf - Sentence 2051
2052,Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          323                                         tenshi3003@gmail.com  Ví dụ 5: Trong chương tr ình d ưới đây sẽ lập các h àm vào ra trên màn hình đồ hoạ.,LTHDT_PhamVanAt.pdf - Sentence 2052
2053,"#include <graphics.h>   #include <conio.h>   #define Enter  13  #define Lmargin 10   void text_write(int *x,int *y,char *s);   void text_writeln(int *x,int *y,char *s);   void text_read(int *x,int *y,char *s);   void text_write(int *x,int *y,char *s)   {  outtextxy(*x,*y,s); *x += textwidth(s);   }   void text_writeln(int *x,in t *y,char *s)   {  outtextxy(*x,*y,s);   *x=Lmargin;   *y += textheight(s)+5;   }  void text_read(int *x,int *y,char *s)   {  int i=0; char ch[2];   ch[1]=0;   while(1)   {  ch[0]=getch();   if(ch[0]==Enter) break;   text_write(x,y,ch);   s[i]=ch[0]; ++i;   }  s[i]=0;   }  main()   {  int mh=0,mode=0,x,y,xmax,ymax;   char name[25];   initgraph(&mh,&mode,"""");   settextstyle(TRIPLEX_FONT,HORIZ_DIR,3);   x=Lmargin; y=100;   text_write (&x,&y,""cho ten cua ban: "");  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          324                                         tenshi3003@gmail.com  text_read (&x,&y,name);   text_writeln (&x,&y,"""" );   text_write(&x,&y,""chao ban "");   text_write (&x,&y,name);   getch();   closegraph();   }      Bài 10.",LTHDT_PhamVanAt.pdf - Sentence 2053
2054,"C ắt hình, Dán hình và T ạo ảnh chuyển động   1.",LTHDT_PhamVanAt.pdf - Sentence 2054
2055,"Hàm   unsigned imagesize(int x1,int y1,int x2,int y2)   trả về số byte cần thiết để l ưu tr ữ ảnh trong phạm vi h ình ch ữ nhật (x1,y1,x2,y2).",LTHDT_PhamVanAt.pdf - Sentence 2055
2056,2.,LTHDT_PhamVanAt.pdf - Sentence 2056
2057,Hàm   #include <alloc.h>   void *malloc(unsigned n);   trả về con trỏ trỏ tới một v ùng nh ớ n byte mới đ ược cấp phát.,LTHDT_PhamVanAt.pdf - Sentence 2057
2058,3.,LTHDT_PhamVanAt.pdf - Sentence 2058
2059,"Hàm   void getimage(int x1,int y1,int x2,int y2,void *bitmap);   sẽ chép các điểm ảnh của h ình ch ữ nhật (x1,y1,x2,y2) v à các thông tin v ề bề rộng, cao của h ình ch ữ  nhật vào vùng nh ớ do bitmap trỏ tới.",LTHDT_PhamVanAt.pdf - Sentence 2059
2060,V ùng nh ớ và biến bitmap cho bởi h àm malloc.,LTHDT_PhamVanAt.pdf - Sentence 2060
2061,Đ ộ lớn của  vùng nh ớ được xác định bằng h àm imagesize.,LTHDT_PhamVanAt.pdf - Sentence 2061
2062,4.,LTHDT_PhamVanAt.pdf - Sentence 2062
2063,"Hàm   void putimage(int x,int y,void *bitmap,int copymode);   dùng đ ể sao ảnh l ưu trong vùng nh ớ bitmap ra m àn hình t ại vị trí ( x,y).",LTHDT_PhamVanAt.pdf - Sentence 2063
2064,"Tham s ố copymode xác định  kiểu sao chép ảnh, nó có thể nhận các giá trị sau:   COPY_PUT = 0  Sao chép nguyên xi.",LTHDT_PhamVanAt.pdf - Sentence 2064
2065,XOR_PUT = 1  Các đi ểm ảnh trong bitmap kết hợp với các    điểm ảnh tr ên màn hình b ằng phép XOR   OR_PUT = 2  Các đi ểm ảnh trong bitmap kết hợp với các    điểm ảnh tr ên màn hình b ằng phép OR   AND_PUT = 3  Các đi ểm ảnh trong bitmap kết hợp với các    điểm ảnh tr ên màn hình b ằng phép AND   NOT_PUT = 4  ảnh xuất hiện tr ên màn hình theo d ạng đảo    ngược (phép NOT) với ảnh trong bitmap.,LTHDT_PhamVanAt.pdf - Sentence 2065
2066,"Nhận xét:  Nếu dùng mode  XOR_PUT đ ể chép h ình, r ồi lặp lại đúng câu lệnh đó th ì hình s ẽ bị  xoá và màn hình tr ở lại nh ư cũ.",LTHDT_PhamVanAt.pdf - Sentence 2066
2067,Kỹ thuật n ày dùng đ ể tạo l ên các hình ảnh chuyển động.,LTHDT_PhamVanAt.pdf - Sentence 2067
2068,"Ví dụ 1: Chương tr ình d ưới đây minh hoạ cách d ùng imagesize, malloc, getimage và putimage.",LTHDT_PhamVanAt.pdf - Sentence 2068
2069,"Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          325                                         tenshi3003@gmail.com  #include <a lloc.h>   #include <graphics.h>   main()   {  int mh=0,mode=0;   char *p;   unsigend size;   initgraph (&mh,&mode,"""");   bar(0,0,getmaxx(),getmaxy());   size = imagesize(10,20,30,40);   p=(char*)malloc(size); // p tr ỏ tới v ùng nh ớ size byte   // mới được cấp phát   getimage (10 ,20,30,40,p);   getch();   cleardevice();   putimage (100,100,p,COPY_PUT);   getch();   closegraph();   }  5.",LTHDT_PhamVanAt.pdf - Sentence 2069
2070,Tảo ảnh di động   Nguyên t ắc tạo ảnh di động giống nh ư phim ho ạt hình:  - Vẽ một h ình (trong chu ỗi hình mô t ả chuyển động)   - Delay   - Xoá hình đó  - Vẽ hình k ế the o  - Delay    .,LTHDT_PhamVanAt.pdf - Sentence 2070
2071,.,LTHDT_PhamVanAt.pdf - Sentence 2071
2072,.,LTHDT_PhamVanAt.pdf - Sentence 2072
2073,A) V ẽ hình  Cách 1:  Vẽ lại một ảnh nh ưng t ại các vị trí khác nhau.,LTHDT_PhamVanAt.pdf - Sentence 2073
2074,Cách 2:  Lưu ảnh v ào m ột vùng nh ớ rối đ ưa ảnh ra m àn hình t ại các vị trí khác nhau.,LTHDT_PhamVanAt.pdf - Sentence 2074
2075,B) Xóa ảnh  Cách 1:  Dùng hàm cleardevice   Cách 2:  Dùng hàm putimage (mode XOR_PUT) đ ể xếp ch ồng l ên ảnh cần xoá.,LTHDT_PhamVanAt.pdf - Sentence 2075
2076,Cách 3:  Lưu tr ạng thái m àn hình vào m ột chỗ n ào đó.,LTHDT_PhamVanAt.pdf - Sentence 2076
2077,V ẽ một h ình ảnh.,LTHDT_PhamVanAt.pdf - Sentence 2077
2078,Đ ưa tr ạng thái cũ m àn  hình ra x ếp đè lên ảnh vừa vẽ.,LTHDT_PhamVanAt.pdf - Sentence 2078
2079,Kỹ thuật tạo ảnh di động đ ược minh hoạ trong các ch ương tr ình c ủa §11.,LTHDT_PhamVanAt.pdf - Sentence 2079
2080,Bài 11.,LTHDT_PhamVanAt.pdf - Sentence 2080
2081,M ột số ch ương tr ình đồ hoạ   Chương trình 1:  Đầu tiên vẽ bầu trời đầu sao.,LTHDT_PhamVanAt.pdf - Sentence 2081
2082,Sau đó từng ch ùm pháo hoa đư ợc bắn l ên bầu  trời.,LTHDT_PhamVanAt.pdf - Sentence 2082
2083,"Khi bấm phím Enter th ì việc bắn pháo hoa kết thúc, ta nhận lại bầu trời đầy sao.",LTHDT_PhamVanAt.pdf - Sentence 2083
2084,Bấm tiếp  Enter thì k ết thúc ch ương tr ình.,LTHDT_PhamVanAt.pdf - Sentence 2084
2085,"// Bắn pháo hoa tr ên bầu trời đầy sao  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          326                                         tenshi3003@gmail.com  #includ e <graphics.h>   #include <conio.h>   #include <stdlib.h>   #include <alloc.h>   main()   {  int x[101],y[101];   int mh=0,mode=0,i,n;   char *p[101];   initgraph(&mh,&mode,"""");   if (graphresult()!=0) exit(1);   setcolor(RED);   // Vẽ bầu trời đầy sao   for (i=1;i<=1000;++i)   {  putpixel(random(getmaxx()),   random(getmaxy()),random(getmaxcolor()));   }  // Lưu hi ện trạng 100 h ình ch ữ nhật tr ên màn hình để khôi phục   for (i=1;i<=100;++i)   {  x[i]=random(getmaxx()) -10;   y[i]=random(getmaxy()) -10;  if (x[i]<0) x[i]=0;   if (y[i]<0) y[i]=0;   n=imagesize(x[i],y[i],x[i]+10,y[i]+10);   p[i]=(char*)malloc(n);   getimage(x[i],y[i],x[i]+10,y[i]+10,p[i]);   }  // Chu trình b ắn pháo hoa   do   {  // Đưa 100 qu ả pháo l ên màn hình t ại các vị trí quy định   for (i=1;i<=100;++i)   {  setfillstyle(SOLID_FILL,i%15+1);   piesl ice(x[i]+5,y[i]+5,0,360,5);   }  delay(500);   //Xoá chùm pháo hoa v ừa bắn bằng cách khôi phục m àn hình  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          327                                         tenshi3003@gmail.com  for (i=100;i>=1; --i)  putimage(x[i],y[i],p[i],COPY_PUT);   delay(500);   } while(!kbhit());   getch();   getch();   closegraph();   }  Chương tr ình 2:  Vẽ đồng hồ có 3 kim  giờ, phút v à giây.",LTHDT_PhamVanAt.pdf - Sentence 2085
2086,Đ ồng hồ chạy đúng theo giờ hệ thống.,LTHDT_PhamVanAt.pdf - Sentence 2086
2087,Muốn kết thúc ch ương tr ình b ấm Enter.,LTHDT_PhamVanAt.pdf - Sentence 2087
2088,"// Đồng hồ   #include <graphics.h>   #include <conio.h>   #include <math.h>   #include <dos.h>   // Hàm k ẻ đoạn thẳng từ tâm đồng hồ theo độ, chiều d ài,  // độ dầy v à mầu  void ke(int ddo, unsigned dai, unsigned day,unsigned mau);   // Kẻ kim giây khi biết số giây   void ke_giay(unsigned giay);   // Kẻ kim phút khi biết số phút   void ke_phut(unsigned phut);   // Kẻ kim giờ khi biết số giờ   void ke_gio(unsigned gio, unsigned phut);   void chay_kim_giay(void); void chay_kim_phut(void);   void chay_kim_gio(void);   int x0,y0,rgio,rphut,rgiay,mgio,mphut,mgiay;   unsigned phutgioht,gioht,phutht,giayht;   void ke(int ddo, unsigned dai, unsigned day,unsigned mau)   {  unsigned x,y; float goc;   while (dd o>=360) ddo=ddo -360;  goc=(M_PI/180)*ddo;   x=x0+ (int)(dai*cos(goc)+0.5);   y=y0 - (int)(dai*sin(goc)+0.5);   setcolor(mau); setlinestyle(0,0,day);   line(x0,y0,x,y);   }  // Hàm ke kim giay   void ke_giay(unsigned giay)   { Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          328                                         tenshi3003@gmail.com  int ddo;   ddo = (90 - 6*giay);   ke(ddo,rgiay,1,m giay);   }  // Hàm ke kim phut   void ke_phut(unsigned phut)   {  int ddo;   ddo= (90 -6*phut);   ke(ddo,rphut,3,mphut);   }  // Hàm ke kim gio   void ke_gio(unsigned gio, unsigned phut)   {  int ddo;   ddo = 360 + 90 - 30*(gio%12) - (phut+1)/2;   ke(ddo,rgio,3,mgio);   }  // Hàm ch ỉnh giây hiện tại v à làm chuy ển động kim giây   void chay_kim_giay(void)   {  unsigned giay; struct time t;   gettime(&t);   giay=t.ti_sec;   if (giay!=giayht)   {  ke_giay(giayht);   giayht=giay;   ke_giay(giayht);   }  }  // Hàm ch ỉnh phút hiện tại v à làm chuy ển động kim phú t   void chay_kim_phut(void)   {  unsigned phut;   struct time t;   gettime(&t);   phut=t.ti_min;   if (phut!=phutht)   { Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          329                                         tenshi3003@gmail.com  ke_phut(phutht);   phutht=phut;   ke_phut(phutht);   }  }  // Hàm ch ỉnh giờ phút hiện tại v à làm chuy ển động kim giờ   void chay_kim_gio(void)   {  unsigned h,g io,phut,sophut,sophutht;   struct time t;   gettime(&t);   gio=t.ti_hour; phut=t.ti_min;   sophut = gio*60+phut;   sophutht = gioht*60+phutgioht;   if ( sophut<sophutht) sophut=sophut+ 12*60;   h=sophut -sophutht;   if (h>=12)   {  ke_gio(gioht,phutgioht);   phutgioht=phut;   gioht=gio;   ke_gio(gioht,phutgioht);   }  }  main()   {  struct time t;   char *dso[]={"""", ""12"", ""1"", ""2"", ""3"", ""4"", ""5"", ""6"", ""7"", ""8"", ""9"", ""10"", ""11""};   int i,mh=0,mode=0,r,x,y;   float goc;   initgraph(&mh,&mode,"""");   x0=(getmaxx()/2) -1; y0=(getmaxy()/2) -1;  r=y0 -2;  rgiay = r -10; rphut=r -50; rgio=r -90;  mgiay= BROWN; mphut=RED; // mgio:=magenta;   mgio=YELLOW;   // Vẽ chu vi đồng hồ   setcolor(BLUE); setlinestyle(0,0,3); circle(x0,y0,r);   setfillstyle(1,YELLOW);   floodfill(0,0,BLUE);  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          330                                         tenshi3003@gmail.com  setfillstyle(1,WHITE); floodfill(x0,y0,BLUE);   setlinestyle(0,0,1);   circle(x0,y0,10);   setfillstyle(1,GREEN); floodfill(x0,y0,BLUE);   settextjustify(1,1); setcolor(MAGENTA);   outtextxy(x0,y0+120,""IBM -JIMIKO"");   // Ghi ch ữ số   settextstyle(3,0,3); settextjustify(1,1); setcolor(BLUE);   for (i=1;i<=12;++i)   {  goc=(2*M_PI+M_PI/2) - (i-1)*(M_PI/6);   x = x0+ (int)(rphut*cos(goc)+0.5);   y = y0 - (int)(rphut*sin(goc)+0.5);   outtextxy(x,y,dso[i]);   }  // Xác đ ịnh thời điểm đầu   gettime(&t);   gioht=t.ti_hour; phutht=t.ti_min; giayht=t.ti_sec;   phutgioht=phutht;   setwritemode(X OR_PUT);   // Ve kim gio,phut,giay   ke_gio(gioht,phutgioht);   ke_phut(phutht);   ke_giay(giayht);   // Làm chuy ển động các kim   do   {  chay_kim_giay(); chay_kim_phut();   chay_kim_gio();   }  while(!kbhit());   closegraph();   }  Chương tr ình 3:  Vẽ một con tầu vũ trụ bay t rên b ầu trời đầy sao theo quỹ đạo ellipse.",LTHDT_PhamVanAt.pdf - Sentence 2088
2089,"Trong khi  tầu chuyển động th ì các ngôi sao thay nhau nh ấp nháy   // Tầu vũ trụ chuyển động tr ên bầu trời đầy sao nhấp nháy   #include <graphics.h>   #include <stdio.h>   #include <conio.h>   #include <alloc.h>  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          331                                         tenshi3003@gmail.com  #include <st dlib.h>   #include <math.h>   // Khai báo các hàm trong chương tr ình   void tau_cd(void); // t ầu chuyển động   void nhap_nhay_bt(void); // nh ấp nháy bầu trời   void main(void); // hàm main   // Khai báo các bi ến mảng ngo ài   int a,b,x,y,x0,y0,mh=0,mode=0,n,i;   float goc,xt,yt;   char *p;   int xx[1001],yy[1001];   // Hàm main   void main(void)   {  initgraph(&mh,&mode,"""");   if (graphresult()!=0) exit(1);   // Vẽ tầu vũ trụ   setcolor(RED);   ellipse(100,50,0,360,20,8);   ellipse (100,46,190,357,20,6);   line(107,44,110,38);   circle(110,3 8,2);   line(93,44,90,38);   circle(90,38,2);   setfillstyle(SOLID_FILL,BLUE);   floodfill(101,54,RED);   setfillstyle(SOLID_FILL,MAGENTA);   floodfill(94,45,RED);   // Lưu ảnh của tầu vũ trụ v ào bộ nhớ   n=imagesize(79,36,121,59);   p=(char*)malloc(n);   getimage(79,36,121 ,59,p);   // Vẽ bầu trời đầy sao v à lưu v ị trí của chúng   // vào các m ảng xx, yy để phục vụ h àm nhap_nhay_bt   cleardevice();   for (i=1;i<=1000;++i)   {  xx[i]=random(getmaxx()); yy[i]=random(getmaxy());   putpixel(xx[i],yy[i],random(getmaxcolor()));   }  // Xác đ ịnh gi á trị ban đầu cho các biến  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          332                                         tenshi3003@gmail.com  // dùng đ ể điều khiển chuyển động tầu   goc= 2*M_PI + M_PI/2;   x0= (getmaxx() - 42)/2;   y0= (getmaxy() - 25)/2;   a=x0; b=y0;   // chu trình t ầu vũ trụ chuyển động v à các ngôi sao nh ấp nháy   do  {  tau_cd();   nhap_nhay_bt();   } while(!kbhit ());  getch();   closegraph();   }  void tau_cd(void)   {  xt=a*cos(goc)+x0;   yt=-b*sin(goc)+y0;   x=(int)(xt+0.5); y=(int)(yt+0.5);   // Đặt tầu vũ trụ l ên màn hình   putimage(x,y,p,XOR_PUT);   delay(500);   // Xóa   putimage(x,y,p,XOR_PUT);   // Thay đ ổi góc để l àm cho t ầu ch uyển động   goc -= M_PI/30;   if (goc<M_PI/2) goc=2*M_PI+M_PI/2;   }  void nhap_nhay_bt(void)   {  static i=1; // L ệnh n ày th ực hiện một lần khi dịch   int j;   // Cho nh ấp nháy bằng cách đổi mầu 50 ngôi sao   for (j=1;j<=50;++j)   {  putpixel(xx[i],yy[i],random(getmaxcolo r()));   ++i;   if (i>1000) i=1;   }  } Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          333                                         tenshi3003@gmail.com  Bài 12.",LTHDT_PhamVanAt.pdf - Sentence 2089
2090,"In ảnh từ m àn hình đồ hoạ   Hàm in_anh dư ới đây sẽ in ảnh trong miền chữ nhật (xt, yt, xd, yd) của m àn hình đồ hoạ ra giấy  trên các máy in LQ1070, LQ1170 và FX1050.",LTHDT_PhamVanAt.pdf - Sentence 2090
2091,"void in_anh(int dd,int xt,int yt,int xd,int yd);   Tham số dd l à độ đậm của nét in.",LTHDT_PhamVanAt.pdf - Sentence 2091
2092,Thực chất dd l à số lần in lại.,LTHDT_PhamVanAt.pdf - Sentence 2092
2093,B ình th ường chon dd=1.,LTHDT_PhamVanAt.pdf - Sentence 2093
2094,Nếu  muốn in r õ hơn ta ch ọn dd bằng 2     hay 3.,LTHDT_PhamVanAt.pdf - Sentence 2094
2095,"Trong hàm in_anh có dùng hàm tao_mau, nó đư ợc mô tả nh ư sau:   int tao_mau(int k,int x,int y);   Hàm này s ẽ dò trên k ch ấm điểm theo chi ều dọc bắt đầu từ toạ độ (x,y) tr ên màn hình để biết  xem ch ấm điểm n ào đã tô m ầu.",LTHDT_PhamVanAt.pdf - Sentence 2095
2096,H àm s ẽ trả về một giá trị nguy ên tạo bởi các bit 1 (ứng với điểm đ ã  tô mầu) v à 0 (ứng với điểm ch ưa tô m ầu).,LTHDT_PhamVanAt.pdf - Sentence 2096
2097,"Hàm in_anh s ẽ dùng hàm tao_mau đ ể duyệt tr ên mi ền chữ nhậ t (xt,yt,xd,yd).",LTHDT_PhamVanAt.pdf - Sentence 2097
2098,M ỗi lần duyệt sẽ  nhận được một mẫu các chấm điểm (giá trị nguy ên) và m ẫu này đư ợc in ra giấy.,LTHDT_PhamVanAt.pdf - Sentence 2098
2099,Dưới đây l à nội dung của 2 h àm nói trên.,LTHDT_PhamVanAt.pdf - Sentence 2099
2100,"// in ảnh   #include ""stdio.h""   #include ""graphics.h""   int tao_mau(int k,int x,int y);   void in_anh(int dd,i nt xt,int yt,int xd,int yd);   int tao_mau(int k,int x,int y)   {  int c=0,i;   for (i=0;i<k;++i)   if (getpixel(x,y+i)) c =c|(128>>i);   return c;   }  void in_anh(int dd,int xt,int yt,int xd,int yd)   {  //dd - so lan in lai mot dong   char c,ch1;   int scot,m,mm,k,dong,cot ,i,j,n1,n2;   dong=(yd -yt+1)/6; mm=(yd -yt+1) % 6;   cot=xd -xt+1;   for (i=0;i<=dong;++i)   {  if (i<dong) m=6; else m=mm;   if (m>0)   {  scot=0;   for (j=0;j < cot;++j)  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          334                                         tenshi3003@gmail.com  if (tao_mau(m,xt+j,yt+i*6)) scot=j+1;   if (scot)   {  n1=scot % 256; n2= scot/256;   for (k=0;k<dd;++k)   {  fprintf(stdprn,""%c%c%c%c%c%c"",13,27,'*',   0,n1,n2); //LQ   for (j=0;j < scot;++j)   {  if (kbhit())//bat phim   {  if ((ch1=getch())==0) getch();   if (ch1==27) goto ket;   }  c=tao_mau(m,xt+j,yt+i*6);   fprintf(stdprn,""%c"",c);   }  }  }  fprintf(stdprn,""%c%c%c"",27,'A',m);   fprin tf(stdprn,"" \n"");  }  }  ket: fprintf(stdprn,""%c%c"",27,'@');   }     Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          335                                         tenshi3003@gmail.com  Chương 9   Truy nh ập trực tiếp v ào bộ nhớ   Trong chương này trình  bầy các vấn đề:   + Hai ki ểu địa chỉ: Địa chỉ phân  đoạn và địa chỉ thực   + Truy nh ập tới địa chỉ phân  đoạn  + Đổi từ địa chỉ phân  đoạn sang địa chỉ thực   + Bộ nhớ m àn hình, truy nh ập trực tiếp v ào bộ nhớ m àn hình  + Dựng con trỏ để lấy dữ liệu từ bộ nhớ phân  đoạn  + Dựng con trỏ h àm đ ể thực hiện các thủ tục của DOS   Bài 1.",LTHDT_PhamVanAt.pdf - Sentence 2100
2101,Các hàm truy nh ập theo địa chỉ phân  đoạn  1.,LTHDT_PhamVanAt.pdf - Sentence 2101
2102,Hàm pokeb : Gửi một ký tự v ào bộ nhớ.,LTHDT_PhamVanAt.pdf - Sentence 2102
2103,"+ Nguyên  mẫu trong dos.h nh ư sau:   void pokeb(unsign ed seg, unsigned off, char value);   + Cụng dụng: Gửi giá trị ký tự value v ào bộ nhớ tại địa chỉ phân  đoạn  seg:off   2.",LTHDT_PhamVanAt.pdf - Sentence 2103
2104,Hàm peekb:  Nhận một ký tự từ bộ nhớ.,LTHDT_PhamVanAt.pdf - Sentence 2104
2105,"+ Nguyên  mẫu trong dos.h nh ư sau:   char peekb(unsigned seg, unsigned off);   + Cụng dụng: Nhận một byte t ại địa chỉ phân  đoạn seg:off   3.",LTHDT_PhamVanAt.pdf - Sentence 2105
2106,Hàm poke:  Gửi một số nguyên  vào b ộ nhớ.,LTHDT_PhamVanAt.pdf - Sentence 2106
2107,"+ Nguyên  mẫu trong dos.h nh ư sau:   void poke(unsigned seg, unsigned off, int value);   + Cụng dụng: Gửi giá trị nguyên  value vào b ộ nhớ tại địa chỉ phân  đoạn seg:off   4.",LTHDT_PhamVanAt.pdf - Sentence 2107
2108,Hàm peek:  Nhận một  số nguyên  từ bộ nhớ.,LTHDT_PhamVanAt.pdf - Sentence 2108
2109,"+ Nguyên  mẫu trong dos.h nh ư sau:   int peek(unsigned seg, unsigned off);   + Cụng dụng: Nhận một word tại địa chỉ phân  đoạn seg:off   5.",LTHDT_PhamVanAt.pdf - Sentence 2109
2110,Hàm movedata:  Sao các byte.,LTHDT_PhamVanAt.pdf - Sentence 2110
2111,"+ Nguyên  mẫu trong mem.h nh ư sau:   void movedata(unsigned seg_gui, unsigned  off_gui,   unsigned seg_nhan, unsigned off_nhan, int n);   + Cụng dụng: Sao n byte từ seg_gui:off_gui đến   seg_nhan:off_nhan   Bài 2.",LTHDT_PhamVanAt.pdf - Sentence 2111
2112,Bộ nhớ m àn hình  văn b ản  2.1.,LTHDT_PhamVanAt.pdf - Sentence 2112
2113,"Cách biểu diễn ký tự trong bộ nhớ m àn hình   Bộ nhớ m àn hình văn b ản bắt đầu từ địa chỉ :   (0xb800:0x 0000)  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          336                                         tenshi3003@gmail.com  Khi đưa m ột ký tự v ào vựng nhớ m àn hình, thì nú sẽ hiện lờn m àn hình.",LTHDT_PhamVanAt.pdf - Sentence 2113
2114,"Mỗi ký tự trên màn hình  chiếm 2 byte trong bộ nhớ m àn hình: byte đ ầu chứa mó ASCII, byte thứ hai biểu diễn mầu hiển thị  gọi là byte thu ộc tính.",LTHDT_PhamVanAt.pdf - Sentence 2114
2115,Các bit của byte thuộc tính:  B7B6B5B 4B3B2B1B0   được chia l àm 3 nhóm :  + Nhóm  1 gồm bit B7 biểu thị sự nhấp nháy .,LTHDT_PhamVanAt.pdf - Sentence 2115
2116,"Nếu B7=0 thì ký tự khụng nhấp nháy , nếu B7=1 thì  ký tự sẽ nhấp nháy .",LTHDT_PhamVanAt.pdf - Sentence 2116
2117,"+ Nhóm  2 gồm các bit B6, B5 và B4.",LTHDT_PhamVanAt.pdf - Sentence 2117
2118,Các bit này ch ứa được một số nguyên  từ 0 đến 7 v à biểu  thị 8 mầu nền của ký t ự.,LTHDT_PhamVanAt.pdf - Sentence 2118
2119,"+ Nhóm  3 gồm các bit B3, B2, B1 và B0.",LTHDT_PhamVanAt.pdf - Sentence 2119
2120,Các bit này ch ứa được một số nguyên  từ 0 đến 15 v à  biểu thị 16 mầu của ký tự.,LTHDT_PhamVanAt.pdf - Sentence 2120
2121,2.2.,LTHDT_PhamVanAt.pdf - Sentence 2121
2122,"Trang màn hình     Mỗi trang m àn hình gồm 80x25 ký tự, do đó cần 80x25x2=4000 byte bộ nhớ.",LTHDT_PhamVanAt.pdf - Sentence 2122
2123,Thực tế mỗi trang  màn hình được phân  bố 4096 = 0x1000 byte.,LTHDT_PhamVanAt.pdf - Sentence 2123
2124,Như v ậy 4 trang m àn hình được phân  bố như sau:   + Trang màn hình thứ 0 bắt đầu từ địa chỉ 0xB800:0x0000   + Trang màn hình thứ 1 bắt đầu từ địa chỉ 0xB800:0x1000   + Trang màn hình thứ 2 bắt đầu từ địa chỉ 0xB800:0x2000   + Trang màn hình thứ 3 bắt đầu từ địa chỉ 0xB800:0x3000   2.3.,LTHDT_PhamVanAt.pdf - Sentence 2124
2125,Ch ọn trang hiển thị   Tại mỗi thời điểm chỉ có thể hiển thị đ ược một trong 4 trang m àn hình.,LTHDT_PhamVanAt.pdf - Sentence 2125
2126,"Để hiển thị trang m àn  hình thứ t (t=0,1,2,3) chúng  ta sử dụng chức năng 5 của ngắt 0x10 theo mẫu sau:   union REGS v,r;   v.h.ah = 5 ; // Ch ức năng 5   v.h.al = t  ;  // S ố hiệu trang m àn hình cần hiển thị   int86(0x10, &v, &r); // Th ực hiện ngắt 0x10   2.4.",LTHDT_PhamVanAt.pdf - Sentence 2126
2127,"Ví dụ minh hoạ   Ví dụ sau dựng h àm pokeb đ ể đưa các ký tự vào các trang c ủa bộ nhớ m àn hình, sau đó dựng  chức năng 5 của ngắt 0x10 để c họn trang hiển thị.",LTHDT_PhamVanAt.pdf - Sentence 2127
2128,"//CT9_03.CPP   #include <dos.h>   #include <conio.h>   char d1[]={'C',1*16+14,'H',1*16+14,'U',1*16+14,'C',1*16+14};   char d2[]={'M',2*16+15,'U',2*16+15,'N',2*16+15,'G',2*16+15};   void main()   {  union REGS v,r;   clrscr();   //Mặc định hiển thị trang  0  for (int i=0;i<8;++i)   pokeb(0xb800,i,d1[i]);   getch();  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          337                                         tenshi3003@gmail.com  //Hien thi trang 1   v.h.ah = 5 ; v.h.al = 1 ;   int86(0x10,&v,&r);   for (i=0;i<8;++i)   pokeb(0xb800,0x1000+i,d2[i]);   getch();   //Hien thi trang 0   v.h.ah = 5 ; v.h.al = 0 ;   int86(0x10,&v,&r);   getch();   //Hie n thi trang 1   v.h.ah = 5 ; v.h.al = 1 ;   int86(0x10,&v,&r);   getch();   }  Bài 3.",LTHDT_PhamVanAt.pdf - Sentence 2128
2129,Chuyển  đ ổi  địa chỉ   3.1.,LTHDT_PhamVanAt.pdf - Sentence 2129
2130,Đ ể chuyển từ địa chỉ thực sang địa chỉ phân  đoạn ta dựng các macro:   unsigned FP_SEG(đ ịa_chỉ_thực)   unsigned FP_OFF(đ ịa_chỉ_thực)   3.2.,LTHDT_PhamVanAt.pdf - Sentence 2130
2131,"Đ ể chuyển từ địa chỉ phân  đoạn sang địa chỉ thực ta dựng macro:   void far *MK_FP(seg,off)   Ví dụ 1.",LTHDT_PhamVanAt.pdf - Sentence 2131
2132,"Sau khi th ực hiện các cõu l ệnh:  char buf[100];   unsigned ds,dx;   ds = FP_SEG(buf); dx = FP_OFF(buf);   thì ds:dx ch ứa địa chỉ của mảng buf.",LTHDT_PhamVanAt.pdf - Sentence 2132
2133,Ví dụ 2.,LTHDT_PhamVanAt.pdf - Sentence 2133
2134,Sau khi th ực hiện các cõu l ệnh:  char  far *pchar;   pchar = (char far*)MK_FP(0xb800:0);   thì pchar tr ỏ tới địa chỉ đầu của bộ nhớ m àn hình.,LTHDT_PhamVanAt.pdf - Sentence 2134
2135,Khi đó ta có thể sử dụng các lệnh gán để truy  nhập trực tiếp tới bộ nhớ m àn hình.,LTHDT_PhamVanAt.pdf - Sentence 2135
2136,Bài 4.,LTHDT_PhamVanAt.pdf - Sentence 2136
2137,các ví dụ minh hoạ   Chương trình  1.,LTHDT_PhamVanAt.pdf - Sentence 2137
2138,Chương trình  minh ho ạ cách truy nh ập trực tiếp v ào bộ nhớ m àn hình có địa  chỉ đầu l à 0xB800:0.,LTHDT_PhamVanAt.pdf - Sentence 2138
2139,Chương trình  gồm h àm main() và hai hàm sau:   1.,LTHDT_PhamVanAt.pdf - Sentence 2139
2140,"Hàm cuaso   void cuaso(int dongt,int cott,int dongd,int cotd,int maucs);   thiết lập một cửa sổ mầu có toạ độ góc trên-trái là (dongt, cott) v à góc dưới-phải là (dongd,cotd).",LTHDT_PhamVanAt.pdf - Sentence 2140
2141,Mầu cho bởi tham số maucs.,LTHDT_PhamVanAt.pdf - Sentence 2141
2142,ở đây sử dụng h àm pokeb và đ ịa chỉ phân  đoạn.,LTHDT_PhamVanAt.pdf - Sentence 2142
2143,2.,LTHDT_PhamVanAt.pdf - Sentence 2143
2144,"Hàm duarmh  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          338                                         tenshi3003@gmail.com  void duarmh(char *day, int dong, int cotd, int cotc,int m_nen, int m_chu);   sẽ đưa ra màn hình một dẫy ký tự (chứa trong dãy) tại dòng  dong, từ cột cotd đến cotc.",LTHDT_PhamVanAt.pdf - Sentence 2144
2145,"Mầu nền cho  bởi m_nen, mầu chữ cho bởi m_chữ.",LTHDT_PhamVanAt.pdf - Sentence 2145
2146,ở đây sử dụng toán tử gán trên địa chỉ thực.,LTHDT_PhamVanAt.pdf - Sentence 2146
2147,Trong hàm main() s ẽ sử dụng các hàm cuaso và duarmh đ ể tạo hai cửa sổ v à viết hai dòng  chữ  trên trang màn hình thứ hai (từ dòng  26 đến dòng  50).,LTHDT_PhamVanAt.pdf - Sentence 2147
2148,"/*  chương trình  minh ho ạ cách truy nh ập trực tiếp v ào bộ  nhớ của m àn hình  */  #include ""dos.h""   #include ""conio.h""   void duarmh(char *day, int dong,I nt cotd, int cotc,I nt m_nen,  int m_chu);   void cuaso(int dongt,int cott,int dongd,int cotd,int maucs) ;  main()   {  cuaso(26,1,50,80,BLUE);   duarmh(""Chuc mung nam moi"", 28, 30, 50, MAGENTA, WHITE);   cuaso(30,20,46,60,RED);   duarmh(""Chuc mung nam moi"", 40, 30, 50, MAGENTA, YELLOW);   getch();   }  void cuaso(int dongt,int cott,int dongd,int cotd,int maucs)   /* Dung dia  phan doan */   {  int i, j, p, t, dt, dd, mau;   union REGS v, r;   /* Xac dinh thuoc tinh mau */   mau = (maucs << 4)+maucs;   /*  Xac dinh trang man hinh t   va cac chi so dong tren dt, dong duoi dd   trong trang t   */  t=(dongt -1)/25;   dt=(dongt -1)-t*25; dd=(dongd -1)-t*25;  /* Chon t la trang hien thi */   v.h.ah=5;v.h.al=t; int86(0x10,&v,&r);   /*  Dua cac khoang trong (ma 32) va thuoc tinh mau   vao cac vi tri thich hop cua bo nho man hinh   */ 495 496 Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          339                                         tenshi3003@gmail.com  for (i=dt;i<=dd;++i)   {  p=t*4096+i*160+(cott -1)*2;   for (j=0;j<=cotd -cott;++j)   {   pokeb( 0xb800,p+2*j,32);   pokeb(0xb800,p+2*j+1,mau);   }  }  }  void duarmh(char *day, int dong, int cotd, int cotc, int m_nen,   int m_chu)   /* Dung dia chi thuc */   {  int i,p,t,d,kt,mau;   char far  *buf;   union REGS v,r;   /* Lay dia chi thuc cua bo nho man hinh */   buf=(cha r far*)MK_FP(0xb800,0);   /* Xac dinh thuoc tinh mau */   mau = (m_nen << 4)+m_chu;   /*  Xac dinh trang man hinh t   va cac chi so dong d trong trang t   */  t=(dong -1)/25; d=dong -1-t*25;   /* Chon t la trang hien thi */   v.h.ah=5;v.h.al=t; int86(0x10,&v,&r);   p=t*4096+d *160+(cotd -1)*2;   /*  Dua cac ky tu va thuoc tinh mau   vao cac vi tri thich hop cua bo nho man hinh   */  for (i=0;i<=cotc -cotd;++i)   {  if ((kt=day[i])==0) break;   buf[p+2*i]=kt;   buf[p+2*i+1]=mau;   }  } Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          340                                         tenshi3003@gmail.com  Chương trình  2.",LTHDT_PhamVanAt.pdf - Sentence 2148
2149,Biết địa chỉ của các thủ tục xử lý ngắt đ ược lưu trữ trong bộ nhớ từ địa chỉ  0000:0000 đ ến 0000:0x0400.,LTHDT_PhamVanAt.pdf - Sentence 2149
2150,Ch ương trình  sẽ cho biết địa chỉ của thủ tục xử lý ngắt n ( giá trị n  nhập vào từ bàn phím ).,LTHDT_PhamVanAt.pdf - Sentence 2150
2151,"Số hiệu của ngắt đ ược tính từ 0, nh ưng n đư ợc đánh số từ 1.",LTHDT_PhamVanAt.pdf - Sentence 2151
2152,"/*  Xac dinh dia chi cac thu tuc ngat */   #inclu de ""dos.h""   #include ""conio.h"" #include ""stdio.h""   main()   {  unsigned char far *p; /*p se tro toi bang vecto ngat*/   int n; /* n - so hieu ngat, n=1,2,...",LTHDT_PhamVanAt.pdf - Sentence 2152
2153,"*/   int k; /* vi tri cua ngat n trong bang vecto ngat */   unsigned seg,off;   /* p tro toi bang vecto ngat * /  p=(unsigned char far*)MK_FP(0,0);   clrscr();   while(1)   {  printf("" \n So hieu ngat (Bam 0 - Ket thuc): "");   scanf(""%d"",&n); if(n==0) break;   k=(n -1)*4;   off=p[k]+256*p[k+1]; seg=p[k+2]+256*p[k+3];   printf("" \nDia chi %x:%x"",seg,off);   }  }  Chương trình  3.",LTHDT_PhamVanAt.pdf - Sentence 2153
2154,"Chương trình minh ho ạ cách dựng con trỏ h àm đ ể thực hiện thủ tục khởi động  lại máy của DOS, biết địa chỉ đầu của thủ tục n ày là 0xFFFF:0000 .",LTHDT_PhamVanAt.pdf - Sentence 2154
2155,Chương trình  yêu cầu nhập  mật khẩu.,LTHDT_PhamVanAt.pdf - Sentence 2155
2156,"Nếu chọn đỳng (bấm ABCD v à Enter) thì chương trình  tiếp tục l àm vi ệc, nếu v ào sai thì  sẽ khởi động lại máy.",LTHDT_PhamVanAt.pdf - Sentence 2156
2157,"#include <dos.h>   #include <conio.h>   #include <iostream.h>   #include <ctype.h>   typedef void far (*HAM)(void);   void khoi_dong_may(void)   {  HAM f;   f = (HAM)MK_FP(0xFFFF,0);   f();  }  char mat_khau[]= {'A','B','C','D'};  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          341                                         tenshi3003@gmail.com  int n = sizeof(mat_khau )/sizeof(char);   void main()   {  char  i, ch, sai_mat_khau;   clrscr();   i=0;  sai_mat_khau=0;   cout << "" \nMat khau: "";   while(1)   {  ch=getch();   if (ch==13) break;   cout << '*' ;   if (i<n)   {  if (toupper(ch)!=mat_khau[i])   sai_mat_khau=1;   }  else  sai_mat_khau=1;   ++i ;   }  if (sai_mat_khau)   {  cout << "" \nSai mat khau, Khoi dong lai may"";   getch();   khoi_dong_may();   }  else  {  cout << "" \nDung mat khau, tiep tuc chuong trinh"";   getch();   }  }  Chương trình  4.",LTHDT_PhamVanAt.pdf - Sentence 2157
2158,Chương trình  minh ho ạ cách dựng biến con trỏ  để lấy dữ liệu về thời gian hệ  thống chứa trong 4 byte bắt đầu từ địa chỉ 0:0x46C .,LTHDT_PhamVanAt.pdf - Sentence 2158
2159,Ch ương trình  cũng minh hoạ cách truy nh ập  trực tiếp bộ nhớ m àn hình văn b ản (địa chỉ đầu l à 0xB800:0) và cách bắt phím  tổng quát.,LTHDT_PhamVanAt.pdf - Sentence 2159
2160,Chương  trình  sẽ in ra m àn hình các chữ cái một cách ngẫu nhiên .,LTHDT_PhamVanAt.pdf - Sentence 2160
2161,Khi b ấm phím F1 chương trình  tạm dừng  để thông  báo thời gian.,LTHDT_PhamVanAt.pdf - Sentence 2161
2162,Để kết thúc chương trình  bấm phím  ESC.,LTHDT_PhamVanAt.pdf - Sentence 2162
2163,"#include <dos.h>  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          342                                         tenshi3003@gmail.com  #include <conio.h>   #include <stdlib.h>   #define VT 132  // vi tri thong bao   //Dia chi vung nho man hinh   char far *p_mh = (char far*)MK_FP(0xB800,0) ;  //Dia chi 4 byte chua thoi gian   unsigned long far *t_time=(unsigned long far*)MK_FP(0,0x46C);   char buf_time[]={'T',47,'I',47,'M',47,'E',47,':', 47, 32, 47, 32, 47,   32, 47, 32, 47, 32, 47, 32, 47, 32, 47, 32, 47, 32, 47};   char buf_luu[28];   void thong_bao _thoi_gian()   {  //Luu trang thai man hinh   for (int i=0; i<28; ++i)   buf_luu[i]=p_mh[i];   // Xac dinh gio, phut, giay   int gio =  (int)(*t_time/65543) ;   unsigned long  du =   *t_time%65543 ;   int phut = (int)(du/1092);   du = du%1092;   int giay = (int)(du/18);   //Doi ra ky tu dua vao mang buf_time   buf_time[12]=gio/10 + 48;   buf_time[14]=gio%10 + 48;   buf_time[18]=phut/10 + 48;   buf_time[20]=phut%10 + 48;   buf_time[24]=giay/10 + 48;   buf_time[26]=giay%10 + 48;   //Dua thong bao goi ra man hinh   for (i=0; i<28; ++i)   p_mh[i] = buf_time[i];   getch();   //Khoi phuc man hinh   for (i=0; i<28; ++i)   p_mh[i] = buf_luu[i];   }  void main()   {  int ch1, ch2;   clrscr();  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          343                                         tenshi3003@gmail.com  while(1)   {  if (kbhit())   {  ch1=getch();   if (ch1==0) ch2=getch();   if (ch1==27) //ESC   break;   if (ch1==0 && ch2==59) // Bam F1   thong_b ao_thoi_gian();   }  //In cac chu cai mot cach ngau nhien   gotoxy(random(80)+1,random(25)+1);   putch(random(26)+65);   delay(400);   }  }           Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          344                                         tenshi3003@gmail.com  Chương 10   Một số ch ương tr ình h ướng đối t ượng tr ên C++   Chương này tr ình b ầy th êm m ột số ch ương tr ình h ướng đối t ượng tr ên C++.",LTHDT_PhamVanAt.pdf - Sentence 2163
2164,"Đây là các chương  trình t ương đ ối phức tạp, hữu ích v à sử dụng các công cụ mạnh của C++ nh ư: Cách truy nh ập trực  tiếp bộ nhớ m àn hình, k ỹ thuật đồ hoạ, con trỏ void, tính kế thừa, lớp c ơ sở trừu t ượng, t ương ứng  bội, ph ương th ức ảo.",LTHDT_PhamVanAt.pdf - Sentence 2164
2165,Bài 1.,LTHDT_PhamVanAt.pdf - Sentence 2165
2166,"Lớp cửa sổ   Chương tr ình g ồm lớp cua_so v à lớp stack   + Lớp cửa sổ   Thuộc tính gồm:   char *noidung;  // Tr ỏ đến v ùng nh ớ chứa nội dung   // soạn thảo  trên c ửa sổ   int cao,rong  ;   // Chi ều cao v à chi ều rộng cửa sổ   int mau;     // mau = 16*mau_nen + mau_chu   int ra_mh; // Cho bi ết cửa sổ đ ã được đưa ra màn h ình ch ưa?",LTHDT_PhamVanAt.pdf - Sentence 2166
2167,"int posx,posy; // V ị trí tr ên trái c ủa cửa sổ tr ên màn hình   word *pluu;  // Tr ỏ đến v ùng nhớ chứa nội dung                               // phần m àn hình b ị cửa sổ đ è lên   Phương th ức gồm:   cua_so();   cua_so(int c,int r,byte mau_nen, byte mau_chu);   int push(int x,int y); // Đưa c ửa sổ ra m àn hình t ại (x,y)   // cho phép so ạn thảo tr ên cửa sổ   // Bấm F6 chuy ển sang cửa sổ khác   // Bấm ESC kết thúc   void pop();  // Tháo g ỡ  cửa sổ v à khôi ph ục m àn hình   int get_ra_mh();   + Lớp stack (d ùng đ ể quản lý một dẫy cửa sổ)   Thuộc tính gồm:   int max;  //S ố cửa sổ cực đại có thể quản lý   int num;  //S ố cửa sổ hiện có tr ong stack   cua_so **pcs; //Con tr ỏ trỏ đến v ùng nh ớ chứa   //địa chỉ của các đối t ượng cua_so   Phương th ức gồm:   stack();   stack(int max_cs);   int accept(cua_so *cs,int x,int y); //Đưa m ột cửa sổ   //vào stack, nó s ẽ hiện l ên màn hình   void del(); // Lo ại cửa sổ kh ỏi stack, nó sẽ bị xoá  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          345                                         tenshi3003@gmail.com  // khỏi màn hình   Nội dung ch ương tr ình:  + Đầu tiên hi ện cửa sổ thứ nhất nền GREEN chữa WHITE.",LTHDT_PhamVanAt.pdf - Sentence 2167
2168,Có thể soạn thảo tr ên đó.,LTHDT_PhamVanAt.pdf - Sentence 2168
2169,"+ Nếu bấm ESC kết thúc ch ương tr ình, n ếu bấm F6 th ì hiện th êm c ửa sổ thứ hai nền CYAN chữ  MAGENTA.",LTHDT_PhamVanAt.pdf - Sentence 2169
2170,Có th ể soạn thảo tr ên đó.,LTHDT_PhamVanAt.pdf - Sentence 2170
2171,"+ Nếu bấm ESC kết thúc ch ương tr ình, n ếu bấm F6 th ì hiện th êm c ửa sổ thứ ba nền RED chữ  YELLOW.",LTHDT_PhamVanAt.pdf - Sentence 2171
2172,Có th ể soạn thảo tr ên đó.,LTHDT_PhamVanAt.pdf - Sentence 2172
2173,"+ Đang ở một cửa sổ, nếu bấm ESC th ì kết thúc ch ương tr ình, n ếu bấm F6 th ì hiện cửa sổ tiếp  theo (theo th ứ tự v òng qu anh: 1 -> 2 ->   3 -> 1).",LTHDT_PhamVanAt.pdf - Sentence 2173
2174,Chương tr ình sử dụng ph ương pháp truy nh ập trực tiếp bộ nhớ m àn hình trình b ầy trong  chương 9.,LTHDT_PhamVanAt.pdf - Sentence 2174
2175,"// CT10_01.CPP   // lop cua_so   #include <stdio.h>   #include <conio.h>   #include <dos.h>   #include <alloc.h>   typedef unsigned int word;   typed ef unsigned char byte;   struct kt_word   {  word kt;   };  struct kt_byte   {  byte ma, mau;   };  union ky_tu   {  struct kt_byte h;   struct kt_word x;   };  typedef union ky_tu far *VP;   VP vptr=(VP)MK_FP(0xb800,0);   // Vi tri x,y tren man hinh   #define VPOS(x,y) (VP)(vptr + ( (y)-1)*80+(x) -1)  class cua_so   {  private:   char *noidung;   int cao, rong;   int mau; // mau = 16*mau_nen + mau_chu  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          346                                         tenshi3003@gmail.com  int ra_mh;   int posx,posy;   word *pluu;   public:   cua_so();   cua_so(int c,int r,byte mau_nen, byte mau_chu);   int push(int x,int y);   void pop();   int get _ra_mh();   };  cua_so::cua_so()   {  cao=rong=mau=ra_mh=posx=posy=0;   noidung=NULL; pluu=NULL;   }  cua_so::cua_so(int c,int r,byte mau_nen, byte mau_chu)   {  cao=c; rong=r;   mau= 16*mau_nen+mau_chu;   ra_mh=posx=posy=0;   noidung = (char*)malloc(cao*rong);   for (int i=0;i <cao*rong;++i)   noidung[i]=32;   pluu= (word*)malloc(2*cao*rong);   }  int cua_so::push(int x,int y)   {  word *p= pluu; char *pnd=noidung;   VP ptr;   int i,j;   // Luu man hinh   if (ra_mh==0)   {  ra_mh=1;  posx=x;posy=y;   for (i=posx;i<=posx+rong -1;++i)   for (j=posy;j<=pos y+cao -1;++j)   {  ptr=VPOS(i,j); *p=ptr ->x.kt; ++p;   }  }  // Hien noi dung dang soan thao tren cua so  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          347                                         tenshi3003@gmail.com  for (i=posx;i<=posx+rong -1;++i)   for (j=posy;j<=posy+cao -1;++j)   {  ptr=VPOS(i,j);   ptr->h.mau=mau;   ptr->h.ma=*pnd; ++pnd;   }  // Soan thao   int xx=posx,yy=posy,ch1 ,ch2;   while (1)   {  gotoxy(xx,yy);   if ((ch1=getch())==0) ch2=getch();   if (ch1==27)break;  // ESC Ket Thuc Soan Thao   else if (ch1==0&&ch2==64)break; //F6   else if (ch1==13)   {  ++yy; xx=posx; if(yy>=posy+cao) break;   }  else if (ch1!=0)   {  ptr=VPOS(xx,yy);   ptr->h.m a=ch1;   ++xx;   if (xx>=posx+rong) {++yy; xx=posx;}   if (yy>=posy+cao) break;   }  else if (ch2==72||ch2==80||ch2==75||ch2==77)   {  if (ch2==72) yy --;  else if (ch2==80) ++yy;   else if (ch2==75) --xx;  else ++xx;   if (xx<posx) xx=posx;   if (xx>=posx+rong) {++yy; xx=posx ;}  if (yy<posy) yy=posy;   if (yy>=posy+cao) break;   }  }  // Luu ket qua soan thao   pnd=noidung;   for (i=posx;i<=posx+rong -1;++i)  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          348                                         tenshi3003@gmail.com  for (j=posy;j<=posy+cao -1;++j)   {  ptr=VPOS(i,j);   *pnd=ptr ->h.ma; ++pnd;   }  if (ch1==0&&ch2==64) return 0; //F6   else return 1;   }  void cua_so::pop() // Khoi phuc vung nho bi cua so chiem   {  if (ra_mh==0) return;   ra_mh=0;   word *p=pluu;   VP ptr;   int i,j;   for (i=posx;i<=posx+rong -1;++i)   for (j=posy;j<=posy+cao -1;++j)   {  ptr=VPOS(i,j); ptr ->x.kt=*p; ++p;   }  }  int cua_so::get_ra_mh()   {  return ra_m h;  }  //class stack   class stack   {  private:   int max,num;   cua_so **pcs;   public:   stack();   stack(int max_cs);   int accept(cua_so *cs,int x,int y);   void del();   };  stack::stack()   {  max=num=0; pcs=NULL;   } Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          349                                         tenshi3003@gmail.com  stack::stack(int max_cs)   {  max=max_cs; num=0;   pcs=(cua_so**) malloc(max*sizeof(cua_so*));   for (int i=0;i<max;++i) pcs[i]=NULL;   }  int stack::accept(cua_so *cs,int x,int y)   {  int gt;   if (num==max)return 0;   if (!cs ->get_ra_mh())   {  pcs[num]=cs; ++num;   }  gt=cs ->push(x,y);   return gt;   }  void stack::del()   {  if (num==0) retu rn;  --num;   pcs[num] ->pop();   pcs[num]=NULL;   }  main()   {  int ch;   cua_so w1(10,40,GREEN,WHITE),   w2(12,42,CYAN,MAGENTA),   w3(14,44,RED,YELLOW);   stack s(4);   clrscr();   while(1)   {  ch=s.accept(&w1,5,5);   if(ch==1)break;   ch=s.accept(&w2,8,8);   if(ch==1)break;   ch=s.acc ept(&w3,11,11);  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          350                                         tenshi3003@gmail.com  if(ch==1)break;   }  s.del(); s.del(); s.del();   }  Bài 2.",LTHDT_PhamVanAt.pdf - Sentence 2175
2176,Lớp menu   Lớp cmenu có 2 ph ương th ức để tạo lập v à sử dụng menu:   1.,LTHDT_PhamVanAt.pdf - Sentence 2176
2177,"Hàm t ạo  cmenu(int so_cn_menu,char **nd_menu);   dùng đ ể tạo một menu (đối t ượng kiểu cmenu).",LTHDT_PhamVanAt.pdf - Sentence 2177
2178,H àm tạo chứa 2 đối l à:  + Biến so_cn_menu ch ứa số chức năng của menu   + Con tr ỏ nd_menu trỏ tới một v ùng nh ớ chứa địa chỉ các chuỗi ký tự d ùng làm tiêu đ ề menu v à  tiêu đ ề các chức năng menu.,LTHDT_PhamVanAt.pdf - Sentence 2178
2179,"Ví dụ các câu l ệnh:  char *nd[]={""Qu ản lý vật t ư"", ""Nh ập số liệu"",                              ""Tìm ki ếm"",""Kết thúc""};   cmenu mc(3,nd);   sẽ tạo một menu mc gồm 3 chức năng: Nhập số liệu, T ìm ki ếm v à Kết thúc.",LTHDT_PhamVanAt.pdf - Sentence 2179
2180,Menu có ti êu đề là:  Quản lý vật t ư  2.,LTHDT_PhamVanAt.pdf - Sentence 2180
2181,"Phương th ức  int menu(int x,int y,int mau_nen,int mau_chon);   thực hiện các việc sau:   + Hi ển thị menu tại vị trí (x,y) trên màn hình.",LTHDT_PhamVanAt.pdf - Sentence 2181
2182,Menu có m ầu nền xác định bởi đối mau_nen v à  mầu chức năng định chọn (hộp sáng) xác định bởi đối mau_chon.,LTHDT_PhamVanAt.pdf - Sentence 2182
2183,"+ Cho phép s ử dụng các phím mũi t ên lên, xu ống để di chuyển hộp sáng v à dùng phím Enter đ ể  thoát kh ỏi ph ương th ức.",LTHDT_PhamVanAt.pdf - Sentence 2183
2184,"+ Sau khi thoát kh ỏi, ph ương th ức trả về giá trị bằng số thứ tự (tính từ 1) của chức năng đ ược  chọn.",LTHDT_PhamVanAt.pdf - Sentence 2184
2185,Chương tr ình d ưới đây xây dựng lớp cmenu v à minh ho ạ cách sử dụng lớp n ày.,LTHDT_PhamVanAt.pdf - Sentence 2185
2186,"/*  CT10_02.CPP   menu.cpp   lop cmenu   */  #include <stdio.h>   #include <conio.h>   #include <dos.h >  #include <alloc.h>   #include <string.h>   typedef unsigned int word;   typedef unsigned char byte;  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          351                                         tenshi3003@gmail.com  struct kt_word   {  word kt;   };  struct kt_byte   {  byte ma, mau;   };  union ky_tu   {  struct kt_byte h;   struct kt_word x;   };  typedef union ky_tu far *VP;   VP vptr=(VP)MK_ FP(0xb800,0);   // Vi tri x,y tren man hinh   #define VPOS(x,y) (VP)(vptr + ((y) -1)*80+(x) -1)  class cmenu   {  private:   int so_cn,cao,rong,posx,posy;   int chon;   char **nd;   private:   void hiendc(char *dc,int x,int y, int mau);   void hien_menu(int x,int y,int mau_nen, int mau_chon);   public:   cmenu(int so_cn_menu,char **nd_menu);   int menu(int x,int y,int mau_nen,int mau_chon);   };  cmenu::cmenu(int so_cn_menu,char **nd_menu)   {  cao=so_cn=so_cn_menu; nd=nd_menu;   rong=0;   chon=1;   int d;   for(int i=0;i<=so_cn;++i)   if( (d=strlen(n d[i])) > rong) rong=d;   }  void cmenu::hiendc(char *dc,int x,int y, int mau)  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          352                                         tenshi3003@gmail.com  {  VP ptr; int i;   byte m=16*mau+15;  //chu trang   for(i=0;i<rong;++i)   {  ptr=VPOS(x+i,y);   ptr->h.mau=m ;   ptr->h.ma=32;   }  for(i=0;i<rong;++i)   {  ptr=VPOS(x+i,y);   if(dc[i]==0)break;   ptr->h.ma=dc[i];   }  }  void cmenu::hien_menu(int x,int y,int mau_nen,int mau_chon)   {  for(int i=0;i<=so_cn;++i)   hiendc(nd[i],x,y+i,mau_nen);   hiendc(nd[chon],x,y+chon,mau_chon);   }  int cmenu::menu(int x,int y,int mau_nen,int mau_chon)   {  int ch1,ch2,chonluu;   //Trinh bay  hien_menu(x,y,mau_nen,mau_chon);   //Bat phim   while(1)   {  if( (ch1=getch())==0 ) ch2=getch();   if(ch1==13) //chon chuc nang   return (chon);   else if( (ch1==0)&&(ch2==80||ch2==72))   {  //Di chuyen hop sang   chonluu=chon;   if(ch2==80) ++chon;   else --chon;   if(chon< 1) chon=cao;   else if(chon>cao) chon=1;  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          353                                         tenshi3003@gmail.com  if(chon!=chonluu)   {  hiendc(nd[chonluu],x,y+chonluu,mau_nen);   hiendc(nd[chon],x,y+chon,mau_chon);   }  }  }  }  char *nd[]={""TINH DIEN TICH"", ""Tam giac"",""Hinh tron"",   ""Chu nhat"", ""Hinh vuong"", ""Ket thuc chuong trinh""};   void main()   {  cmenu mc(5,nd); int chon;   clrscr();   while(1)   {  chon=mc.menu(5,5,BLUE,MAGENTA);   if(chon==1)   {  clrscr();   puts(""TAM GIAC"");   getch(); clrscr();   }  else if(chon==2)   {  clrscr();   puts(""HINH TRON"");   getch();clrscr();   }  else if(chon==3)   {  clrscr();   puts(""CH U NHAT"");   getch();clrscr();   }  else if(chon==4)   {  clrscr();   puts(""HINH VUONG"");   getch(); clrscr();   }  else break;  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          354                                         tenshi3003@gmail.com  }  }  Bài 3.",LTHDT_PhamVanAt.pdf - Sentence 2186
2187,Lớp h ình h ọc  Chương tr ình d ưới đây gồm:   + Lớp “hinh” l à lớp cơ sở trừu t ượng  + Và 3 l ớp dẫn suất từ lớp “h ình” là:   - Lớp “khoihop” bi ểu thị các khối hộp lập ph ương   - Lớp “duong” biểu thị các đoạn thẳng qua 2 điểm   - Lớp “tron” biểu thị các đ ường tr òn  Chương tr ình minh ho ạ cách d ùng tư ợng ứng bội v à phương th ức ảo.,LTHDT_PhamVanAt.pdf - Sentence 2187
2188,Nội dung ch ương tr ình nh ư  sau:   + Khi ch ạy ch ương tr ình s ẽ thấy xuất hiện một khối hộp lập ph ương.,LTHDT_PhamVanAt.pdf - Sentence 2188
2189,+ Có th ể di chuyển khối hộp bằng các phím mũi t ên.,LTHDT_PhamVanAt.pdf - Sentence 2189
2190,+ Bấm phím Q sẽ xuất hiện một đoạn thẳng.,LTHDT_PhamVanAt.pdf - Sentence 2190
2191,+ Có th ể di chuyển đoạn thẳng bằng các phím mũi t ên.,LTHDT_PhamVanAt.pdf - Sentence 2191
2192,+ Bấm phím Q sẽ xuất hiện một đ ường tr òn.,LTHDT_PhamVanAt.pdf - Sentence 2192
2193,+ Có th ể di chuyển đ ường tr òn bằng các phím  mũi tên.,LTHDT_PhamVanAt.pdf - Sentence 2193
2194,+ Bấm phím Q sẽ kết thúc ch ương tr ình.,LTHDT_PhamVanAt.pdf - Sentence 2194
2195,"/*  CT10_03.CPP   LOP hinh hoc   Minh hoa cach dung:   + lop co so truu tuong   + Tuong ung boi va phuong thuc ao   */  #include <graphics.h>   #include <process.h>   #include <stdio.h>   #include <conio.h>   char getkey(int &d x,int &dy);   class  hinh   {  protected:   int mau;   public:   hinh(void)   {  mau=0;   } Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          355                                         tenshi3003@gmail.com  hinh(int m)   {  mau=m;   }  virtual void dchuyen(int b)=0;   };  class khoihop : public hinh   {  private:   int x,y;   int  a ;   public:   khoihop(void):hinh()   {  x=y=a=0;   }  khoihop(int m,int x1,int  y1, int a1):hinh(m)   {  x=x1;   y=y1;   a=a1;   }  virtual void dchuyen(int b);   void  hien(void)   {  setfillstyle(1,mau);   bar3d(x,y,x+a,y+a,a/2,1);   }  void an(void)   {  setfillstyle(1,getbkcolor());   bar(x,y -a/2,x+a+a/2,y+a+a/2);   }  };  class duong:public  hinh   {  private:   int x1,y1,x2,y2;   public:  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          356                                         tenshi3003@gmail.com  duong(void):hinh()   {  x1=x2=y1=y1=0;   }  duong(int m,int a,int b,int c,int d):hinh(m)   {  x1=a;y1=b;x2=c;y2=d;   }  virtual void dchuyen(int b);   void  hien(void)   {  setcolor(mau);   line(x1,y1,x2,y2);   }  void an(void)   {  setcolor(getbkcolor()) ;  line(x1,y1,x2,y2);   }  };  class tron:public  hinh   {  private:   int x,y,r;   public:   tron(void):hinh()   {  x=y=r=0;   }  tron(int m,int a,int b,int d):hinh(m)   {  x=a; y=b; r=d;   }  virtual void dchuyen(int b);   void  hien(void)   {  setcolor(mau);   circle(x,y,r);   }  void an( void)   { Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          357                                         tenshi3003@gmail.com  setcolor(getbkcolor());   circle(x,y,r);   }  };  char getkey(int &dx,int &dy)   {  int ch1,ch2;   dx=dy=0;   while (1)   {  ch1=getch();   if (ch1==0)   ch2=getch();   if (ch1=='q'||ch1=='Q')  return('q');   if ((ch1==0&&(ch2==80||ch2==72||ch2==75||ch2==77)))   {    if (ch2 ==80)  dy=1;   else if (ch2==72)  dy= -1;  else if (ch2==77) dx=1;   else dx= -1;  return(0);   }  }  }  void khoihop::dchuyen(int b)   {  int dx,dy;   while (1)   {  hien();   if (getkey(dx,dy)=='q')  break;   an();   x+=b*dx;   y+=b*dy;   }  }  void duong::dchuyen(int b)   {  int dx,dy;   while (1)   { Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          358                                         tenshi3003@gmail.com  hien();   if (getkey(dx,dy)=='q')  break;   an();   x1+=b*dx;   x2+=b*dx;   y1+=b*dy;   y2+=b*dy;   }  }  void tron::dchuyen(int b)   {  int dx,dy;   while (1)   {  hien();   if (getkey(dx,dy)=='q')  break;   an();   x+=b*dx;   y+=b*dy;   }  }  void main()   {  int  mh=0,mode=0;   initgraph(&mh,&mode,"""");   if (graphresult())   {  printf("" \n LOI"");   getch();   exit(0);   }  setbkcolor(0);   //  setwritemode(0);   hinh  *h[3];   khoihop  M(4,300,200,15);   duong D(10,10,10,60,60);   tron  T(14,200,200,50);   h[0]=&M; h[1]=&D;h[2]=&T;   for(int i=0;i<3;++i)   h[i]->dchuyen(10);   closegraph();  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          359                                         tenshi3003@gmail.com  }  Bài 4.",LTHDT_PhamVanAt.pdf - Sentence 2195
2196,Các l ớp ngăn xếp v à hàng đ ợi  Chương tr ình tổ chức th ành 4 l ớp chính:   1.,LTHDT_PhamVanAt.pdf - Sentence 2196
2197,Lớp container  (thùng ch ứa) gồm 2 thuộc tính:   unsigned long count; //S ố phần tử  trong th ùng ch ứa  void (*errhandler)();  //Con tr ỏ tới h àm x ử lý lỗi   2.,LTHDT_PhamVanAt.pdf - Sentence 2197
2198,"Lớp s_list thừa kế từ lớp container , có thêm 2 thu ộc tính các con trỏ kiểu cấu trúc listnode:   struct listnode   {  void *dataptr;   listnode *next;   };  listnode *head;  // Tr ỏ tới đầu danh sách   listnode *tail;    // Tr ỏ tới cuối danh sách   Các ph ần tử đ ược ch ứa trong lớp s_list d ưới dạng một danh sách móc nối đ ơn.",LTHDT_PhamVanAt.pdf - Sentence 2198
2199,M ỗi nút chứa địa  chỉ của một phần tử.,LTHDT_PhamVanAt.pdf - Sentence 2199
2200,Do ở đây d ùng ki ểu con trỏ void n ên có th ể đưa vào l ớp s_list các phần tử có  kiểu bất kỳ.,LTHDT_PhamVanAt.pdf - Sentence 2200
2201,3.,LTHDT_PhamVanAt.pdf - Sentence 2201
2202,Lớp stack thừa kế từ lớp s_list   4.,LTHDT_PhamVanAt.pdf - Sentence 2202
2203,Lớp queue thừa kế từ lớp stack   Các lớp stack v à queue không có các thu ộc tính ri êng.,LTHDT_PhamVanAt.pdf - Sentence 2203
2204,Hai phương th ức quan trọng của các lớp  này là:   virtual int store(void *item) ; // C ất vào m ột phần tử   virtual void *retrieve () ; // L ấy ra một phần tử   Chú ý là:  Lớp stack hoạt động theo nguy ên tắc LIFO  (vào sau ra trư ớc) c òn lớp queue hoạt động  theo nguyên t ắc FIFO  (v ào trư ớc ra tr ước) .,LTHDT_PhamVanAt.pdf - Sentence 2204
2205,"Chương tr ình sau minh ho ạ cách d ùng liên k ết bội, ph ương th ức ảo v à con tr ỏ kiểu void để quản  lý các ki ểu dữ liệu khác nhau.",LTHDT_PhamVanAt.pdf - Sentence 2205
2206,"Hoạt động của ch ương tr ình nh ư sau:   + Trư ớc tiên l ần lượt đưa địa chỉ của biến đối t ượng ts1, chuỗi “HA NOI”, biến nguy ên a, bi ến  đối tượng ts2 v à biến thực x v ào ngăn x ếp s1 v à hàng đ ợi q1.",LTHDT_PhamVanAt.pdf - Sentence 2206
2207,+ Th ực hiện phép gán các biến đối t ượng:  s2 = s1 ;   q2 = q1 ;   + Lấy các phần tử trong ngăn xếp s2 theo tr ình tự ngược với lúc đ ưa vào.,LTHDT_PhamVanAt.pdf - Sentence 2207
2208,+ Lấy các phần tử trong h àng đ ợi q2 theo tr ình tự như lúc đưa vào.,LTHDT_PhamVanAt.pdf - Sentence 2208
2209,/*  CT10_05.CPP   Lop vat chua (container)   Lop danh sach moc noi   Lop ngan xep  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          360                                         tenshi3003@gmail.com  Lop hang doi   Chu y:   1.,LTHDT_PhamVanAt.pdf - Sentence 2209
2210,constructor sao chep cua lop dan suat   2.,LTHDT_PhamVanAt.pdf - Sentence 2210
2211,toan tu gan cua lop dan  suat  3.,LTHDT_PhamVanAt.pdf - Sentence 2211
2212,co the dung cac phuong thuc khac   de viet constructor va destructor   4.,LTHDT_PhamVanAt.pdf - Sentence 2212
2213,"Dung con tro this   */  #include <stdio.h>   #include <iostream.h>   #include <iomanip.h>   #include <conio.h>   #include <alloc.h>   #include <dos.h>   //Lop container   class container   {  prote cted:   unsigned long count; //so pt trong thung chua   void (*errhandler)();   public:   container();   container(const container &c); // Ham tao sao chep   void operator=(const container &c); // Gan   unsigned long getcount(); // Cho biet so phan tu   // Dinh ham xl loi   void seterrorhandler(void (*userhandler)());   // 4 phuong thuc thuan ao   virtual int store(void *item)=0;//Cat mot phan tu vao thung   virtual void *examine()=0; // Xem gia tri  mot phan tu   virtual void *retrieve ()=0; // Lay mot pt ra   virtual void empty()=0;  // Lam cho thung tro nen rong   };  // Cai dat   // Ham xl loi mac dinh   void defaulthandler();   void defaulthandler()   {  puts("" \nContainer error: memory allocation failure"");   }  container::container ()  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          361                                         tenshi3003@gmail.com  {  count=0;  errhandler= defaulthandler;   }  container::containe r(const container &c)   {  count=c.count;   errhandler=c.errhandler;   }  // Gan   void container::operator=(const container &c)   {  count=c.count;   errhandler=c.errhandler;   }  // Cho biet so pt   unsigned long container::getcount()   {  return count;   }  // Dinh ham xl lo i  void container::seterrorhandler(void (*userhandler)())   {  errhandler=userhandler;   }  // Lop danh sach moc noi don   class s_list:public container   {  protected:   //Cau truc mot nut trong ds   struct listnode   {  void *dataptr;   listnode *next;   };  listnode *head;   listnode *tail;   private:   // phuong thuc sao chep   void copy(const s_list &s1);   public:   s_list();   s_list(const s_list &s1);  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          362                                         tenshi3003@gmail.com  ~s_list();   void operator=(const s_list &s1);   // 4 phuong thuc  ao   virtual int store(void *item)=0; // Cat mot phan tu vao   // thung   virtu al void *examine()=0; // Xem gia tri  mot phan tu   virtual void *retrieve ()=0; // Lay mot pt ra   virtual void empty(); // Lam cho thung tro nen rong   };  //Cai dat   void s_list::copy(const s_list &s1)   {  head=NULL; tail=NULL;   listnode *temp = s1.head;   while(tem p!=NULL)   {  if(head==NULL)   {  head= new listnode;   if(head==NULL) errhandler();   tail=head;   }  else  {  tail->next = new listnode;   if(tail ->next == NULL) errhandler();   tail = tail ->next;   }  tail->dataptr= temp ->dataptr;   tail->next=NULL;   temp = temp ->next;   }  }  // constructor   s_list::s_list() : container()   {  head=NULL; tail=NULL;   }  s_list::s_list(const s_list &s1):container(s1)   { Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          363                                         tenshi3003@gmail.com  copy(s1);   }  s_list::~s_list()   {  this->empty();   }  void s_list::operator=(const s_list &s1)   {  this->empty();   count=s1.count;   copy(s1);   }  void s_list::empty()   {  listnode *q,*p;   p = head; head=NULL; tail=NULL;   while (p!=NULL)   {  q=p; p=p ->next;   delete q;   }  }  // Lop stack   class stack:public s_list   {  public:   stack();   stack(const stack &st);   void operator=(const stack &st);   virtual int store(void *it em); // Cat mot phan tu vao thung   virtual void *examine(); // Xem gia tri  mot phan tu   virtual void *retrieve(); // Lay mot pt ra   };  stack::stack():s_list()   {  }  stack::stack(const stack &st):s_list(st)   {  }  void stack::operator=(const stack &st)   {  this->s_list::operator=(st); //Dung toan tu gan cua s_list  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          364                                         tenshi3003@gmail.com  }  int stack::store(void *item) // Cat mot phan tu vao thung   {  //Dua vao dau danh sach   listnode *p;   p= new listnode ;   if(p==NULL) return 1;   count++;   p->dataptr=item; p ->next=head;   head=p;  return 0;   }  void * stack::examine() // Xem gia tri  mot phan tu   {  if(count==0) return NULL;   else  return head ->dataptr;   }  void *stack::retrieve() // Lay mot pt ra   {  if(count==NULL) return NULL;   else  {  listnode *p; void *value;   value = head ->dataptr;   p=head;   head = p ->next;   delete p;   count --;  return value;   }  }  // Lop queue   class queue:public stack   {  public:   queue();   queue(const queue &q);   void operator=(const queue &q);   virtual int store(void *item); // Cat mot phan tu vao thung   };  queue::queue(): stack()   { Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          365                                         tenshi3003@gmail.com  }  queue::queue(const  queue &q):stack(q)   {  }  void queue::operator=(const queue &q)   {  this->stack::operator=(q); //Dung toan tu gan cua stack   }  int queue::store(void *item)   {  // Dat vao cuoi   listnode *q;   q=new listnode;   if(q==NULL)return 1;   // Bo sung   q->next=NULL; q ->dataptr=i tem;  if(count==0)   {  head=q; tail=q;   }  else  {  tail->next=q;   tail=q;   }  count++; return 0;   }  class TS   {  private:   char ht[25];   int sobd;   float td;   public:   void nhap()   {  cout << "" \nHo ten: "" ;   fflush(stdin);   gets(ht);   cout << ""So bao danh: "" ;  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          366                                         tenshi3003@gmail.com  cin >> sobd;   cout << ""Tong diem: "" ;   cin >> td;   }  void xuat()   {  cout << "" \nHo ten: "" << ht;   cout << "" \nSo bao danh: "" << sobd;   cout << "" \nTong diem: "" << setiosflags(ios::showpoint)   << setprecision(1)<<setw(5)<< td;   }  };  // Ham main   void main()   {  stack s1,s2; queue q1,q2;   TS ts1,ts2,ts;   int a=123,b;   float x=3.14,y;   char *str;   clrscr();   ts1.nhap();   ts2.nhap();   //Gui vao   s1.store(&ts1); q1.store(&ts1);   s1.store(""HA NOI""); q1.store(""HA NOI"");   s1.store(&a); q1.store(&a);   s1.store(&ts2); q1.store(&ts2);   s1.store(&x); q1.store(&x );  //Lay ra tu ngan xep theo nguyen tac LIFO   cout <<"" \n\nLay ra tu ngan xep:"" ;   s2=s1;   y =  *((float*)s2.retrieve());   cout << "" \nSo thuc = "" <<setiosflags(ios::showpoint)   << setprecision(2)<< y;   ts =  *((TS*)s2.retrieve());   ts.xuat();   b =  *((int*)s2.retri eve());   cout << "" \nSo nguyen = "" << b;   str = (char*)s2.retrieve();  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          367                                         tenshi3003@gmail.com  cout << "" \nChuoi ky tu: "" << str;   ts =  *((TS*)s2.retrieve());   ts.xuat();   //Lay ra tu hang doi theo nguyen tac FIFO   cout <<"" \n\nLay ra tu hang doi:"" ;   q2=q1;   ts =  *((TS*)q2.retrieve());   ts.xuat();   str = (char*)q2.retrieve();   cout << "" \nChuoi ky tu: "" << str;   b =  *((int*)q2.retrieve());     cout << "" \nSo nguyen = "" << b;   ts =  *((TS*)q2.retrieve());   ts.xuat();   y =  *((float*)q2.retrieve());   cout << "" \nSo thuc = "" << setiosflags(ios::showpoint)   << setprecision(2)<< y;   getch();   }  Bài 5.",LTHDT_PhamVanAt.pdf - Sentence 2213
2214,"Các l ớp sắp xếp   Trong t ệp C_SORT.H d ưới đây sẽ chứa 4 lớp sắp xếp: sort, select_sort, quick_sort  v à heap_sort.",LTHDT_PhamVanAt.pdf - Sentence 2214
2215,tổng quát h ơn.,LTHDT_PhamVanAt.pdf - Sentence 2215
2216,So v ới các lớp sắp xếp trong mục §7 chương 6 th ì các l ớp ở đây tổng quát h ơn ở  chỗ:    + Các l ớp trong mục §7 chương 6 ch ỉ cho phép sắp xếp một dẫy số nguy ên theo th ứ tự tăng dần.,LTHDT_PhamVanAt.pdf - Sentence 2216
2217,"+ Các l ớp dưới đây cho phép sắp xếp một dẫy phần tử có kiểu bất kỳ (nguy ên, th ực, cấu trúc,  lớp, ...) v à theo m ột tiêu chu ẩn sắp xếp bất kỳ.",LTHDT_PhamVanAt.pdf - Sentence 2217
2218,1.,LTHDT_PhamVanAt.pdf - Sentence 2218
2219,"Lớp sort  là lớp cơ sở trừu t ượng       + Các thu ộc tính:   protected:   void  *a ;   // Tr ỏ tới v ùng nh ớ chứa dẫy   // phần tử cần sắp xếp   int  size ;    // Đ ộ lớn tính theo byte của phần tử   int  (*nho_hon)(void* pt1, void* pt2); // Con tr ỏ hàm  // định nghĩa pt1 nhỏ h ơn pt2   + Các phương th ức:  protected:   void hoan_vi(int i, int j) ; // Hoán v ị các phần tử thứ i v à j Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          368                                         tenshi3003@gmail.com  void * dia_chi (int m);   // Cho đ ịa chỉ của phần tử thứ m   public:   virtual void sapxep(void *a1,int n,int itemsize,   int (*ss_nho_hon)(void* ,void* )) ;  // S ắp xếp  dẫy  // n ph ần tử chứa trong v ùng nh ớ a1, mỗi phần tử   // có đ ộ dài itemsize, th ứ tự tăng đ ược quy định   // bởi hàm ss_nho_hon   2.",LTHDT_PhamVanAt.pdf - Sentence 2219
2220,Lớp select_sort  dẫn xuất  từ lớp sort.,LTHDT_PhamVanAt.pdf - Sentence 2220
2221,Lớp n ày sẽ thực hiện việc sắp xếp theo ph ương pháp  chon (xem m ục §7 chương 6).,LTHDT_PhamVanAt.pdf - Sentence 2221
2222,"+ Các ph ương th ức:  public:   virtual void sapxep(void *a1,int n,int itemsize,   int (*ss_nho_hon)(void* ,void* )) ;  // th ực hiện   // sắp xếp theo ph ương pháp ch ọn  3.",LTHDT_PhamVanAt.pdf - Sentence 2222
2223,Lớp quick_sort dẫn xuất  từ lớp sort.,LTHDT_PhamVanAt.pdf - Sentence 2223
2224,"Lớp n ày sẽ thực hiện việc sắp xếp theo ph ương pháp  quick sort (x em m ục §7 chương 6)    + Các phương th ức:  private:   void q_sort(int l, int r);   public:   virtual void sapxep(void *a1,int n,int itemsize,   int (*ss_nho_hon)(void* ,void* )) ;  // th ực hiện   // sắp xếp theo ph ương pháp quick sort   4.",LTHDT_PhamVanAt.pdf - Sentence 2224
2225,Lớp heap_sort  dẫn xuất  từ lớp  sort.,LTHDT_PhamVanAt.pdf - Sentence 2225
2226,L ớp này sẽ thực hiện việc sắp xếp theo ph ương pháp  heap sort (xem m ục §7 chương 6).,LTHDT_PhamVanAt.pdf - Sentence 2226
2227,"+ Các phương th ức:  private:   void shift(int i, int n);   public:   virtual void sapxep(void *a1,int n,int itemsize,   int (*ss_nho_hon)(void* ,void* )) ;  // th ực hiện   // sắp xếp theo ph ương pháp heap sort   Dưới đây l à nội dung tệp C_SORT.H   //C_SORT.H   // Lop co so truu tuong   // Lop sort   #include <conio.h>  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          369                                         tenshi3003@gmail.com  #include <stdio.h>   #include <stdlib.h>   #include <iostream.h>   #include <iomanip.h>   #include <mem.h>   class sort   {  protected :  void *a;   int size;   int (*nho_hon)(void*,void*);   void* dia_chi(int m)   {  return (void*)  ((char*)a + size*(m -1));  }  void hoan_vi(int i, int j)   {  void *tg, *di, *dj;   di= dia_chi(i);   dj= dia_chi(j);   tg = new char[size];   memcpy(tg,di,size);   memcpy(di,dj,size) ;  memcpy(dj,tg,size);   }  public:   virtual void sapxep(void *a1,int n,int itemsize,   int (*ss_nho_hon)(void*,void*))   {  a=a1;   size=n; // Cho C++ hai long   size=itemsize;   nho_hon= ss_nho_hon;   }  } ;  class select_sort : public sort   {  public:   virtual void sapxep(voi d *a1,int n,int itemsize,   int (*ss_nho_hon)(void*,void*)) ;   } ;  void select_sort::sapxep(void *a1,int n,int itemsize,  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          370                                         tenshi3003@gmail.com  int (*ss_nho_hon)(void*,void*))   {  int i,j,r;   sort::sapxep(a1,n,itemsize,ss_nho_hon);   for(i=1; i<n; ++i)   {  r=i;  for(j=i+1; j<=n; ++j)   if(nh o_hon(dia_chi(j),dia_chi(r))) r = j;   if(r!=i) hoan_vi(i,r);   }  }  class quick_sort : public sort   {  private:   void q_sort(int l, int r);   public:   virtual void sapxep(void *a1,int n,int itemsize,   int (*ss_nho_hon)(void*,void*)) ;   } ;  void quick_sort::q_sort(int l, int r)   {  void *x;   int i,j;   x = new char[size];   if(l < r)   {  memcpy(x, dia_chi(l), size);   i = l; j = r+1;   do  {  ++i;  --j;  while(i<r &&  nho_hon(dia_chi(i),x)) ++i ;   while(nho_hon(x,dia_chi(j)) ) --j ;  if(i<j) hoan_vi(i,j);   } while (i<j);   hoan_vi(l,j);   q_sort(l,j -1);  q_sort(j+1,r);   } Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          371                                         tenshi3003@gmail.com  }  void quick_sort::sapxep(void *a1,int n,int itemsize,   int (*ss_nho_hon)(void*,void*))   {  sort::sapxep(a1,n,itemsize,ss_nho_hon);   q_sort(1,n);   }  class heap_sort : public sort   {  private:   void shift(int i, int n);   public:   virtual void sapxep(void *a1,int n,int itemsize,   int (*ss_nho_hon)(void*,void*));   } ;  void heap_sort::shift(int i, int n)   {  int l,r,k;   l = 2*i; r = l+1;   if(l>n) return;   if(l==n)   {  if (nho_hon(dia_chi(i), dia_chi(l)))   hoan_vi(i,l);   return;   }  if(nho_hon(dia_chi(r), dia_chi(l)))   k = l;   else  k = r;   if (!nho_hon(dia_chi(i), dia_chi(k)))   return;   else  {  hoan_vi(i,k);   shift(k,n);   }  }  void heap_sort::sapxep(void *a1,int n,int itemsize,   int (*ss_nho_hon)(void*,void*))   {  long i;  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          372                                         tenshi3003@gmail.com  sort::sapxep(a1,n,itemsize,ss_nho_hon);   // Tao dong   for(i=n/2 ; i>=1; --i) shift(i,n);   // Lap   for(i=n ; i>=2; --i)  {  hoan_vi(1,i);   shift(1,i -1);  }  }  Bài 6.",LTHDT_PhamVanAt.pdf - Sentence 2227
2228,Ví d ụ về Các lớp sắp xếp   Trong m ục này trình b ầy 2 ch ương tr ình minh ho ạ cách d ùng các l ớp nói tr ên.,LTHDT_PhamVanAt.pdf - Sentence 2228
2229,Chương tr ình th ứ  nhất minh hoạ cách sử dụng các l ớp trong tệp C_SORT.H để sắp xếp một dẫy thí sinh theo thứ tự  giảm v à thứ tự tăng của tổng điểm.,LTHDT_PhamVanAt.pdf - Sentence 2229
2230,Ch ương tr ình th ứ hai minh hoạ cách d ùng các l ớp trong  C_SORT.H đ ể sắp xếp một dẫy số nguy ên theo chi ều tăng v à chi ều giảm.,LTHDT_PhamVanAt.pdf - Sentence 2230
2231,"Chương tr ình 1   //CT10 -08  // Lop  co so truu tuong   // Lop sort   #include ""c_sort.h""   class TS   {  private:   char ht[25];   int sobd;   float td;   public:   float get_td()   {  return td;   }  void nhap()   {  cout << "" \nHo ten: "" ;   fflush(stdin);   gets(ht);   cout << ""So bao danh: "" ;   cin >> sobd;   cout << ""Tong diem: "" ;   cin >> td;   } Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          373                                         tenshi3003@gmail.com  void xuat()   {  cout << "" \nHo ten: "" << ht;   cout << "" \nSo bao danh: "" << sobd;   cout << "" \nTong diem: "" << setiosflags(ios::showpoint)   << setprecision(1)<<setw(5)<< td;   }  };  int ss_tong_diem_giam(void *ts1, void *ts2)   {  return ( ((TS*)t s1)->get_td() > ((TS*)ts2) ->get_td()) ;   }  int ss_tong_diem_tang(void *ts1, void *ts2)   {  return ( ((TS*)ts1) ->get_td() < ((TS*)ts2) ->get_td()) ;   }  void main()   {  TS t[100];   sort *sa;   int n,i;   clrscr();   cout << "" \nSo thi sinh: "";   cin >> n;   for(i=1; i<=n; ++i)  t[i].nhap();   for(i=1; i<=n; ++i) t[i].xuat();   getch();   cout << "" \n\nSap xep giam theo tong diem - PP Select Sort"" ;   sa= new select_sort;   sa->sapxep( t+1,n,sizeof(TS),ss_tong_diem_giam);   for(i=1; i<=n; ++i) t[i].xuat();   delete sa;   getch();   cout << "" \n\nSap  xep tang theo tong diem - PP Select Sort"";   sa= new select_sort;   sa->sapxep( t+1,n,sizeof(TS),ss_tong_diem_tang);   for(i=1; i<=n; ++i) t[i].xuat();   delete sa;   getch();   cout << "" \n\nSap xep giam theo tong diem - PP Quick Sort"" ;  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          374                                         tenshi3003@gmail.com  sa= new quick_sort;   sa->sapxe p( t+1,n,sizeof(TS),ss_tong_diem_giam);   for(i=1; i<=n; ++i) t[i].xuat();   delete sa;   getch();   cout << "" \n\nSap xep tang theo tong diem - PP Quick Sort"" ;   sa= new quick_sort;   sa->sapxep( t+1,n,sizeof(TS),ss_tong_diem_tang);   for(i=1; i<=n; ++i) t[i].xuat();   delete sa;   getch();   cout << "" \n\nSap xep giam theo tong diem - PP Heap Sort"" ;   sa= new heap_sort;   sa->sapxep( t+1,n,sizeof(TS),ss_tong_diem_giam);   for(i=1; i<=n; ++i) t[i].xuat();   delete sa;   getch();   cout << "" \n\nSap xep tang theo tong diem - PP Heap Sort"" ;  sa= new heap_sort;   sa->sapxep( t+1,n,sizeof(TS),ss_tong_diem_tang);   for(i=1; i<=n; ++i) t[i].xuat();   delete sa;   getch();   }  Chương tr ình 2   //CT10 -09  // Lop co so truu tuong   // Lop sort   #include ""c_sort.h""   int ss_tang(void *i1,void *i2)   {  return *((int*)i1 ) < *((int*)i2);   }  int ss_giam(void *i1,void *i2)   {  return *((int*)i1) > *((int*)i2);   }  void main()   {  int i,n;  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          375                                         tenshi3003@gmail.com  struct time t1,t2;   int b[20],a[20], k, tg, sec, hund;   n=10;   sort *s[3];   select_sort ss;   quick_sort  qs;   heap_sort   hs;   s[0]=&ss; s[1]=&qs; s[2]= &hs;   clrscr();   srand(5000);   for(i=1;i<=n;++i)   b[i]=rand();   cout<<"" \nDay ban dau \n "";  for(i=1;i<=n;++i) cout <<b[i]<<"" "";   cout<<"" \n\nCac day tang sap xep theo "";   cout << ""select_sort, quick_sort, heap_sort \n"";  for(k=0; k<3; ++k)   {  for(i=1;i<=n;++i)   a[i]=b[i ];  s[k]->sapxep (a+1,n,sizeof(int),ss_tang);   //In  for(i=1;i<=n;++i) cout <<a[i]<<"" "";   cout<<"" \n"";  }  cout<<"" \n\nCac day giam sap xep theo "";   cout << ""select_sort, quick_sort, heap_sort \n"";  for(k=0; k<3; ++k)   {  for(i=1;i<=n;++i)   a[i]=b[i];   s[k]->sapxep (a+1, n,sizeof(int),ss_giam);   //In  for(i=1;i<=n;++i) cout <<a[i]<<"" "";   cout << "" \n"";  }  getch();   }   Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          376                                         tenshi3003@gmail.com  Phụ lục 1   Thứ  tự ưu tiên c ủa các phép toán   Các phép toán đư ợc chia th ành 16 nhóm.",LTHDT_PhamVanAt.pdf - Sentence 2231
2232,Các phép toán trong cùng nhóm có m ực độ ưu tiên như  nhau.,LTHDT_PhamVanAt.pdf - Sentence 2232
2233,"Về trình tự kết hợp th ì:   + Các phép tính c ủa nhóm 2, nhóm 14 v à toán t ử gán (nhóm 15) kết hợp từ phải sang trái.",LTHDT_PhamVanAt.pdf - Sentence 2233
2234,+ Các phép toán còn l ại kết hợp từ trái qua phải.,LTHDT_PhamVanAt.pdf - Sentence 2234
2235,1.,LTHDT_PhamVanAt.pdf - Sentence 2235
2236,Nhóm m ột  ()   Gọi ho àm (Function call)   []   Chỉ số mảng (Array subscript)   ->   Chọn gián tiếp một th ành ph ần (indirect component selector)   ::     Xác đ ịnh phạm vi truy nhập (scope access/resolution)   .,LTHDT_PhamVanAt.pdf - Sentence 2236
2237,Chọn trực tiếp một th ành ph ần (direct component selector)   2.,LTHDT_PhamVanAt.pdf - Sentence 2237
2238,Nhóm hai   ()  Gọi ho àm (Function call)   !,LTHDT_PhamVanAt.pdf - Sentence 2238
2239,"Phủ định logic (Logical negation -NOT)   ~   Lấy phần b ù theo bit (Bitwise (1's) complement)   +   Dấu cộng (Unary plus)   -    Dấu trừ (Unary minus)   ++  Phép tăng m ột (Preincrement or postincrement)   --   Phép gi ảm một (Predecrement or postdecrement)   &   Phép l ấy địa chỉ  (Address)   *    Truy nh ập gián tiếp  (Indirection)   sizeof Cho kích thư ớc của toán hạng (returns size of operand, in bytes)   new C ấp phát bộ nh ớ động (dynamically allocates C++ storage)   delete Gi ải phóng bộ nhớ  (dynamically deallocates C++ storage)   3.",LTHDT_PhamVanAt.pdf - Sentence 2239
2240,Nhóm ba   *   Nhân  ( Multiply)   /     Chia  (Divide)   %   Lấy phần d ư  (Remainder  - modulus)   4.,LTHDT_PhamVanAt.pdf - Sentence 2240
2241,Nhóm b ốn  .*    Gọi gián tiếp tới th ành ph ần từ một b iến đối t ượng  ->*  Gọi gián tiếp tới th ành ph ần từ một con trỏ đối t ượng  5.,LTHDT_PhamVanAt.pdf - Sentence 2241
2242,Nhóm năm   +   Cộng  (Binary plus)   -    Trừ  (Binary minus)   6.,LTHDT_PhamVanAt.pdf - Sentence 2242
2243,Nhóm sáu   <<  Dịch trái (Shift left)  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          377                                         tenshi3003@gmail.com  >>   Dịch phải  (Shift right)   7.,LTHDT_PhamVanAt.pdf - Sentence 2243
2244,Nhóm b ẩy  <   Nhỏ hơn (Less than)   <=  Nhỏ hơn ho ặc bằng (Less than or equal to)   >    Lớn hơn  (Greater than)   >=  Lớn hơn ho ặc bằng (Greater than or equal to)   8.,LTHDT_PhamVanAt.pdf - Sentence 2244
2245,Nhóm tám   == Bằng  (Equal to)   !=   Không b ằng (Not equal to)   9.,LTHDT_PhamVanAt.pdf - Sentence 2245
2246,Nhóm chín   &   Phép và theo bit  (Bitwise AND)   10.,LTHDT_PhamVanAt.pdf - Sentence 2246
2247,Nhóm mư ời  ^   Phép ho ặc loại trừ theo bit  (Bitwise XOR)   11.,LTHDT_PhamVanAt.pdf - Sentence 2247
2248,Nhóm mư ời một   |   Phép ho ặc theo bit  (Bitwise OR)   12.,LTHDT_PhamVanAt.pdf - Sentence 2248
2249,Nhóm mư ời hai   && Phép và logic  (Logical AND)   13.,LTHDT_PhamVanAt.pdf - Sentence 2249
2250,Nhóm mư ời ba   &&  Phép ho ặc logic  (Logical OR)   14.,LTHDT_PhamVanAt.pdf - Sentence 2250
2251,Nhóm mư ời bốn   ?:   Toán t ử điều kiện  (a ?,LTHDT_PhamVanAt.pdf - Sentence 2251
2252,"x : y  means ""if a then x, el se y"")   15.",LTHDT_PhamVanAt.pdf - Sentence 2252
2253,Nhóm mư ời năm   =   Phép gán đơn gi ản (Simple assignment)   *=  Phép gán sau khi nhân (Assign product)   /=  Phép gán sau khi chia (Assign quotient)   %=  Phép gán sau khi l ấy phần d ư (Assign remainder)   +=  Phép gán sau khi c ộng (Assign sum)   -=  Phép gá n sau khi tr ừ (Assign difference)   &=  Phép gán sau khi AND theo bit (Assign bitwise AND)   ^=  Phép gán sau khi XOR theo bit (Assign bitwise XOR)   |=  Phép gán sau khi OR theo bit (Assign bitwise OR)   <<=  Phép gán sau khi d ịch trái (Assign left shift)   >>=  Phép gán sau khi d ịch phải (Assign right shift)   16.,LTHDT_PhamVanAt.pdf - Sentence 2253
2254,"Nhóm mư ời sáu   ,  Toán t ử phẩy d ùng đ ể phân cách các phần tử   Tất cả các toán tử nói tr ên đều có thể định nghĩa chồng trừ các toán tử sau:   .",LTHDT_PhamVanAt.pdf - Sentence 2254
2255,Chọn trực tiếp một th ành ph ần  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          378                                         tenshi3003@gmail.com  .*  Gọi gián tiếp tới th ành ph ần từ một biến đối t ượng  ::   Toán t ử xác định phạm vi truy nhập   ?:  Toán t ử điều kiện  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          379                                         tenshi3003@gmail.com    Phụ lục 2   Các từ khóa  của c++   asm double  new switch   auto else operator  template   break  enum  private  this  case extern  protected  throw   catch  float public  try  char for register  typedef   class  friend  return  union   const  goto short  unsigned   continue  if signed  virtual  default  inline  sizeof  void  delete  int static  volatile   do long struct  while      Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          380                                         tenshi3003@gmail.com  Phụ lục 3   Bảng mã asskey và gi ải quyết   1.,LTHDT_PhamVanAt.pdf - Sentence 2255
2256,"Bảng m ã ascii   Bộ ký tự ASCII gồm 256 ký tự đ ược phân bố nh ư sau:   + 32 ký t ự đầu ti ên là các ký t ự điều khiển không in đ ược nh ư ký tự Enter (m ã 13), ký t ự ESC  (mã 27).",LTHDT_PhamVanAt.pdf - Sentence 2256
2257,"+ Các mã ASCII 32 -47, 58 -64, 91 -96 và 123 -127 l à các ký t ự đặc biệt nh ư dấu chấm, dấu phẩy,  dấu cách, dấu ngoặc, dấu móc, dấu hỏi,...",LTHDT_PhamVanAt.pdf - Sentence 2257
2258,+ Các mã ASCII 48 -57 là 10 ch ữ số  + Các mã ASCII 65 -90 là các ch ữ cái hoa từ A đến Z   + Các mã ASCII 97 -122 là các ch ữ cái th ường từ a đến z   Lưu ý: Chữ thường có m ã ASCII  lớn hơn 32 so v ới chữ hoa t ương ứng.,LTHDT_PhamVanAt.pdf - Sentence 2258
2259,Ví dụ m ã ASCII c ủa a l à  97 còn mã ASCII c ủa A l à 65.,LTHDT_PhamVanAt.pdf - Sentence 2259
2260,+ Các mã ASCII 128 -255 là các ký t ự đồ hoạ.,LTHDT_PhamVanAt.pdf - Sentence 2260
2261,Bảng sau cho m ã ASCII c ủa 128 ký tự đầu ti ên.,LTHDT_PhamVanAt.pdf - Sentence 2261
2262,"Đ ể nhận đ ược các ký tự đồ hoạ (có m ã từ 128  đến 255) có thể d ùng chương tr ình sau:   // In các ký t ự đồ hoạ l ên màn hình   #include <stdio.h>   #include <conio.h>   main()   {  int i;  clrscr();   for (i=128; i<=255; ++i)   printf(""%6d%2c"",i,i);   }      Bảng m ã ASCII   mã  ký tự  mã  ký tự  mã  ký tự  (Số TT)  (Số TT)  (Số TT)   0  NUL  26 SUB  52 4  1  SOH  27 ESC 53 5  2  STX  28 FS 54 6  3  ETX  29 GS 55 7  4  EOT  30 RS 56 8  5 ENQ  31 US 57 9  6  ACK  32 Space  58 :  7  BEL  33 !",LTHDT_PhamVanAt.pdf - Sentence 2262
2263,59 ;  8 BS 34 “ 60 <  9 HT 35 # 61 = Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          381                                         tenshi3003@gmail.com  10 LF 36 $ 62 >  11 VT 37 % 63 ?,LTHDT_PhamVanAt.pdf - Sentence 2263
2264,"12 FF 38 & 64 @  13 CR 39 ‘ 65 A  14 SO 40 ( 66 B  15 SI 41 ) 67 C  16 DLE  42 * 68 D  17 DC1  43 + 69 E  18 DC2  44 , 70 F  19 DC3  45 - 71 G  20 DC4  46 .",LTHDT_PhamVanAt.pdf - Sentence 2264
2265,72 H  21 NAK  47 / 73 I  22 SYN  48 0 74 J  23 ETB  49 1 75 K  24 CAN  50 2 76 L  25 EM 51 3 77 M  78  N  95 _ 112 p  79 O 96 * 113 q  80 P 97 a 114 r  81 Q 98 b 115 s  82 R 99 c 116 t  83 S 100 d 117 u  84 t 101 e 118 v  85 U 102 f 119 w  86 V 103 g 120 x  87 W 104 h 121 y  88 X 105 i 122 z  89 Y 106 J 123 {  90 Z 107 k 124 |  91 [ 108 l 125 }  92 \ 109 m 126 ~  93 ] 110 n 127 DEL   94 ^ 111 o     2.,LTHDT_PhamVanAt.pdf - Sentence 2265
2266,"Bảng m ã scan t ừ bàn phím   Mỗi phím tr ên bàn phím c ủa IBM PC đều đ ược gán một con số, gọi l à mã scan, t ừ 1 đến 83.",LTHDT_PhamVanAt.pdf - Sentence 2266
2267,"IBM  PC AT đùng m ột nhóm m ã khác, t ừ 1 đến 108 các m ã này b ắt đầu bằng các phím số, các phím chữ,  rồi đến các ph ím ch ức năng v à cuối cùng là các phím cho con tr ỏ, khi một phím đ ược nhấn th ì bộ  xử lý của b àn phím g ửi cho CPU m ã scan t ương ứng, khi nó đ ược nhả th ì mã scan c ộng th êm 80  hex s ẽ được gửi tiếp cho CPU.",LTHDT_PhamVanAt.pdf - Sentence 2267
2268,"Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          382                                         tenshi3003@gmail.com   Hex  Thập phân  Phím c ủa PC  Phím c ủa PC -AT  1  1  ESC  Tilde   2-B  2-11  1-9,0  1-9,0  C  12  trừ, gạch d ưới  trừ, gạch d ưới  D  13  =, +  =, +  E  14  Backspace  \,thanh đ ứng  F  15  Tab  Backspace   10  16  Q  Tab  11  17  W  Q   12  18  E  W   13  19  R  E   14  20  T  R   15  21  Y  T   16  22  U  Y   17  23  I  U   18  24  O  I   19  25  P  O   1A  26  [  P   1B  27  ]  [   1C  28  Enter  ]  1D  29  Ctrl  1E  30  A  Ctrl  1F  31  S  A   20  32  D  S   21  33  F  D   22  34  G  F   23  35  H  G   24  36  J  H   25  37  K  J   26  38  L  K   27  39  Chấm phẩy, :  L  28  40  Nháy  Chấm phẩy,:   29  41  Tidle  Nháy   2A  42  Shift  trái  2B  43  \, thanh đ ứng  Enter   2C  44  Z  Shift trái   2D  45  X  2E  46  C  Z   2F  47  V  X   30 48  B  C  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          383                                         tenshi3003@gmail.com  31  49  N  V   32  50  M  B   33  51  Phảy  N   34  52  Chấm  M  35  53  /,?",LTHDT_PhamVanAt.pdf - Sentence 2268
2269,"Phảy   36  54  Shift ph ải  Chấm  37  55  *, PrtScr  /, ?",LTHDT_PhamVanAt.pdf - Sentence 2269
2270,"38  56  Alt  39  57  Space bar  Shift ph ải  3A  58  Caps Lock  Alt  3B  59  F1   3C  60  F2  3D  61  F3  Space bar   3E  62  F4   3F  63  F5  40  64  F6  Caps Lock   41  65  F7  F2   42  66  F8  F4   43  67  F9  F6   44  68  F10  F8  45  69  Num Lock  F10  46  70  Scroll Lock,Break  F1   47  71  Home  F3   48  72  mũi tên lên  F5   49  73  PgUp  F7   4A  74  Dấu trừ b àn tính  F9  4B  75  Mũi tên trái   4C  76  5  của bàn tính   4D  77  Mũi tên ph ải   4F  79  End  50  80  Mũi tên xu ống  51  81  PgDn   52  82  Ins   53  83  Del  5A  90   ESC  5B  91   Home   5C  92   Mũi tên trái   5D  93   End  5F  95   Num Lock   60  96   Mũi tên lên  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          384                                         tenshi3003@gmail.com  61  97   5 của bàn tính   62  98   Mũi tên xu ống  63  99   Ins  64  100   Scroll Lock   65  101   PgUp   66  102   Mũi tên ph ải  67  103   PgDn   68  104   Del   69  105   Sys  6A  106   *, PrtScr   6B  107   -   6C  108   +                                  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          385                                         tenshi3003@gmail.com  Phụ lục 4     Hàm v ới đối số bất định trong C   Trong các giáo trình C th ường chỉ h ướng dẫn cách xây dựng h àm v ới các đối cố định.",LTHDT_PhamVanAt.pdf - Sentence 2270
2271,Mỗi đối  cần có một tham số (c ùng ki ểu với nó) trong lời gọi h àm.,LTHDT_PhamVanAt.pdf - Sentence 2271
2272,"Tuy nhiên m ột vài hàm chu ẩn của C lại  không như v ậy, m à linh ho ạt hơn, ch ẳng khi d ùng hàm printf hay scanf thì s ố tham số m à ta cung  cấp cho h àm là không c ố định cả về số l ượng lẫn kiểu cách.",LTHDT_PhamVanAt.pdf - Sentence 2272
2273,"Ví dụ trong câu lệnh:   printf(“ \n Tổng = %d “ , 3+4+5) ;   có 2 tham s ố, nh ưng trong câu l ệnh:  printf(“ \n Hà N ội“ ) ;   chỉ có một th am số.",LTHDT_PhamVanAt.pdf - Sentence 2273
2274,"Như v ậy cần phân biệt các khái niệm sau:   - Đối số cố định đ ược khai báo trong d òng đầu của h àm, nó có tên và ki ểu  - Tham s ố ứng với đối số cố định gọi l à tham s ố cố định   - Đối bất định đ ược khai báo bởi ba dấu chấm: bất định cả về số l ượng v à kiểu  - Tham s ố bất định (ứng với đối bất định) l à một danh sách giá trị với số l ượng v à kiểu tuỳ ý  (không xác đ ịnh)   Trong ph ụ lục n ày sẽ trình b ầy cách xây dựng các h àm v ới đối số bất định.",LTHDT_PhamVanAt.pdf - Sentence 2274
2275,Công cụ chủ yếu  được dùng là con tr ỏ và danh sách.,LTHDT_PhamVanAt.pdf - Sentence 2275
2276,1.,LTHDT_PhamVanAt.pdf - Sentence 2276
2277,"Bi ến con trỏ   Biến con trỏ (hay con trỏ) d ùng đ ể chứa địa chỉ của biến, mảng, h àm, ...",LTHDT_PhamVanAt.pdf - Sentence 2277
2278,"Có nhi ều kiểu địa chỉ, v ì  vậy cũng có nhiều kiểu con trỏ.",LTHDT_PhamVanAt.pdf - Sentence 2278
2279,"Biến con trỏ đ ược khai báo theo mẫu:   Kiểu   *T ên_bi ến_con_trỏ ;   Ví dụ:  float  px ;   // px là con tr ỏ thực   Các phép toán quan trọng tr ên con tr ỏ gồm:   + Gán đ ịa chỉ một v ùng nh ớ cho con trỏ (d ùng toán t ử gán, phép lấy địa chỉ, các h àm c ấp phát bộ  nhớ)  + Truy nh ập vào vùng nh ớ thông qua con trỏ, d ùng phép toán:   *Tên_con_tr ỏ  (Để ý ở đây có 2 v ùng nh ớ: vùng nh ớ của biến con trỏ v à vùng nh ớ mà địa chỉ đầu của nó chứa  trong bi ến con trỏ)   +  Cộng địa chỉ để con trỏ chứa địa chỉ của phần tử tiếp theo, d ùng phép toán:   ++ Tên_con_tr ỏ     hoặc   T ên_con_tr ỏ ++   Chú ý  rằng các phép toán tr ên ch ỉ có thể thực hiện đối với con trỏ có kiểu.",LTHDT_PhamVanAt.pdf - Sentence 2279
2280,2.,LTHDT_PhamVanAt.pdf - Sentence 2280
2281,"Da nh sách không cùng ki ểu  Dùng con tr ỏ có kiểu chỉ quản lý đ ược một danh sách giá trị c ùng ki ểu, ví dụ dẫy số thực, dẫy số  nguyên, d ẫy các cấu trúc,....",LTHDT_PhamVanAt.pdf - Sentence 2281
2282,"Khi c ần quản lý một danh sách các giá trị không c ùng ki ểu ta phải d ùng con tr ỏ không kiểu  (void) khai báo  như sau:   void  * Tên_con_tr ỏ ; Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          386                                         tenshi3003@gmail.com  Con tr ỏ void có thể chứa các địa chỉ có kiểu bất kỳ, v à dùng đ ể trỏ đến v ùng nh ớ chứa danh sách  cần quản lý.",LTHDT_PhamVanAt.pdf - Sentence 2282
2283,"Một chú ý quan trọng l à mỗi khi gửi v ào hay l ấy ra một giá trị từ v ùng nh ớ, thì tuỳ theo  kiểu giá trị m à ta ph ải dùng phép chuy ển kiểu thích hợp đối với con trỏ.",LTHDT_PhamVanAt.pdf - Sentence 2283
2284,"Ví dụ sau minh hoạ cách  lập một danh sách gồm một số nguy ên, m ột số thực v à một chuỗi ký tự.",LTHDT_PhamVanAt.pdf - Sentence 2284
2285,"Chúng ta cần một bộ nhớ  để chứa số nguy ên, số thực v à địa chỉ chuỗi v à dùng các con tr ỏ void để quản lý v ùng nh ớ này.",LTHDT_PhamVanAt.pdf - Sentence 2285
2286,"void  *list  , *p ;  //  Con tr ỏ list trỏ tới đầu danh sách   // p dùng đ ể duyệt qua các phần tử của danh sách   list=malloc(sizeof(int) + sizeof(float)+ sizeof(char*) );   p=list;   *((int*)p)  = 12;  // Đưa s ố nguy ên 12 vào danh sách   ((int*)p)++ ;       // C huyển sang phần tử tiếp theo   *((float*)p)  = 3.14; // Đưa s ố thực 3.14 v ào danh sách   ((float*)p)++ ;        // Chuy ển sang phần tử tiếp theo   *((char**)p)  = “HA NOI”;   // Đưa đ ịa chỉ chuỗi “HA NOI”   // vào danh sách   // Nh ận các phần tử  trong danh sách    p=list;  // V ề đầu danh sách   int a = *((int*)p);  // Nh ận phần tử thứ nhất   ((int*)p)++ ;    // Chuy ển sang phần tử tiếp theo   float  x= *((float*)p);   // Nh ận phần tử thứ hai   ((float*)p)++ ; // Chuy ển sang phần tử tiếp theo   char *str   =  *((char**) p) ;  // Nh ận phần tử thứ ba   3.",LTHDT_PhamVanAt.pdf - Sentence 2286
2287,Hàm v ới  đối số bất định              + Đối bất định bao giờ cũng đặt sau c ùng và đư ợc khai báo bằng dấu ba chấm.,LTHDT_PhamVanAt.pdf - Sentence 2287
2288,"Ví dụ ví dụ h àm  void f(int n, char *s, ...) ;   có 2 đ ối cố định l à n, s và đ ối bất định.",LTHDT_PhamVanAt.pdf - Sentence 2288
2289,+ Để nhận đ ược các th am số bất định trong lời gọi h àm ta c ần lưu ý các đi ểm sau:   - Các tham s ố bất định chứa trong một danh sách.,LTHDT_PhamVanAt.pdf - Sentence 2289
2290,Để nhận đ ược địa chỉ đầu danh sách ta d ùng  một con trỏ void v à phép gán sau:   void  *list ;   list = ...,LTHDT_PhamVanAt.pdf - Sentence 2290
2291,";   - Dùng m ột tham số cố định kiểu chuỗi để q uy định số l ượng v à kiểu của mỗi tham số trong danh  sách, ví d ụ:           “3i”   hi ểu là : tham s ố bất định gồm 3 giá trị int   “3f”   hi ểu là : tham s ố bất định gồm 3 giá trị float   “fiss” hi ểu là có 4 tham s ố bất định có kiểu lần l ượt là float, int, char*,  char*   Một khi đ ã biết được địa chỉ đầu danh sách, biết đ ược số l ượng v à kiểu của mỗi tham số , th ì dễ  dàng nh ận được giá trị các tham số để sử dụng trong thân h àm.",LTHDT_PhamVanAt.pdf - Sentence 2291
2292,Ví dụ sau đây minh ho ạ cách xây dựng các h àm v ới tham số bất định.,LTHDT_PhamVanAt.pdf - Sentence 2292
2293,"H àm dùng đ ể in các giá t rị  kiểu int, float v à char.",LTHDT_PhamVanAt.pdf - Sentence 2293
2294,Hàm có m ột tham số cố định để cho biết có bao nhi êu giá tr ị và kiểu các giá  trị cần in.,LTHDT_PhamVanAt.pdf - Sentence 2294
2295,"Kiểu quy định nh ư sau: i là int, f là float, s là char*.",LTHDT_PhamVanAt.pdf - Sentence 2295
2296,Tham s ố có 2 cách viết: lặp (gồm một  hằng số nguy ên và m ột chữ cái định kiểu) v à liệt kê (một dẫy các chữ cái định kiểu).,LTHDT_PhamVanAt.pdf - Sentence 2296
2297,"Ví dụ:  563 564 Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          387                                         tenshi3003@gmail.com  “4s”    có ngh ĩa in 4 chuỗi   “siif”  có ngh ĩa in một chuỗi, 2 giá trị  nguy ên và m ột giá trị thực:   #include <stdio.h>   #include <ctype.h>   #include <string.h>   #include <conio.h>   #include <stdlib.h>   #include <stda rg.h>   void InDanhSachGiaTri(char *st,...)   {  void *list ;   int gt_int ;   float gt_float;   char *gt_str;   int n,i ;   char kieu;   int lap;   list = ...",LTHDT_PhamVanAt.pdf - Sentence 2297
2298,";  // list tro toi vung nho chua danh sach dia chi cac   // tham so   lap = isdigit(st[0])  ;   if (lap)   n=st[0] - '0' ;  else  n=strlen(st);   printf("" \n n= %d lap = %d"",n,lap); getch();   for(i=0;i<n;++i)   {  if(lap)   kieu=st[1];   else  kieu = st[i];   printf("" \nKieu= %c"",kieu); getch();   switch(kieu)   {  case 'i' :   gt_int =  *((int*)list);   if(!lap)   ((int*)list)++  ;   printf("" \nGia tri % d = %d"",i,gt_int);   break;  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          388                                         tenshi3003@gmail.com  case 'f' :   gt_float = (float) (*((double*)list));   if(!lap)   ((double*)list)++  ;   printf("" \nGia tri %d = %0.2f"",i,gt_float);   break;           case 's' :   gt_str = *((char**)list) ;   if(!lap)   ((char**)list)++  ;    printf("" \nGia tri %d = % s"",i,gt_str);   }  }  }  void main()     {  float x=3.14;   int a=123;   char *tp=""HAI PHONG"";   InDanhSachGiaTri(""4i"",a);   InDanhSachGiaTri(""4s"",""HA NOI"");   InDanhSachGiaTri(""ifsssffii"", a, x, tp, tp,""QUY NHON"",   x, 6.28, a, 246);   InDanhSachGiaTri(""4f"",6.28);   getch();   }  4.",LTHDT_PhamVanAt.pdf - Sentence 2298
2299,Hàm không đ ối và hàm v ới đối bất định   Nhiều ng ười nghĩ h àm khai báo như sau   void  f();   là hàm không đ ối trong C.,LTHDT_PhamVanAt.pdf - Sentence 2299
2300,"Trong C++ th ì hiểu nh ư thế là đúng, c òn trong C thì đó là hàm có đ ối bất  định (h àm không đ ối trong C khai báo nh ư sau: f(void) ).",LTHDT_PhamVanAt.pdf - Sentence 2300
2301,"Do không c ó đối cố định n ào cho bi ết về  số lượng v à kiểu của các tham số bất định, n ên gi ải pháp ở đây l à dùng các bi ến to àn bộ.",LTHDT_PhamVanAt.pdf - Sentence 2301
2302,Rõ ràng  giải pháp n ày không không thu ận tiện cho ng ười dùng vì ph ải khai báo đúng t ên bi ến to àn bộ và  phải khởi gán giá trị cho nó tr ước khi g ọi hàm.,LTHDT_PhamVanAt.pdf - Sentence 2302
2303,Ví d ụ trình b ầy một h àm ch ỉ có đối bất định d ùng đ ể  tính max và min c ủa các giá trị thực.,LTHDT_PhamVanAt.pdf - Sentence 2303
2304,"Các tham số bất định đ ược đưa vào theo tr ình tự sau: Địa chỉ  chứa max, địa chỉ chứa min, các giá trị nguy ên cần tính max, min.",LTHDT_PhamVanAt.pdf - Sentence 2304
2305,"Ch ương tr ình dùng bi ến to àn bộ  N để cho biết số giá trị nguy ên cần tính max, min.",LTHDT_PhamVanAt.pdf - Sentence 2305
2306,int N;   void maxmin()   {  void *lt = ...,LTHDT_PhamVanAt.pdf - Sentence 2306
2307,";  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          389                                         tenshi3003@gmail.com  float *max, *min ,  tg;   int i;  max = *((float**)lt)++;   min = *((float**)lt)++;   *max = *min = (float) *((double*)lt)++;   for(i=1;i<N;++i)   {  tg= (float) *((double* )lt)++;   if(tg > *max) *max = tg;   if(tg < *min) *min = tg;   }  }                         Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          390                                         tenshi3003@gmail.com  phụ lục 5   Tóm t ắt các hàm c ủa Turbo C theo thứ tự ABC     1.",LTHDT_PhamVanAt.pdf - Sentence 2307
2308,_chmod  <io.h>     2.,LTHDT_PhamVanAt.pdf - Sentence 2308
2309,_close  <io.h>     3.,LTHDT_PhamVanAt.pdf - Sentence 2309
2310,_creat  <io.h>     4.,LTHDT_PhamVanAt.pdf - Sentence 2310
2311,_open  <io.h>     5.,LTHDT_PhamVanAt.pdf - Sentence 2311
2312,abort  <process.h>   6.,LTHDT_PhamVanAt.pdf - Sentence 2312
2313,abs <stdlib.h>   7.,LTHDT_PhamVanAt.pdf - Sentence 2313
2314,acos <math.h>   8.,LTHDT_PhamVanAt.pdf - Sentence 2314
2315,arc <graphics.h>   9.,LTHDT_PhamVanAt.pdf - Sentence 2315
2316,asin <math.h>   10.,LTHDT_PhamVanAt.pdf - Sentence 2316
2317,atan <math.h>   11.,LTHDT_PhamVanAt.pdf - Sentence 2317
2318,atan2  <math.h>   12.,LTHDT_PhamVanAt.pdf - Sentence 2318
2319,atof <ctype.h>   13.,LTHDT_PhamVanAt.pdf - Sentence 2319
2320,atoi <ctype.h>   14.,LTHDT_PhamVanAt.pdf - Sentence 2320
2321,atol <ctype.h>   15.,LTHDT_PhamVanAt.pdf - Sentence 2321
2322,bar <graphics.h>    16.,LTHDT_PhamVanAt.pdf - Sentence 2322
2323,bar3d  <graphics.h>    17.,LTHDT_PhamVanAt.pdf - Sentence 2323
2324,cabs <math.h>   18.,LTHDT_PhamVanAt.pdf - Sentence 2324
2325,calloc  <alloc.h>   19.,LTHDT_PhamVanAt.pdf - Sentence 2325
2326,ceil <math.h>   20.,LTHDT_PhamVanAt.pdf - Sentence 2326
2327,chdir  <dir.h>   21.,LTHDT_PhamVanAt.pdf - Sentence 2327
2328,chmod  <io.h>     22.,LTHDT_PhamVanAt.pdf - Sentence 2328
2329,circle  <graphics.h>     23.,LTHDT_PhamVanAt.pdf - Sentence 2329
2330,cleardevive  <graphics.h>     24.,LTHDT_PhamVanAt.pdf - Sentence 2330
2331,clearviewport  <graph ics.h>     25.,LTHDT_PhamVanAt.pdf - Sentence 2331
2332,close  <io.h>     26.,LTHDT_PhamVanAt.pdf - Sentence 2332
2333,clreol  <conio.h>     27.,LTHDT_PhamVanAt.pdf - Sentence 2333
2334,clrscr  <conio.h>     28.,LTHDT_PhamVanAt.pdf - Sentence 2334
2335,coreleft  <alloc.h>   29.,LTHDT_PhamVanAt.pdf - Sentence 2335
2336,cos <math.h>   30.,LTHDT_PhamVanAt.pdf - Sentence 2336
2337,cosh <math.h>   31.,LTHDT_PhamVanAt.pdf - Sentence 2337
2338,cprintf  <conio.h>     32.,LTHDT_PhamVanAt.pdf - Sentence 2338
2339,creat  <io.h>     33.,LTHDT_PhamVanAt.pdf - Sentence 2339
2340,cscanf  <conio.h>     34.,LTHDT_PhamVanAt.pdf - Sentence 2340
2341,delay  <dos.h>     35.,LTHDT_PhamVanAt.pdf - Sentence 2341
2342,delline  <conio.h>     36.,LTHDT_PhamVanAt.pdf - Sentence 2342
2343,disable  <dos.h>     37.,LTHDT_PhamVanAt.pdf - Sentence 2343
2344,drawpoly  <graphics.h>    Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          391                                         tenshi3003@gmail.com  38.,LTHDT_PhamVanAt.pdf - Sentence 2344
2345,ecvt <ctype.h>   39.,LTHDT_PhamVanAt.pdf - Sentence 2345
2346,ellipse  <graphics.h>     40.,LTHDT_PhamVanAt.pdf - Sentence 2346
2347,enable  <dos.h>     41.,LTHDT_PhamVanAt.pdf - Sentence 2347
2348,exit <process.h>   42.,LTHDT_PhamVanAt.pdf - Sentence 2348
2349,exp <math.h>   43.,LTHDT_PhamVanAt.pdf - Sentence 2349
2350,fabs <math.h>   44.,LTHDT_PhamVanAt.pdf - Sentence 2350
2351,fclose  <stdio.h>     45.,LTHDT_PhamVanAt.pdf - Sentence 2351
2352,fcloseall  <stdio.h>     46.,LTHDT_PhamVanAt.pdf - Sentence 2352
2353,fcvt <ctype.h>   47.,LTHDT_PhamVanAt.pdf - Sentence 2353
2354,feof <stdio.h>     48.,LTHDT_PhamVanAt.pdf - Sentence 2354
2355,ferror  <stdio.h>     49.,LTHDT_PhamVanAt.pdf - Sentence 2355
2356,fflush  <stdio.h>     50.,LTHDT_PhamVanAt.pdf - Sentence 2356
2357,fflushall  <stdio.h>     51.,LTHDT_PhamVanAt.pdf - Sentence 2357
2358,fgetc  <stdio.h>     52.,LTHDT_PhamVanAt.pdf - Sentence 2358
2359,fgets  <stdio.h>     53.,LTHDT_PhamVanAt.pdf - Sentence 2359
2360,fillpopy  <graphics.h>     54.,LTHDT_PhamVanAt.pdf - Sentence 2360
2361,findfirst  <dir.h>   55.,LTHDT_PhamVanAt.pdf - Sentence 2361
2362,findnext  <dir.h>   56.,LTHDT_PhamVanAt.pdf - Sentence 2362
2363,floodfill  <graphics.h>     57.,LTHDT_PhamVanAt.pdf - Sentence 2363
2364,floor  <math.h>   58.,LTHDT_PhamVanAt.pdf - Sentence 2364
2365,fmode  <math.h>   59.,LTHDT_PhamVanAt.pdf - Sentence 2365
2366,fopen  <stdio.h>     60.,LTHDT_PhamVanAt.pdf - Sentence 2366
2367,FP_OFF  <dos.h>     61.,LTHDT_PhamVanAt.pdf - Sentence 2367
2368,FP_SEG  <dos.h>     62.,LTHDT_PhamVanAt.pdf - Sentence 2368
2369,fprintf  <stdio.h>     63.,LTHDT_PhamVanAt.pdf - Sentence 2369
2370,fprintf  <stdio.h>     64.,LTHDT_PhamVanAt.pdf - Sentence 2370
2371,fputc  <stdio.h>     65.,LTHDT_PhamVanAt.pdf - Sentence 2371
2372,fputs  <stdio.h>     66.,LTHDT_PhamVanAt.pdf - Sentence 2372
2373,fread  <stdio.h>     67.,LTHDT_PhamVanAt.pdf - Sentence 2373
2374,free <alloc.h>   68.,LTHDT_PhamVanAt.pdf - Sentence 2374
2375,fscanf  <stdio.h>     69.,LTHDT_PhamVanAt.pdf - Sentence 2375
2376,fseek  <stdio.h>     70.,LTHDT_PhamVanAt.pdf - Sentence 2376
2377,fteel <stdio.h>     71.,LTHDT_PhamVanAt.pdf - Sentence 2377
2378,fwrite  <stdio.h>     72.,LTHDT_PhamVanAt.pdf - Sentence 2378
2379,gcvt <ctype.h>   73.,LTHDT_PhamVanAt.pdf - Sentence 2379
2380,genin terrupt  <dos.h>     74.,LTHDT_PhamVanAt.pdf - Sentence 2380
2381,getbkcolor  <graphics.h>     75.,LTHDT_PhamVanAt.pdf - Sentence 2381
2382,getc <stdio.h>     76.,LTHDT_PhamVanAt.pdf - Sentence 2382
2383,getch  <conio.h>     77.,LTHDT_PhamVanAt.pdf - Sentence 2383
2384,getchar  <stdio.h>    Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          392                                         tenshi3003@gmail.com  78.,LTHDT_PhamVanAt.pdf - Sentence 2384
2385,getche  <conio.h>     79.,LTHDT_PhamVanAt.pdf - Sentence 2385
2386,getcolor  <graphics.h>     80.,LTHDT_PhamVanAt.pdf - Sentence 2386
2387,getcwd  <dir.h>   81.,LTHDT_PhamVanAt.pdf - Sentence 2387
2388,getdate  <time.h>   82.,LTHDT_PhamVanAt.pdf - Sentence 2388
2389,getimage  <graphics.h>     83.,LTHDT_PhamVanAt.pdf - Sentence 2389
2390,getlinesettings  <graphics.h>      84.,LTHDT_PhamVanAt.pdf - Sentence 2390
2391,getmaxcolor  <graphics.h>     85.,LTHDT_PhamVanAt.pdf - Sentence 2391
2392,getmaxx  <graphics.h>     86.,LTHDT_PhamVanAt.pdf - Sentence 2392
2393,getmaxy  <graphics.h>     87.,LTHDT_PhamVanAt.pdf - Sentence 2393
2394,getpalette  <graphics.h>     88.,LTHDT_PhamVanAt.pdf - Sentence 2394
2395,getpixel  <graphics.h>     89.,LTHDT_PhamVanAt.pdf - Sentence 2395
2396,gets <stdio.h>     90.,LTHDT_PhamVanAt.pdf - Sentence 2396
2397,gettextinfo  <conio.h>     91.,LTHDT_PhamVanAt.pdf - Sentence 2397
2398,gettime  <dos.h>     92.,LTHDT_PhamVanAt.pdf - Sentence 2398
2399,gettime  <time.h>   93.,LTHDT_PhamVanAt.pdf - Sentence 2399
2400,getvect  <dos.h>     94.,LTHDT_PhamVanAt.pdf - Sentence 2400
2401,getviewport  <graphics.h>     95.,LTHDT_PhamVanAt.pdf - Sentence 2401
2402,getw  <stdio.h>     96.,LTHDT_PhamVanAt.pdf - Sentence 2402
2403,gotoxy  <conio.h>     97.,LTHDT_PhamVanAt.pdf - Sentence 2403
2404,gotoxy  <conio.h>     98.,LTHDT_PhamVanAt.pdf - Sentence 2404
2405,grapherrormsg  <graphics.h>     99.,LTHDT_PhamVanAt.pdf - Sentence 2405
2406,graphresult  <graphics.h>     100.,LTHDT_PhamVanAt.pdf - Sentence 2406
2407,imagesize  <graphics.h>     101.,LTHDT_PhamVanAt.pdf - Sentence 2407
2408,initgraph  <graphics.h>     102.,LTHDT_PhamVanAt.pdf - Sentence 2408
2409,int86  <dos.h>     103.,LTHDT_PhamVanAt.pdf - Sentence 2409
2410,int86x  <dos.h>     104.,LTHDT_PhamVanAt.pdf - Sentence 2410
2411,intdos  <dos.h>     105.,LTHDT_PhamVanAt.pdf - Sentence 2411
2412,intdosx  <dos.h>     106.,LTHDT_PhamVanAt.pdf - Sentence 2412
2413,intr <dos.h>     107.,LTHDT_PhamVanAt.pdf - Sentence 2413
2414,inxdigit  <ctype.h>   108.,LTHDT_PhamVanAt.pdf - Sentence 2414
2415,isalnum  <ctype.h>   109.,LTHDT_PhamVanAt.pdf - Sentence 2415
2416,isalpha  <ctype.h>   110.,LTHDT_PhamVanAt.pdf - Sentence 2416
2417,iscntrl  <ctype.h>   111.,LTHDT_PhamVanAt.pdf - Sentence 2417
2418,isdigit  <ctype.h>   112.,LTHDT_PhamVanAt.pdf - Sentence 2418
2419,isgraph  <ctype.h>   113.,LTHDT_PhamVanAt.pdf - Sentence 2419
2420,islower  <ctype.h>   114.,LTHDT_PhamVanAt.pdf - Sentence 2420
2421,isprint  <ctype.h>   115.,LTHDT_PhamVanAt.pdf - Sentence 2421
2422,ispunct  <ctype.h>   116.,LTHDT_PhamVanAt.pdf - Sentence 2422
2423,isspace  <ctype.,LTHDT_PhamVanAt.pdf - Sentence 2423
2424,h>   117.,LTHDT_PhamVanAt.pdf - Sentence 2424
2425,isupper  <ctype.h>  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          393                                         tenshi3003@gmail.com  118.,LTHDT_PhamVanAt.pdf - Sentence 2425
2426,itoa <ctype.h>   119.,LTHDT_PhamVanAt.pdf - Sentence 2426
2427,kbhit  <conio.h>     120.,LTHDT_PhamVanAt.pdf - Sentence 2427
2428,keep  <dos.h>     121.,LTHDT_PhamVanAt.pdf - Sentence 2428
2429,labs <stdlib.h>   122.,LTHDT_PhamVanAt.pdf - Sentence 2429
2430,line <graphics.h>     123.,LTHDT_PhamVanAt.pdf - Sentence 2430
2431,linerel  <graphics.h>     124.,LTHDT_PhamVanAt.pdf - Sentence 2431
2432,lineto  <graphics.h>     125.,LTHDT_PhamVanAt.pdf - Sentence 2432
2433,log <math.h>   126.,LTHDT_PhamVanAt.pdf - Sentence 2433
2434,log10  <math.h>   127.,LTHDT_PhamVanAt.pdf - Sentence 2434
2435,lseek  <io.h>     128.,LTHDT_PhamVanAt.pdf - Sentence 2435
2436,ltoa <ctype.h>   129.,LTHDT_PhamVanAt.pdf - Sentence 2436
2437,malloc  <alloc.h>   130.,LTHDT_PhamVanAt.pdf - Sentence 2437
2438,memccpy  <memory.h> ho ặc <string.h>   131.,LTHDT_PhamVanAt.pdf - Sentence 2438
2439,memchr  <memory.h> ho ặc <string.h>   132.,LTHDT_PhamVanAt.pdf - Sentence 2439
2440,memcmp  <memory.h> ho ặc <string.h>   133.,LTHDT_PhamVanAt.pdf - Sentence 2440
2441,memcpy  <memory.h> ho ặc <string.h>   134.,LTHDT_PhamVanAt.pdf - Sentence 2441
2442,memicmp  <memory.h> ho ặc <string.h>   135.,LTHDT_PhamVanAt.pdf - Sentence 2442
2443,memset  <memory.h> ho ặc <string.h>   136.,LTHDT_PhamVanAt.pdf - Sentence 2443
2444,MK_FP  <dos.h>     137.,LTHDT_PhamVanAt.pdf - Sentence 2444
2445,mkdi r <dir.h>   138.,LTHDT_PhamVanAt.pdf - Sentence 2445
2446,movedata  <mem.h>   139.,LTHDT_PhamVanAt.pdf - Sentence 2446
2447,movedata  <memory.h> ho ặc <string.h>   140.,LTHDT_PhamVanAt.pdf - Sentence 2447
2448,moveto  <graphics.h>     141.,LTHDT_PhamVanAt.pdf - Sentence 2448
2449,nosound  <dos.h>     142.,LTHDT_PhamVanAt.pdf - Sentence 2449
2450,open  <io.h>     143.,LTHDT_PhamVanAt.pdf - Sentence 2450
2451,outtext  <graphics.h>    144.,LTHDT_PhamVanAt.pdf - Sentence 2451
2452,outtextxy  <graphics.h>     145.,LTHDT_PhamVanAt.pdf - Sentence 2452
2453,peek  <dos.h>     146.,LTHDT_PhamVanAt.pdf - Sentence 2453
2454,peekb  <dos.h>     147.,LTHDT_PhamVanAt.pdf - Sentence 2454
2455,perror  <stdio.h>    148.,LTHDT_PhamVanAt.pdf - Sentence 2455
2456,pieslice  <graphics.h>   149.,LTHDT_PhamVanAt.pdf - Sentence 2456
2457,poke  <dos.h>     150.,LTHDT_PhamVanAt.pdf - Sentence 2457
2458,pokeb  <dos.h>     151.,LTHDT_PhamVanAt.pdf - Sentence 2458
2459,pow <math.h>   152.,LTHDT_PhamVanAt.pdf - Sentence 2459
2460,printf  <stdio.h>   153.,LTHDT_PhamVanAt.pdf - Sentence 2460
2461,putc <stdio.h>   154.,LTHDT_PhamVanAt.pdf - Sentence 2461
2462,putch  <conio.h>   155.,LTHDT_PhamVanAt.pdf - Sentence 2462
2463,putchar  <stdio.h>   156.,LTHDT_PhamVanAt.pdf - Sentence 2463
2464,putimage  <graphics.h>   157.,LTHDT_PhamVanAt.pdf - Sentence 2464
2465,putpixel  <graphics.h>  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          394                                         tenshi3003@gmail.com  158.,LTHDT_PhamVanAt.pdf - Sentence 2465
2466,puts <stdio.h>     159.,LTHDT_PhamVanAt.pdf - Sentence 2466
2467,putw  <stdio.h>     160.,LTHDT_PhamVanAt.pdf - Sentence 2467
2468,rand <stdlib.h>   161.,LTHDT_PhamVanAt.pdf - Sentence 2468
2469,random <stdlib.h>   162.,LTHDT_PhamVanAt.pdf - Sentence 2469
2470,randomize  <stdlib.h> và <time.h>   163.,LTHDT_PhamVanAt.pdf - Sentence 2470
2471,read <io.h>    164.,LTHDT_PhamVanAt.pdf - Sentence 2471
2472,realloc  <alloc.h>   165.,LTHDT_PhamVanAt.pdf - Sentence 2472
2473,rectangle  <graphics.h>   166.,LTHDT_PhamVanAt.pdf - Sentence 2473
2474,remove  <stdio.h>    167.,LTHDT_PhamVanAt.pdf - Sentence 2474
2475,rewind  <stdio.h>    168.,LTHDT_PhamVanAt.pdf - Sentence 2475
2476,rmdir  <dir.h>   169.,LTHDT_PhamVanAt.pdf - Sentence 2476
2477,scanf  <stdio.h>   170.,LTHDT_PhamVanAt.pdf - Sentence 2477
2478,segread  <dos.h>    171.,LTHDT_PhamVanAt.pdf - Sentence 2478
2479,setbkcolor  <graphics.h>   172.,LTHDT_PhamVanAt.pdf - Sentence 2479
2480,setcolor  <graphics.,LTHDT_PhamVanAt.pdf - Sentence 2480
2481,h>  173.,LTHDT_PhamVanAt.pdf - Sentence 2481
2482,setdate  <time.h>   174.,LTHDT_PhamVanAt.pdf - Sentence 2482
2483,setfillstyle  <graphics.h>   175.,LTHDT_PhamVanAt.pdf - Sentence 2483
2484,setlinestyle  <graphics.h>   176.,LTHDT_PhamVanAt.pdf - Sentence 2484
2485,setpalette  <graphics.h>   177.,LTHDT_PhamVanAt.pdf - Sentence 2485
2486,settextjustify  <graphics.h>   178.,LTHDT_PhamVanAt.pdf - Sentence 2486
2487,settextstyle  <graphics.h>   179.,LTHDT_PhamVanAt.pdf - Sentence 2487
2488,settime  <time.h>   180.,LTHDT_PhamVanAt.pdf - Sentence 2488
2489,setvect  <dos.h>     181.,LTHDT_PhamVanAt.pdf - Sentence 2489
2490,setviewport  <graphics.h>   182.,LTHDT_PhamVanAt.pdf - Sentence 2490
2491,setwritemode  <grap hics.h>   183.,LTHDT_PhamVanAt.pdf - Sentence 2491
2492,sin <math.h>   184.,LTHDT_PhamVanAt.pdf - Sentence 2492
2493,sinh <math.h>   185.,LTHDT_PhamVanAt.pdf - Sentence 2493
2494,sleep  <dos.h>     186.,LTHDT_PhamVanAt.pdf - Sentence 2494
2495,sound  <dos.h>     187.,LTHDT_PhamVanAt.pdf - Sentence 2495
2496,sprintf  <stdio.h>   188.,LTHDT_PhamVanAt.pdf - Sentence 2496
2497,sqrt <math.h>   189.,LTHDT_PhamVanAt.pdf - Sentence 2497
2498,srand  <stdlib.h>   190.,LTHDT_PhamVanAt.pdf - Sentence 2498
2499,strcat  <string.h>   191.,LTHDT_PhamVanAt.pdf - Sentence 2499
2500,strchr  <string.h>   192.,LTHDT_PhamVanAt.pdf - Sentence 2500
2501,strcmp  <string.h>   193.,LTHDT_PhamVanAt.pdf - Sentence 2501
2502,strcmpi  <string.h>   194.,LTHDT_PhamVanAt.pdf - Sentence 2502
2503,strcpy  <string.h>   195.,LTHDT_PhamVanAt.pdf - Sentence 2503
2504,strcspn  <string.h>   196.,LTHDT_PhamVanAt.pdf - Sentence 2504
2505,strdup  <string.h>   197.,LTHDT_PhamVanAt.pdf - Sentence 2505
2506,stricmp  <string.h>  Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          395                                         tenshi3003@gmail.com  198.,LTHDT_PhamVanAt.pdf - Sentence 2506
2507,strlen  <string.h>   199.,LTHDT_PhamVanAt.pdf - Sentence 2507
2508,strlwr  <string.h>   200.,LTHDT_PhamVanAt.pdf - Sentence 2508
2509,strncat  <string.h>   201.,LTHDT_PhamVanAt.pdf - Sentence 2509
2510,strncmp  <string.h>   202.,LTHDT_PhamVanAt.pdf - Sentence 2510
2511,strncpy  <string.h>   203.,LTHDT_PhamVanAt.pdf - Sentence 2511
2512,strnicmp  <string.h>   204.,LTHDT_PhamVanAt.pdf - Sentence 2512
2513,strnset  <string.h>   205.,LTHDT_PhamVanAt.pdf - Sentence 2513
2514,strpbrk  <string.h>   206.,LTHDT_PhamVanAt.pdf - Sentence 2514
2515,strrchr  <string.h>   207.,LTHDT_PhamVanAt.pdf - Sentence 2515
2516,strrev  <string .h>  208.,LTHDT_PhamVanAt.pdf - Sentence 2516
2517,strset  <string.h>   209.,LTHDT_PhamVanAt.pdf - Sentence 2517
2518,strspn  <string.h>   210.,LTHDT_PhamVanAt.pdf - Sentence 2518
2519,strstr  <string.h>   211.,LTHDT_PhamVanAt.pdf - Sentence 2519
2520,strupr  <string.h>   212.,LTHDT_PhamVanAt.pdf - Sentence 2520
2521,system  <process.h>   213.,LTHDT_PhamVanAt.pdf - Sentence 2521
2522,tan <math.h>   214.,LTHDT_PhamVanAt.pdf - Sentence 2522
2523,tanh <math.h>   215.,LTHDT_PhamVanAt.pdf - Sentence 2523
2524,textbackground  <conio.h>   216.,LTHDT_PhamVanAt.pdf - Sentence 2524
2525,textcolor  <conio.h>   217.,LTHDT_PhamVanAt.pdf - Sentence 2525
2526,textheight  <graphics.h>   218.,LTHDT_PhamVanAt.pdf - Sentence 2526
2527,textmode  <conio.h>    219.,LTHDT_PhamVanAt.pdf - Sentence 2527
2528,textwidth  <graphic s.h>  220.,LTHDT_PhamVanAt.pdf - Sentence 2528
2529,time <time.h>   221.,LTHDT_PhamVanAt.pdf - Sentence 2529
2530,tolower  <ctype.h>   222.,LTHDT_PhamVanAt.pdf - Sentence 2530
2531,toupper  <ctype.h>   223.,LTHDT_PhamVanAt.pdf - Sentence 2531
2532,ultoa  <ctype.h>   224.,LTHDT_PhamVanAt.pdf - Sentence 2532
2533,unlink  <stdio.h>   225.,LTHDT_PhamVanAt.pdf - Sentence 2533
2534,wherex  <conio.h>   226.,LTHDT_PhamVanAt.pdf - Sentence 2534
2535,wherey  <conio.h>   227.,LTHDT_PhamVanAt.pdf - Sentence 2535
2536,window  <conio.h>   228.,LTHDT_PhamVanAt.pdf - Sentence 2536
2537,write  <io.h>        Lập Tr ình H ướng Đối T ượng Với C++     GS: Ph ạm Văn Ất                                          396                                         tenshi3003@gmail.com,LTHDT_PhamVanAt.pdf - Sentence 2537
1,"Object-Oriented Programming and Design Patterns Contents 1 Object-Oriented Design 2 1.1 Classes, Objects and Interfaces .",OOP.pdf - Sentence 1
2,.,OOP.pdf - Sentence 2
3,.,OOP.pdf - Sentence 3
4,.,OOP.pdf - Sentence 4
5,.,OOP.pdf - Sentence 5
6,.,OOP.pdf - Sentence 6
7,.,OOP.pdf - Sentence 7
8,.,OOP.pdf - Sentence 8
9,.,OOP.pdf - Sentence 9
10,.,OOP.pdf - Sentence 10
11,.,OOP.pdf - Sentence 11
12,.,OOP.pdf - Sentence 12
13,.,OOP.pdf - Sentence 13
14,.,OOP.pdf - Sentence 14
15,.,OOP.pdf - Sentence 15
16,.,OOP.pdf - Sentence 16
17,.,OOP.pdf - Sentence 17
18,.,OOP.pdf - Sentence 18
19,.,OOP.pdf - Sentence 19
20,.,OOP.pdf - Sentence 20
21,.,OOP.pdf - Sentence 21
22,.,OOP.pdf - Sentence 22
23,.,OOP.pdf - Sentence 23
24,.,OOP.pdf - Sentence 24
25,.,OOP.pdf - Sentence 25
26,.,OOP.pdf - Sentence 26
27,.,OOP.pdf - Sentence 27
28,2 1.2 Polymorphism .,OOP.pdf - Sentence 28
29,.,OOP.pdf - Sentence 29
30,.,OOP.pdf - Sentence 30
31,.,OOP.pdf - Sentence 31
32,.,OOP.pdf - Sentence 32
33,.,OOP.pdf - Sentence 33
34,.,OOP.pdf - Sentence 34
35,.,OOP.pdf - Sentence 35
36,.,OOP.pdf - Sentence 36
37,.,OOP.pdf - Sentence 37
38,.,OOP.pdf - Sentence 38
39,.,OOP.pdf - Sentence 39
40,.,OOP.pdf - Sentence 40
41,.,OOP.pdf - Sentence 41
42,.,OOP.pdf - Sentence 42
43,.,OOP.pdf - Sentence 43
44,.,OOP.pdf - Sentence 44
45,.,OOP.pdf - Sentence 45
46,.,OOP.pdf - Sentence 46
47,.,OOP.pdf - Sentence 47
48,.,OOP.pdf - Sentence 48
49,.,OOP.pdf - Sentence 49
50,.,OOP.pdf - Sentence 50
51,.,OOP.pdf - Sentence 51
52,.,OOP.pdf - Sentence 52
53,.,OOP.pdf - Sentence 53
54,.,OOP.pdf - Sentence 54
55,.,OOP.pdf - Sentence 55
56,.,OOP.pdf - Sentence 56
57,.,OOP.pdf - Sentence 57
58,.,OOP.pdf - Sentence 58
59,.,OOP.pdf - Sentence 59
60,.,OOP.pdf - Sentence 60
61,.,OOP.pdf - Sentence 61
62,.,OOP.pdf - Sentence 62
63,.,OOP.pdf - Sentence 63
64,.,OOP.pdf - Sentence 64
65,2 1.3 Inheritence .,OOP.pdf - Sentence 65
66,.,OOP.pdf - Sentence 66
67,.,OOP.pdf - Sentence 67
68,.,OOP.pdf - Sentence 68
69,.,OOP.pdf - Sentence 69
70,.,OOP.pdf - Sentence 70
71,.,OOP.pdf - Sentence 71
72,.,OOP.pdf - Sentence 72
73,.,OOP.pdf - Sentence 73
74,.,OOP.pdf - Sentence 74
75,.,OOP.pdf - Sentence 75
76,.,OOP.pdf - Sentence 76
77,.,OOP.pdf - Sentence 77
78,.,OOP.pdf - Sentence 78
79,.,OOP.pdf - Sentence 79
80,.,OOP.pdf - Sentence 80
81,.,OOP.pdf - Sentence 81
82,.,OOP.pdf - Sentence 82
83,.,OOP.pdf - Sentence 83
84,.,OOP.pdf - Sentence 84
85,.,OOP.pdf - Sentence 85
86,.,OOP.pdf - Sentence 86
87,.,OOP.pdf - Sentence 87
88,.,OOP.pdf - Sentence 88
89,.,OOP.pdf - Sentence 89
90,.,OOP.pdf - Sentence 90
91,.,OOP.pdf - Sentence 91
92,.,OOP.pdf - Sentence 92
93,.,OOP.pdf - Sentence 93
94,.,OOP.pdf - Sentence 94
95,.,OOP.pdf - Sentence 95
96,.,OOP.pdf - Sentence 96
97,.,OOP.pdf - Sentence 97
98,.,OOP.pdf - Sentence 98
99,.,OOP.pdf - Sentence 99
100,.,OOP.pdf - Sentence 100
101,.,OOP.pdf - Sentence 101
102,.,OOP.pdf - Sentence 102
103,3 1.4 Interfaces .,OOP.pdf - Sentence 103
104,.,OOP.pdf - Sentence 104
105,.,OOP.pdf - Sentence 105
106,.,OOP.pdf - Sentence 106
107,.,OOP.pdf - Sentence 107
108,.,OOP.pdf - Sentence 108
109,.,OOP.pdf - Sentence 109
110,.,OOP.pdf - Sentence 110
111,.,OOP.pdf - Sentence 111
112,.,OOP.pdf - Sentence 112
113,.,OOP.pdf - Sentence 113
114,.,OOP.pdf - Sentence 114
115,.,OOP.pdf - Sentence 115
116,.,OOP.pdf - Sentence 116
117,.,OOP.pdf - Sentence 117
118,.,OOP.pdf - Sentence 118
119,.,OOP.pdf - Sentence 119
120,.,OOP.pdf - Sentence 120
121,.,OOP.pdf - Sentence 121
122,.,OOP.pdf - Sentence 122
123,.,OOP.pdf - Sentence 123
124,.,OOP.pdf - Sentence 124
125,.,OOP.pdf - Sentence 125
126,.,OOP.pdf - Sentence 126
127,.,OOP.pdf - Sentence 127
128,.,OOP.pdf - Sentence 128
129,.,OOP.pdf - Sentence 129
130,.,OOP.pdf - Sentence 130
131,.,OOP.pdf - Sentence 131
132,.,OOP.pdf - Sentence 132
133,.,OOP.pdf - Sentence 133
134,.,OOP.pdf - Sentence 134
135,.,OOP.pdf - Sentence 135
136,.,OOP.pdf - Sentence 136
137,.,OOP.pdf - Sentence 137
138,.,OOP.pdf - Sentence 138
139,.,OOP.pdf - Sentence 139
140,.,OOP.pdf - Sentence 140
141,.,OOP.pdf - Sentence 141
142,3 1.5 Composition .,OOP.pdf - Sentence 142
143,.,OOP.pdf - Sentence 143
144,.,OOP.pdf - Sentence 144
145,.,OOP.pdf - Sentence 145
146,.,OOP.pdf - Sentence 146
147,.,OOP.pdf - Sentence 147
148,.,OOP.pdf - Sentence 148
149,.,OOP.pdf - Sentence 149
150,.,OOP.pdf - Sentence 150
151,.,OOP.pdf - Sentence 151
152,.,OOP.pdf - Sentence 152
153,.,OOP.pdf - Sentence 153
154,.,OOP.pdf - Sentence 154
155,.,OOP.pdf - Sentence 155
156,.,OOP.pdf - Sentence 156
157,.,OOP.pdf - Sentence 157
158,.,OOP.pdf - Sentence 158
159,.,OOP.pdf - Sentence 159
160,.,OOP.pdf - Sentence 160
161,.,OOP.pdf - Sentence 161
162,.,OOP.pdf - Sentence 162
163,.,OOP.pdf - Sentence 163
164,.,OOP.pdf - Sentence 164
165,.,OOP.pdf - Sentence 165
166,.,OOP.pdf - Sentence 166
167,.,OOP.pdf - Sentence 167
168,.,OOP.pdf - Sentence 168
169,.,OOP.pdf - Sentence 169
170,.,OOP.pdf - Sentence 170
171,.,OOP.pdf - Sentence 171
172,.,OOP.pdf - Sentence 172
173,.,OOP.pdf - Sentence 173
174,.,OOP.pdf - Sentence 174
175,.,OOP.pdf - Sentence 175
176,.,OOP.pdf - Sentence 176
177,.,OOP.pdf - Sentence 177
178,.,OOP.pdf - Sentence 178
179,4 1.6 Delegation .,OOP.pdf - Sentence 179
180,.,OOP.pdf - Sentence 180
181,.,OOP.pdf - Sentence 181
182,.,OOP.pdf - Sentence 182
183,.,OOP.pdf - Sentence 183
184,.,OOP.pdf - Sentence 184
185,.,OOP.pdf - Sentence 185
186,.,OOP.pdf - Sentence 186
187,.,OOP.pdf - Sentence 187
188,.,OOP.pdf - Sentence 188
189,.,OOP.pdf - Sentence 189
190,.,OOP.pdf - Sentence 190
191,.,OOP.pdf - Sentence 191
192,.,OOP.pdf - Sentence 192
193,.,OOP.pdf - Sentence 193
194,.,OOP.pdf - Sentence 194
195,.,OOP.pdf - Sentence 195
196,.,OOP.pdf - Sentence 196
197,.,OOP.pdf - Sentence 197
198,.,OOP.pdf - Sentence 198
199,.,OOP.pdf - Sentence 199
200,.,OOP.pdf - Sentence 200
201,.,OOP.pdf - Sentence 201
202,.,OOP.pdf - Sentence 202
203,.,OOP.pdf - Sentence 203
204,.,OOP.pdf - Sentence 204
205,.,OOP.pdf - Sentence 205
206,.,OOP.pdf - Sentence 206
207,.,OOP.pdf - Sentence 207
208,.,OOP.pdf - Sentence 208
209,.,OOP.pdf - Sentence 209
210,.,OOP.pdf - Sentence 210
211,.,OOP.pdf - Sentence 211
212,.,OOP.pdf - Sentence 212
213,.,OOP.pdf - Sentence 213
214,.,OOP.pdf - Sentence 214
215,.,OOP.pdf - Sentence 215
216,.,OOP.pdf - Sentence 216
217,.,OOP.pdf - Sentence 217
218,4 1.7 Parameterized Types .,OOP.pdf - Sentence 218
219,.,OOP.pdf - Sentence 219
220,.,OOP.pdf - Sentence 220
221,.,OOP.pdf - Sentence 221
222,.,OOP.pdf - Sentence 222
223,.,OOP.pdf - Sentence 223
224,.,OOP.pdf - Sentence 224
225,.,OOP.pdf - Sentence 225
226,.,OOP.pdf - Sentence 226
227,.,OOP.pdf - Sentence 227
228,.,OOP.pdf - Sentence 228
229,.,OOP.pdf - Sentence 229
230,.,OOP.pdf - Sentence 230
231,.,OOP.pdf - Sentence 231
232,.,OOP.pdf - Sentence 232
233,.,OOP.pdf - Sentence 233
234,.,OOP.pdf - Sentence 234
235,.,OOP.pdf - Sentence 235
236,.,OOP.pdf - Sentence 236
237,.,OOP.pdf - Sentence 237
238,.,OOP.pdf - Sentence 238
239,.,OOP.pdf - Sentence 239
240,.,OOP.pdf - Sentence 240
241,.,OOP.pdf - Sentence 241
242,.,OOP.pdf - Sentence 242
243,.,OOP.pdf - Sentence 243
244,.,OOP.pdf - Sentence 244
245,.,OOP.pdf - Sentence 245
246,.,OOP.pdf - Sentence 246
247,.,OOP.pdf - Sentence 247
248,.,OOP.pdf - Sentence 248
249,.,OOP.pdf - Sentence 249
250,.,OOP.pdf - Sentence 250
251,5 1.8 Run-Time and Compile-Time Structures .,OOP.pdf - Sentence 251
252,.,OOP.pdf - Sentence 252
253,.,OOP.pdf - Sentence 253
254,.,OOP.pdf - Sentence 254
255,.,OOP.pdf - Sentence 255
256,.,OOP.pdf - Sentence 256
257,.,OOP.pdf - Sentence 257
258,.,OOP.pdf - Sentence 258
259,.,OOP.pdf - Sentence 259
260,.,OOP.pdf - Sentence 260
261,.,OOP.pdf - Sentence 261
262,.,OOP.pdf - Sentence 262
263,.,OOP.pdf - Sentence 263
264,.,OOP.pdf - Sentence 264
265,.,OOP.pdf - Sentence 265
266,.,OOP.pdf - Sentence 266
267,.,OOP.pdf - Sentence 267
268,.,OOP.pdf - Sentence 268
269,.,OOP.pdf - Sentence 269
270,.,OOP.pdf - Sentence 270
271,.,OOP.pdf - Sentence 271
272,.,OOP.pdf - Sentence 272
273,5 1.9 SOLID Principles .,OOP.pdf - Sentence 273
274,.,OOP.pdf - Sentence 274
275,.,OOP.pdf - Sentence 275
276,.,OOP.pdf - Sentence 276
277,.,OOP.pdf - Sentence 277
278,.,OOP.pdf - Sentence 278
279,.,OOP.pdf - Sentence 279
280,.,OOP.pdf - Sentence 280
281,.,OOP.pdf - Sentence 281
282,.,OOP.pdf - Sentence 282
283,.,OOP.pdf - Sentence 283
284,.,OOP.pdf - Sentence 284
285,.,OOP.pdf - Sentence 285
286,.,OOP.pdf - Sentence 286
287,.,OOP.pdf - Sentence 287
288,.,OOP.pdf - Sentence 288
289,.,OOP.pdf - Sentence 289
290,.,OOP.pdf - Sentence 290
291,.,OOP.pdf - Sentence 291
292,.,OOP.pdf - Sentence 292
293,.,OOP.pdf - Sentence 293
294,.,OOP.pdf - Sentence 294
295,.,OOP.pdf - Sentence 295
296,.,OOP.pdf - Sentence 296
297,.,OOP.pdf - Sentence 297
298,.,OOP.pdf - Sentence 298
299,.,OOP.pdf - Sentence 299
300,.,OOP.pdf - Sentence 300
301,.,OOP.pdf - Sentence 301
302,.,OOP.pdf - Sentence 302
303,.,OOP.pdf - Sentence 303
304,.,OOP.pdf - Sentence 304
305,.,OOP.pdf - Sentence 305
306,.,OOP.pdf - Sentence 306
307,.,OOP.pdf - Sentence 307
308,5 2 Design Patterns 6 2.1 Creational Patterns .,OOP.pdf - Sentence 308
309,.,OOP.pdf - Sentence 309
310,.,OOP.pdf - Sentence 310
311,.,OOP.pdf - Sentence 311
312,.,OOP.pdf - Sentence 312
313,.,OOP.pdf - Sentence 313
314,.,OOP.pdf - Sentence 314
315,.,OOP.pdf - Sentence 315
316,.,OOP.pdf - Sentence 316
317,.,OOP.pdf - Sentence 317
318,.,OOP.pdf - Sentence 318
319,.,OOP.pdf - Sentence 319
320,.,OOP.pdf - Sentence 320
321,.,OOP.pdf - Sentence 321
322,.,OOP.pdf - Sentence 322
323,.,OOP.pdf - Sentence 323
324,.,OOP.pdf - Sentence 324
325,.,OOP.pdf - Sentence 325
326,.,OOP.pdf - Sentence 326
327,.,OOP.pdf - Sentence 327
328,.,OOP.pdf - Sentence 328
329,.,OOP.pdf - Sentence 329
330,.,OOP.pdf - Sentence 330
331,.,OOP.pdf - Sentence 331
332,.,OOP.pdf - Sentence 332
333,.,OOP.pdf - Sentence 333
334,.,OOP.pdf - Sentence 334
335,.,OOP.pdf - Sentence 335
336,.,OOP.pdf - Sentence 336
337,.,OOP.pdf - Sentence 337
338,.,OOP.pdf - Sentence 338
339,.,OOP.pdf - Sentence 339
340,.,OOP.pdf - Sentence 340
341,.,OOP.pdf - Sentence 341
342,8 2.1.1 Abstract Factory * .,OOP.pdf - Sentence 342
343,.,OOP.pdf - Sentence 343
344,.,OOP.pdf - Sentence 344
345,.,OOP.pdf - Sentence 345
346,.,OOP.pdf - Sentence 346
347,.,OOP.pdf - Sentence 347
348,.,OOP.pdf - Sentence 348
349,.,OOP.pdf - Sentence 349
350,.,OOP.pdf - Sentence 350
351,.,OOP.pdf - Sentence 351
352,.,OOP.pdf - Sentence 352
353,.,OOP.pdf - Sentence 353
354,.,OOP.pdf - Sentence 354
355,.,OOP.pdf - Sentence 355
356,.,OOP.pdf - Sentence 356
357,.,OOP.pdf - Sentence 357
358,.,OOP.pdf - Sentence 358
359,.,OOP.pdf - Sentence 359
360,.,OOP.pdf - Sentence 360
361,.,OOP.pdf - Sentence 361
362,.,OOP.pdf - Sentence 362
363,.,OOP.pdf - Sentence 363
364,.,OOP.pdf - Sentence 364
365,.,OOP.pdf - Sentence 365
366,.,OOP.pdf - Sentence 366
367,.,OOP.pdf - Sentence 367
368,.,OOP.pdf - Sentence 368
369,.,OOP.pdf - Sentence 369
370,.,OOP.pdf - Sentence 370
371,.,OOP.pdf - Sentence 371
372,8 2.1.2 Builder .,OOP.pdf - Sentence 372
373,.,OOP.pdf - Sentence 373
374,.,OOP.pdf - Sentence 374
375,.,OOP.pdf - Sentence 375
376,.,OOP.pdf - Sentence 376
377,.,OOP.pdf - Sentence 377
378,.,OOP.pdf - Sentence 378
379,.,OOP.pdf - Sentence 379
380,.,OOP.pdf - Sentence 380
381,.,OOP.pdf - Sentence 381
382,.,OOP.pdf - Sentence 382
383,.,OOP.pdf - Sentence 383
384,.,OOP.pdf - Sentence 384
385,.,OOP.pdf - Sentence 385
386,.,OOP.pdf - Sentence 386
387,.,OOP.pdf - Sentence 387
388,.,OOP.pdf - Sentence 388
389,.,OOP.pdf - Sentence 389
390,.,OOP.pdf - Sentence 390
391,.,OOP.pdf - Sentence 391
392,.,OOP.pdf - Sentence 392
393,.,OOP.pdf - Sentence 393
394,.,OOP.pdf - Sentence 394
395,.,OOP.pdf - Sentence 395
396,.,OOP.pdf - Sentence 396
397,.,OOP.pdf - Sentence 397
398,.,OOP.pdf - Sentence 398
399,.,OOP.pdf - Sentence 399
400,.,OOP.pdf - Sentence 400
401,.,OOP.pdf - Sentence 401
402,.,OOP.pdf - Sentence 402
403,.,OOP.pdf - Sentence 403
404,.,OOP.pdf - Sentence 404
405,.,OOP.pdf - Sentence 405
406,.,OOP.pdf - Sentence 406
407,.,OOP.pdf - Sentence 407
408,9 2.1.3 Factory Method * .,OOP.pdf - Sentence 408
409,.,OOP.pdf - Sentence 409
410,.,OOP.pdf - Sentence 410
411,.,OOP.pdf - Sentence 411
412,.,OOP.pdf - Sentence 412
413,.,OOP.pdf - Sentence 413
414,.,OOP.pdf - Sentence 414
415,.,OOP.pdf - Sentence 415
416,.,OOP.pdf - Sentence 416
417,.,OOP.pdf - Sentence 417
418,.,OOP.pdf - Sentence 418
419,.,OOP.pdf - Sentence 419
420,.,OOP.pdf - Sentence 420
421,.,OOP.pdf - Sentence 421
422,.,OOP.pdf - Sentence 422
423,.,OOP.pdf - Sentence 423
424,.,OOP.pdf - Sentence 424
425,.,OOP.pdf - Sentence 425
426,.,OOP.pdf - Sentence 426
427,.,OOP.pdf - Sentence 427
428,.,OOP.pdf - Sentence 428
429,.,OOP.pdf - Sentence 429
430,.,OOP.pdf - Sentence 430
431,.,OOP.pdf - Sentence 431
432,.,OOP.pdf - Sentence 432
433,.,OOP.pdf - Sentence 433
434,.,OOP.pdf - Sentence 434
435,.,OOP.pdf - Sentence 435
436,.,OOP.pdf - Sentence 436
437,.,OOP.pdf - Sentence 437
438,10 2.1.4 Prototype .,OOP.pdf - Sentence 438
439,.,OOP.pdf - Sentence 439
440,.,OOP.pdf - Sentence 440
441,.,OOP.pdf - Sentence 441
442,.,OOP.pdf - Sentence 442
443,.,OOP.pdf - Sentence 443
444,.,OOP.pdf - Sentence 444
445,.,OOP.pdf - Sentence 445
446,.,OOP.pdf - Sentence 446
447,.,OOP.pdf - Sentence 447
448,.,OOP.pdf - Sentence 448
449,.,OOP.pdf - Sentence 449
450,.,OOP.pdf - Sentence 450
451,.,OOP.pdf - Sentence 451
452,.,OOP.pdf - Sentence 452
453,.,OOP.pdf - Sentence 453
454,.,OOP.pdf - Sentence 454
455,.,OOP.pdf - Sentence 455
456,.,OOP.pdf - Sentence 456
457,.,OOP.pdf - Sentence 457
458,.,OOP.pdf - Sentence 458
459,.,OOP.pdf - Sentence 459
460,.,OOP.pdf - Sentence 460
461,.,OOP.pdf - Sentence 461
462,.,OOP.pdf - Sentence 462
463,.,OOP.pdf - Sentence 463
464,.,OOP.pdf - Sentence 464
465,.,OOP.pdf - Sentence 465
466,.,OOP.pdf - Sentence 466
467,.,OOP.pdf - Sentence 467
468,.,OOP.pdf - Sentence 468
469,.,OOP.pdf - Sentence 469
470,.,OOP.pdf - Sentence 470
471,.,OOP.pdf - Sentence 471
472,.,OOP.pdf - Sentence 472
473,11 2.1.5 Singleton .,OOP.pdf - Sentence 473
474,.,OOP.pdf - Sentence 474
475,.,OOP.pdf - Sentence 475
476,.,OOP.pdf - Sentence 476
477,.,OOP.pdf - Sentence 477
478,.,OOP.pdf - Sentence 478
479,.,OOP.pdf - Sentence 479
480,.,OOP.pdf - Sentence 480
481,.,OOP.pdf - Sentence 481
482,.,OOP.pdf - Sentence 482
483,.,OOP.pdf - Sentence 483
484,.,OOP.pdf - Sentence 484
485,.,OOP.pdf - Sentence 485
486,.,OOP.pdf - Sentence 486
487,.,OOP.pdf - Sentence 487
488,.,OOP.pdf - Sentence 488
489,.,OOP.pdf - Sentence 489
490,.,OOP.pdf - Sentence 490
491,.,OOP.pdf - Sentence 491
492,.,OOP.pdf - Sentence 492
493,.,OOP.pdf - Sentence 493
494,.,OOP.pdf - Sentence 494
495,.,OOP.pdf - Sentence 495
496,.,OOP.pdf - Sentence 496
497,.,OOP.pdf - Sentence 497
498,.,OOP.pdf - Sentence 498
499,.,OOP.pdf - Sentence 499
500,.,OOP.pdf - Sentence 500
501,.,OOP.pdf - Sentence 501
502,.,OOP.pdf - Sentence 502
503,.,OOP.pdf - Sentence 503
504,.,OOP.pdf - Sentence 504
505,.,OOP.pdf - Sentence 505
506,.,OOP.pdf - Sentence 506
507,.,OOP.pdf - Sentence 507
508,12 2.2 Structural Patterns .,OOP.pdf - Sentence 508
509,.,OOP.pdf - Sentence 509
510,.,OOP.pdf - Sentence 510
511,.,OOP.pdf - Sentence 511
512,.,OOP.pdf - Sentence 512
513,.,OOP.pdf - Sentence 513
514,.,OOP.pdf - Sentence 514
515,.,OOP.pdf - Sentence 515
516,.,OOP.pdf - Sentence 516
517,.,OOP.pdf - Sentence 517
518,.,OOP.pdf - Sentence 518
519,.,OOP.pdf - Sentence 519
520,.,OOP.pdf - Sentence 520
521,.,OOP.pdf - Sentence 521
522,.,OOP.pdf - Sentence 522
523,.,OOP.pdf - Sentence 523
524,.,OOP.pdf - Sentence 524
525,.,OOP.pdf - Sentence 525
526,.,OOP.pdf - Sentence 526
527,.,OOP.pdf - Sentence 527
528,.,OOP.pdf - Sentence 528
529,.,OOP.pdf - Sentence 529
530,.,OOP.pdf - Sentence 530
531,.,OOP.pdf - Sentence 531
532,.,OOP.pdf - Sentence 532
533,.,OOP.pdf - Sentence 533
534,.,OOP.pdf - Sentence 534
535,.,OOP.pdf - Sentence 535
536,.,OOP.pdf - Sentence 536
537,.,OOP.pdf - Sentence 537
538,.,OOP.pdf - Sentence 538
539,.,OOP.pdf - Sentence 539
540,.,OOP.pdf - Sentence 540
541,.,OOP.pdf - Sentence 541
542,13 2.2.1 Adapter * .,OOP.pdf - Sentence 542
543,.,OOP.pdf - Sentence 543
544,.,OOP.pdf - Sentence 544
545,.,OOP.pdf - Sentence 545
546,.,OOP.pdf - Sentence 546
547,.,OOP.pdf - Sentence 547
548,.,OOP.pdf - Sentence 548
549,.,OOP.pdf - Sentence 549
550,.,OOP.pdf - Sentence 550
551,.,OOP.pdf - Sentence 551
552,.,OOP.pdf - Sentence 552
553,.,OOP.pdf - Sentence 553
554,.,OOP.pdf - Sentence 554
555,.,OOP.pdf - Sentence 555
556,.,OOP.pdf - Sentence 556
557,.,OOP.pdf - Sentence 557
558,.,OOP.pdf - Sentence 558
559,.,OOP.pdf - Sentence 559
560,.,OOP.pdf - Sentence 560
561,.,OOP.pdf - Sentence 561
562,.,OOP.pdf - Sentence 562
563,.,OOP.pdf - Sentence 563
564,.,OOP.pdf - Sentence 564
565,.,OOP.pdf - Sentence 565
566,.,OOP.pdf - Sentence 566
567,.,OOP.pdf - Sentence 567
568,.,OOP.pdf - Sentence 568
569,.,OOP.pdf - Sentence 569
570,.,OOP.pdf - Sentence 570
571,.,OOP.pdf - Sentence 571
572,.,OOP.pdf - Sentence 572
573,.,OOP.pdf - Sentence 573
574,.,OOP.pdf - Sentence 574
575,.,OOP.pdf - Sentence 575
576,.,OOP.pdf - Sentence 576
577,13 2.2.2 Bridge .,OOP.pdf - Sentence 577
578,.,OOP.pdf - Sentence 578
579,.,OOP.pdf - Sentence 579
580,.,OOP.pdf - Sentence 580
581,.,OOP.pdf - Sentence 581
582,.,OOP.pdf - Sentence 582
583,.,OOP.pdf - Sentence 583
584,.,OOP.pdf - Sentence 584
585,.,OOP.pdf - Sentence 585
586,.,OOP.pdf - Sentence 586
587,.,OOP.pdf - Sentence 587
588,.,OOP.pdf - Sentence 588
589,.,OOP.pdf - Sentence 589
590,.,OOP.pdf - Sentence 590
591,.,OOP.pdf - Sentence 591
592,.,OOP.pdf - Sentence 592
593,.,OOP.pdf - Sentence 593
594,.,OOP.pdf - Sentence 594
595,.,OOP.pdf - Sentence 595
596,.,OOP.pdf - Sentence 596
597,.,OOP.pdf - Sentence 597
598,.,OOP.pdf - Sentence 598
599,.,OOP.pdf - Sentence 599
600,.,OOP.pdf - Sentence 600
601,.,OOP.pdf - Sentence 601
602,.,OOP.pdf - Sentence 602
603,.,OOP.pdf - Sentence 603
604,.,OOP.pdf - Sentence 604
605,.,OOP.pdf - Sentence 605
606,.,OOP.pdf - Sentence 606
607,.,OOP.pdf - Sentence 607
608,.,OOP.pdf - Sentence 608
609,.,OOP.pdf - Sentence 609
610,.,OOP.pdf - Sentence 610
611,.,OOP.pdf - Sentence 611
612,.,OOP.pdf - Sentence 612
613,.,OOP.pdf - Sentence 613
614,14 2.2.3 Composite * .,OOP.pdf - Sentence 614
615,.,OOP.pdf - Sentence 615
616,.,OOP.pdf - Sentence 616
617,.,OOP.pdf - Sentence 617
618,.,OOP.pdf - Sentence 618
619,.,OOP.pdf - Sentence 619
620,.,OOP.pdf - Sentence 620
621,.,OOP.pdf - Sentence 621
622,.,OOP.pdf - Sentence 622
623,.,OOP.pdf - Sentence 623
624,.,OOP.pdf - Sentence 624
625,.,OOP.pdf - Sentence 625
626,.,OOP.pdf - Sentence 626
627,.,OOP.pdf - Sentence 627
628,.,OOP.pdf - Sentence 628
629,.,OOP.pdf - Sentence 629
630,.,OOP.pdf - Sentence 630
631,.,OOP.pdf - Sentence 631
632,.,OOP.pdf - Sentence 632
633,.,OOP.pdf - Sentence 633
634,.,OOP.pdf - Sentence 634
635,.,OOP.pdf - Sentence 635
636,.,OOP.pdf - Sentence 636
637,.,OOP.pdf - Sentence 637
638,.,OOP.pdf - Sentence 638
639,.,OOP.pdf - Sentence 639
640,.,OOP.pdf - Sentence 640
641,.,OOP.pdf - Sentence 641
642,.,OOP.pdf - Sentence 642
643,.,OOP.pdf - Sentence 643
644,.,OOP.pdf - Sentence 644
645,.,OOP.pdf - Sentence 645
646,.,OOP.pdf - Sentence 646
647,15 2.2.4 Decorator * .,OOP.pdf - Sentence 647
648,.,OOP.pdf - Sentence 648
649,.,OOP.pdf - Sentence 649
650,.,OOP.pdf - Sentence 650
651,.,OOP.pdf - Sentence 651
652,.,OOP.pdf - Sentence 652
653,.,OOP.pdf - Sentence 653
654,.,OOP.pdf - Sentence 654
655,.,OOP.pdf - Sentence 655
656,.,OOP.pdf - Sentence 656
657,.,OOP.pdf - Sentence 657
658,.,OOP.pdf - Sentence 658
659,.,OOP.pdf - Sentence 659
660,.,OOP.pdf - Sentence 660
661,.,OOP.pdf - Sentence 661
662,.,OOP.pdf - Sentence 662
663,.,OOP.pdf - Sentence 663
664,.,OOP.pdf - Sentence 664
665,.,OOP.pdf - Sentence 665
666,.,OOP.pdf - Sentence 666
667,.,OOP.pdf - Sentence 667
668,.,OOP.pdf - Sentence 668
669,.,OOP.pdf - Sentence 669
670,.,OOP.pdf - Sentence 670
671,.,OOP.pdf - Sentence 671
672,.,OOP.pdf - Sentence 672
673,.,OOP.pdf - Sentence 673
674,.,OOP.pdf - Sentence 674
675,.,OOP.pdf - Sentence 675
676,.,OOP.pdf - Sentence 676
677,.,OOP.pdf - Sentence 677
678,.,OOP.pdf - Sentence 678
679,.,OOP.pdf - Sentence 679
680,.,OOP.pdf - Sentence 680
681,16 2.2.5 Facade .,OOP.pdf - Sentence 681
682,.,OOP.pdf - Sentence 682
683,.,OOP.pdf - Sentence 683
684,.,OOP.pdf - Sentence 684
685,.,OOP.pdf - Sentence 685
686,.,OOP.pdf - Sentence 686
687,.,OOP.pdf - Sentence 687
688,.,OOP.pdf - Sentence 688
689,.,OOP.pdf - Sentence 689
690,.,OOP.pdf - Sentence 690
691,.,OOP.pdf - Sentence 691
692,.,OOP.pdf - Sentence 692
693,.,OOP.pdf - Sentence 693
694,.,OOP.pdf - Sentence 694
695,.,OOP.pdf - Sentence 695
696,.,OOP.pdf - Sentence 696
697,.,OOP.pdf - Sentence 697
698,.,OOP.pdf - Sentence 698
699,.,OOP.pdf - Sentence 699
700,.,OOP.pdf - Sentence 700
701,.,OOP.pdf - Sentence 701
702,.,OOP.pdf - Sentence 702
703,.,OOP.pdf - Sentence 703
704,.,OOP.pdf - Sentence 704
705,.,OOP.pdf - Sentence 705
706,.,OOP.pdf - Sentence 706
707,.,OOP.pdf - Sentence 707
708,.,OOP.pdf - Sentence 708
709,.,OOP.pdf - Sentence 709
710,.,OOP.pdf - Sentence 710
711,.,OOP.pdf - Sentence 711
712,.,OOP.pdf - Sentence 712
713,.,OOP.pdf - Sentence 713
714,.,OOP.pdf - Sentence 714
715,.,OOP.pdf - Sentence 715
716,.,OOP.pdf - Sentence 716
717,.,OOP.pdf - Sentence 717
718,17 2.2.6 Flyweight .,OOP.pdf - Sentence 718
719,.,OOP.pdf - Sentence 719
720,.,OOP.pdf - Sentence 720
721,.,OOP.pdf - Sentence 721
722,.,OOP.pdf - Sentence 722
723,.,OOP.pdf - Sentence 723
724,.,OOP.pdf - Sentence 724
725,.,OOP.pdf - Sentence 725
726,.,OOP.pdf - Sentence 726
727,.,OOP.pdf - Sentence 727
728,.,OOP.pdf - Sentence 728
729,.,OOP.pdf - Sentence 729
730,.,OOP.pdf - Sentence 730
731,.,OOP.pdf - Sentence 731
732,.,OOP.pdf - Sentence 732
733,.,OOP.pdf - Sentence 733
734,.,OOP.pdf - Sentence 734
735,.,OOP.pdf - Sentence 735
736,.,OOP.pdf - Sentence 736
737,.,OOP.pdf - Sentence 737
738,.,OOP.pdf - Sentence 738
739,.,OOP.pdf - Sentence 739
740,.,OOP.pdf - Sentence 740
741,.,OOP.pdf - Sentence 741
742,.,OOP.pdf - Sentence 742
743,.,OOP.pdf - Sentence 743
744,.,OOP.pdf - Sentence 744
745,.,OOP.pdf - Sentence 745
746,.,OOP.pdf - Sentence 746
747,.,OOP.pdf - Sentence 747
748,.,OOP.pdf - Sentence 748
749,.,OOP.pdf - Sentence 749
750,.,OOP.pdf - Sentence 750
751,.,OOP.pdf - Sentence 751
752,.,OOP.pdf - Sentence 752
753,18 2.2.7 Proxy .,OOP.pdf - Sentence 753
754,.,OOP.pdf - Sentence 754
755,.,OOP.pdf - Sentence 755
756,.,OOP.pdf - Sentence 756
757,.,OOP.pdf - Sentence 757
758,.,OOP.pdf - Sentence 758
759,.,OOP.pdf - Sentence 759
760,.,OOP.pdf - Sentence 760
761,.,OOP.pdf - Sentence 761
762,.,OOP.pdf - Sentence 762
763,.,OOP.pdf - Sentence 763
764,.,OOP.pdf - Sentence 764
765,.,OOP.pdf - Sentence 765
766,.,OOP.pdf - Sentence 766
767,.,OOP.pdf - Sentence 767
768,.,OOP.pdf - Sentence 768
769,.,OOP.pdf - Sentence 769
770,.,OOP.pdf - Sentence 770
771,.,OOP.pdf - Sentence 771
772,.,OOP.pdf - Sentence 772
773,.,OOP.pdf - Sentence 773
774,.,OOP.pdf - Sentence 774
775,.,OOP.pdf - Sentence 775
776,.,OOP.pdf - Sentence 776
777,.,OOP.pdf - Sentence 777
778,.,OOP.pdf - Sentence 778
779,.,OOP.pdf - Sentence 779
780,.,OOP.pdf - Sentence 780
781,.,OOP.pdf - Sentence 781
782,.,OOP.pdf - Sentence 782
783,.,OOP.pdf - Sentence 783
784,.,OOP.pdf - Sentence 784
785,.,OOP.pdf - Sentence 785
786,.,OOP.pdf - Sentence 786
787,.,OOP.pdf - Sentence 787
788,.,OOP.pdf - Sentence 788
789,.,OOP.pdf - Sentence 789
790,19 2.3 Behavioural Patterns .,OOP.pdf - Sentence 790
791,.,OOP.pdf - Sentence 791
792,.,OOP.pdf - Sentence 792
793,.,OOP.pdf - Sentence 793
794,.,OOP.pdf - Sentence 794
795,.,OOP.pdf - Sentence 795
796,.,OOP.pdf - Sentence 796
797,.,OOP.pdf - Sentence 797
798,.,OOP.pdf - Sentence 798
799,.,OOP.pdf - Sentence 799
800,.,OOP.pdf - Sentence 800
801,.,OOP.pdf - Sentence 801
802,.,OOP.pdf - Sentence 802
803,.,OOP.pdf - Sentence 803
804,.,OOP.pdf - Sentence 804
805,.,OOP.pdf - Sentence 805
806,.,OOP.pdf - Sentence 806
807,.,OOP.pdf - Sentence 807
808,.,OOP.pdf - Sentence 808
809,.,OOP.pdf - Sentence 809
810,.,OOP.pdf - Sentence 810
811,.,OOP.pdf - Sentence 811
812,.,OOP.pdf - Sentence 812
813,.,OOP.pdf - Sentence 813
814,.,OOP.pdf - Sentence 814
815,.,OOP.pdf - Sentence 815
816,.,OOP.pdf - Sentence 816
817,.,OOP.pdf - Sentence 817
818,.,OOP.pdf - Sentence 818
819,.,OOP.pdf - Sentence 819
820,.,OOP.pdf - Sentence 820
821,.,OOP.pdf - Sentence 821
822,.,OOP.pdf - Sentence 822
823,20 2.3.1 Chain of Responsibility .,OOP.pdf - Sentence 823
824,.,OOP.pdf - Sentence 824
825,.,OOP.pdf - Sentence 825
826,.,OOP.pdf - Sentence 826
827,.,OOP.pdf - Sentence 827
828,.,OOP.pdf - Sentence 828
829,.,OOP.pdf - Sentence 829
830,.,OOP.pdf - Sentence 830
831,.,OOP.pdf - Sentence 831
832,.,OOP.pdf - Sentence 832
833,.,OOP.pdf - Sentence 833
834,.,OOP.pdf - Sentence 834
835,.,OOP.pdf - Sentence 835
836,.,OOP.pdf - Sentence 836
837,.,OOP.pdf - Sentence 837
838,.,OOP.pdf - Sentence 838
839,.,OOP.pdf - Sentence 839
840,.,OOP.pdf - Sentence 840
841,.,OOP.pdf - Sentence 841
842,.,OOP.pdf - Sentence 842
843,.,OOP.pdf - Sentence 843
844,.,OOP.pdf - Sentence 844
845,.,OOP.pdf - Sentence 845
846,.,OOP.pdf - Sentence 846
847,.,OOP.pdf - Sentence 847
848,.,OOP.pdf - Sentence 848
849,.,OOP.pdf - Sentence 849
850,20 2.3.2 Command .,OOP.pdf - Sentence 850
851,.,OOP.pdf - Sentence 851
852,.,OOP.pdf - Sentence 852
853,.,OOP.pdf - Sentence 853
854,.,OOP.pdf - Sentence 854
855,.,OOP.pdf - Sentence 855
856,.,OOP.pdf - Sentence 856
857,.,OOP.pdf - Sentence 857
858,.,OOP.pdf - Sentence 858
859,.,OOP.pdf - Sentence 859
860,.,OOP.pdf - Sentence 860
861,.,OOP.pdf - Sentence 861
862,.,OOP.pdf - Sentence 862
863,.,OOP.pdf - Sentence 863
864,.,OOP.pdf - Sentence 864
865,.,OOP.pdf - Sentence 865
866,.,OOP.pdf - Sentence 866
867,.,OOP.pdf - Sentence 867
868,.,OOP.pdf - Sentence 868
869,.,OOP.pdf - Sentence 869
870,.,OOP.pdf - Sentence 870
871,.,OOP.pdf - Sentence 871
872,.,OOP.pdf - Sentence 872
873,.,OOP.pdf - Sentence 873
874,.,OOP.pdf - Sentence 874
875,.,OOP.pdf - Sentence 875
876,.,OOP.pdf - Sentence 876
877,.,OOP.pdf - Sentence 877
878,.,OOP.pdf - Sentence 878
879,.,OOP.pdf - Sentence 879
880,.,OOP.pdf - Sentence 880
881,.,OOP.pdf - Sentence 881
882,.,OOP.pdf - Sentence 882
883,.,OOP.pdf - Sentence 883
884,.,OOP.pdf - Sentence 884
885,21 2.3.3 Interpreter .,OOP.pdf - Sentence 885
886,.,OOP.pdf - Sentence 886
887,.,OOP.pdf - Sentence 887
888,.,OOP.pdf - Sentence 888
889,.,OOP.pdf - Sentence 889
890,.,OOP.pdf - Sentence 890
891,.,OOP.pdf - Sentence 891
892,.,OOP.pdf - Sentence 892
893,.,OOP.pdf - Sentence 893
894,.,OOP.pdf - Sentence 894
895,.,OOP.pdf - Sentence 895
896,.,OOP.pdf - Sentence 896
897,.,OOP.pdf - Sentence 897
898,.,OOP.pdf - Sentence 898
899,.,OOP.pdf - Sentence 899
900,.,OOP.pdf - Sentence 900
901,.,OOP.pdf - Sentence 901
902,.,OOP.pdf - Sentence 902
903,.,OOP.pdf - Sentence 903
904,.,OOP.pdf - Sentence 904
905,.,OOP.pdf - Sentence 905
906,.,OOP.pdf - Sentence 906
907,.,OOP.pdf - Sentence 907
908,.,OOP.pdf - Sentence 908
909,.,OOP.pdf - Sentence 909
910,.,OOP.pdf - Sentence 910
911,.,OOP.pdf - Sentence 911
912,.,OOP.pdf - Sentence 912
913,.,OOP.pdf - Sentence 913
914,.,OOP.pdf - Sentence 914
915,.,OOP.pdf - Sentence 915
916,.,OOP.pdf - Sentence 916
917,.,OOP.pdf - Sentence 917
918,.,OOP.pdf - Sentence 918
919,22 2.3.4 Iterator .,OOP.pdf - Sentence 919
920,.,OOP.pdf - Sentence 920
921,.,OOP.pdf - Sentence 921
922,.,OOP.pdf - Sentence 922
923,.,OOP.pdf - Sentence 923
924,.,OOP.pdf - Sentence 924
925,.,OOP.pdf - Sentence 925
926,.,OOP.pdf - Sentence 926
927,.,OOP.pdf - Sentence 927
928,.,OOP.pdf - Sentence 928
929,.,OOP.pdf - Sentence 929
930,.,OOP.pdf - Sentence 930
931,.,OOP.pdf - Sentence 931
932,.,OOP.pdf - Sentence 932
933,.,OOP.pdf - Sentence 933
934,.,OOP.pdf - Sentence 934
935,.,OOP.pdf - Sentence 935
936,.,OOP.pdf - Sentence 936
937,.,OOP.pdf - Sentence 937
938,.,OOP.pdf - Sentence 938
939,.,OOP.pdf - Sentence 939
940,.,OOP.pdf - Sentence 940
941,.,OOP.pdf - Sentence 941
942,.,OOP.pdf - Sentence 942
943,.,OOP.pdf - Sentence 943
944,.,OOP.pdf - Sentence 944
945,.,OOP.pdf - Sentence 945
946,.,OOP.pdf - Sentence 946
947,.,OOP.pdf - Sentence 947
948,.,OOP.pdf - Sentence 948
949,.,OOP.pdf - Sentence 949
950,.,OOP.pdf - Sentence 950
951,.,OOP.pdf - Sentence 951
952,.,OOP.pdf - Sentence 952
953,.,OOP.pdf - Sentence 953
954,.,OOP.pdf - Sentence 954
955,23 2.3.5 Mediator .,OOP.pdf - Sentence 955
956,.,OOP.pdf - Sentence 956
957,.,OOP.pdf - Sentence 957
958,.,OOP.pdf - Sentence 958
959,.,OOP.pdf - Sentence 959
960,.,OOP.pdf - Sentence 960
961,.,OOP.pdf - Sentence 961
962,.,OOP.pdf - Sentence 962
963,.,OOP.pdf - Sentence 963
964,.,OOP.pdf - Sentence 964
965,.,OOP.pdf - Sentence 965
966,.,OOP.pdf - Sentence 966
967,.,OOP.pdf - Sentence 967
968,.,OOP.pdf - Sentence 968
969,.,OOP.pdf - Sentence 969
970,.,OOP.pdf - Sentence 970
971,.,OOP.pdf - Sentence 971
972,.,OOP.pdf - Sentence 972
973,.,OOP.pdf - Sentence 973
974,.,OOP.pdf - Sentence 974
975,.,OOP.pdf - Sentence 975
976,.,OOP.pdf - Sentence 976
977,.,OOP.pdf - Sentence 977
978,.,OOP.pdf - Sentence 978
979,.,OOP.pdf - Sentence 979
980,.,OOP.pdf - Sentence 980
981,.,OOP.pdf - Sentence 981
982,.,OOP.pdf - Sentence 982
983,.,OOP.pdf - Sentence 983
984,.,OOP.pdf - Sentence 984
985,.,OOP.pdf - Sentence 985
986,.,OOP.pdf - Sentence 986
987,.,OOP.pdf - Sentence 987
988,.,OOP.pdf - Sentence 988
989,.,OOP.pdf - Sentence 989
990,24 2.3.6 Memento .,OOP.pdf - Sentence 990
991,.,OOP.pdf - Sentence 991
992,.,OOP.pdf - Sentence 992
993,.,OOP.pdf - Sentence 993
994,.,OOP.pdf - Sentence 994
995,.,OOP.pdf - Sentence 995
996,.,OOP.pdf - Sentence 996
997,.,OOP.pdf - Sentence 997
998,.,OOP.pdf - Sentence 998
999,.,OOP.pdf - Sentence 999
1000,.,OOP.pdf - Sentence 1000
1001,.,OOP.pdf - Sentence 1001
1002,.,OOP.pdf - Sentence 1002
1003,.,OOP.pdf - Sentence 1003
1004,.,OOP.pdf - Sentence 1004
1005,.,OOP.pdf - Sentence 1005
1006,.,OOP.pdf - Sentence 1006
1007,.,OOP.pdf - Sentence 1007
1008,.,OOP.pdf - Sentence 1008
1009,.,OOP.pdf - Sentence 1009
1010,.,OOP.pdf - Sentence 1010
1011,.,OOP.pdf - Sentence 1011
1012,.,OOP.pdf - Sentence 1012
1013,.,OOP.pdf - Sentence 1013
1014,.,OOP.pdf - Sentence 1014
1015,.,OOP.pdf - Sentence 1015
1016,.,OOP.pdf - Sentence 1016
1017,.,OOP.pdf - Sentence 1017
1018,.,OOP.pdf - Sentence 1018
1019,.,OOP.pdf - Sentence 1019
1020,.,OOP.pdf - Sentence 1020
1021,.,OOP.pdf - Sentence 1021
1022,.,OOP.pdf - Sentence 1022
1023,.,OOP.pdf - Sentence 1023
1024,.,OOP.pdf - Sentence 1024
1025,25 2.3.7 Observer * .,OOP.pdf - Sentence 1025
1026,.,OOP.pdf - Sentence 1026
1027,.,OOP.pdf - Sentence 1027
1028,.,OOP.pdf - Sentence 1028
1029,.,OOP.pdf - Sentence 1029
1030,.,OOP.pdf - Sentence 1030
1031,.,OOP.pdf - Sentence 1031
1032,.,OOP.pdf - Sentence 1032
1033,.,OOP.pdf - Sentence 1033
1034,.,OOP.pdf - Sentence 1034
1035,.,OOP.pdf - Sentence 1035
1036,.,OOP.pdf - Sentence 1036
1037,.,OOP.pdf - Sentence 1037
1038,.,OOP.pdf - Sentence 1038
1039,.,OOP.pdf - Sentence 1039
1040,.,OOP.pdf - Sentence 1040
1041,.,OOP.pdf - Sentence 1041
1042,.,OOP.pdf - Sentence 1042
1043,.,OOP.pdf - Sentence 1043
1044,.,OOP.pdf - Sentence 1044
1045,.,OOP.pdf - Sentence 1045
1046,.,OOP.pdf - Sentence 1046
1047,.,OOP.pdf - Sentence 1047
1048,.,OOP.pdf - Sentence 1048
1049,.,OOP.pdf - Sentence 1049
1050,.,OOP.pdf - Sentence 1050
1051,.,OOP.pdf - Sentence 1051
1052,.,OOP.pdf - Sentence 1052
1053,.,OOP.pdf - Sentence 1053
1054,.,OOP.pdf - Sentence 1054
1055,.,OOP.pdf - Sentence 1055
1056,.,OOP.pdf - Sentence 1056
1057,.,OOP.pdf - Sentence 1057
1058,.,OOP.pdf - Sentence 1058
1059,26 2.3.8 State .,OOP.pdf - Sentence 1059
1060,.,OOP.pdf - Sentence 1060
1061,.,OOP.pdf - Sentence 1061
1062,.,OOP.pdf - Sentence 1062
1063,.,OOP.pdf - Sentence 1063
1064,.,OOP.pdf - Sentence 1064
1065,.,OOP.pdf - Sentence 1065
1066,.,OOP.pdf - Sentence 1066
1067,.,OOP.pdf - Sentence 1067
1068,.,OOP.pdf - Sentence 1068
1069,.,OOP.pdf - Sentence 1069
1070,.,OOP.pdf - Sentence 1070
1071,.,OOP.pdf - Sentence 1071
1072,.,OOP.pdf - Sentence 1072
1073,.,OOP.pdf - Sentence 1073
1074,.,OOP.pdf - Sentence 1074
1075,.,OOP.pdf - Sentence 1075
1076,.,OOP.pdf - Sentence 1076
1077,.,OOP.pdf - Sentence 1077
1078,.,OOP.pdf - Sentence 1078
1079,.,OOP.pdf - Sentence 1079
1080,.,OOP.pdf - Sentence 1080
1081,.,OOP.pdf - Sentence 1081
1082,.,OOP.pdf - Sentence 1082
1083,.,OOP.pdf - Sentence 1083
1084,.,OOP.pdf - Sentence 1084
1085,.,OOP.pdf - Sentence 1085
1086,.,OOP.pdf - Sentence 1086
1087,.,OOP.pdf - Sentence 1087
1088,.,OOP.pdf - Sentence 1088
1089,.,OOP.pdf - Sentence 1089
1090,.,OOP.pdf - Sentence 1090
1091,.,OOP.pdf - Sentence 1091
1092,.,OOP.pdf - Sentence 1092
1093,.,OOP.pdf - Sentence 1093
1094,.,OOP.pdf - Sentence 1094
1095,.,OOP.pdf - Sentence 1095
1096,.,OOP.pdf - Sentence 1096
1097,27 2.3.9 Strategy * .,OOP.pdf - Sentence 1097
1098,.,OOP.pdf - Sentence 1098
1099,.,OOP.pdf - Sentence 1099
1100,.,OOP.pdf - Sentence 1100
1101,.,OOP.pdf - Sentence 1101
1102,.,OOP.pdf - Sentence 1102
1103,.,OOP.pdf - Sentence 1103
1104,.,OOP.pdf - Sentence 1104
1105,.,OOP.pdf - Sentence 1105
1106,.,OOP.pdf - Sentence 1106
1107,.,OOP.pdf - Sentence 1107
1108,.,OOP.pdf - Sentence 1108
1109,.,OOP.pdf - Sentence 1109
1110,.,OOP.pdf - Sentence 1110
1111,.,OOP.pdf - Sentence 1111
1112,.,OOP.pdf - Sentence 1112
1113,.,OOP.pdf - Sentence 1113
1114,.,OOP.pdf - Sentence 1114
1115,.,OOP.pdf - Sentence 1115
1116,.,OOP.pdf - Sentence 1116
1117,.,OOP.pdf - Sentence 1117
1118,.,OOP.pdf - Sentence 1118
1119,.,OOP.pdf - Sentence 1119
1120,.,OOP.pdf - Sentence 1120
1121,.,OOP.pdf - Sentence 1121
1122,.,OOP.pdf - Sentence 1122
1123,.,OOP.pdf - Sentence 1123
1124,.,OOP.pdf - Sentence 1124
1125,.,OOP.pdf - Sentence 1125
1126,.,OOP.pdf - Sentence 1126
1127,.,OOP.pdf - Sentence 1127
1128,.,OOP.pdf - Sentence 1128
1129,.,OOP.pdf - Sentence 1129
1130,.,OOP.pdf - Sentence 1130
1131,.,OOP.pdf - Sentence 1131
1132,28 2.3.10 Template Method * .,OOP.pdf - Sentence 1132
1133,.,OOP.pdf - Sentence 1133
1134,.,OOP.pdf - Sentence 1134
1135,.,OOP.pdf - Sentence 1135
1136,.,OOP.pdf - Sentence 1136
1137,.,OOP.pdf - Sentence 1137
1138,.,OOP.pdf - Sentence 1138
1139,.,OOP.pdf - Sentence 1139
1140,.,OOP.pdf - Sentence 1140
1141,.,OOP.pdf - Sentence 1141
1142,.,OOP.pdf - Sentence 1142
1143,.,OOP.pdf - Sentence 1143
1144,.,OOP.pdf - Sentence 1144
1145,.,OOP.pdf - Sentence 1145
1146,.,OOP.pdf - Sentence 1146
1147,.,OOP.pdf - Sentence 1147
1148,.,OOP.pdf - Sentence 1148
1149,.,OOP.pdf - Sentence 1149
1150,.,OOP.pdf - Sentence 1150
1151,.,OOP.pdf - Sentence 1151
1152,.,OOP.pdf - Sentence 1152
1153,.,OOP.pdf - Sentence 1153
1154,.,OOP.pdf - Sentence 1154
1155,.,OOP.pdf - Sentence 1155
1156,.,OOP.pdf - Sentence 1156
1157,.,OOP.pdf - Sentence 1157
1158,.,OOP.pdf - Sentence 1158
1159,.,OOP.pdf - Sentence 1159
1160,.,OOP.pdf - Sentence 1160
1161,29 2.3.11 Visitor .,OOP.pdf - Sentence 1161
1162,.,OOP.pdf - Sentence 1162
1163,.,OOP.pdf - Sentence 1163
1164,.,OOP.pdf - Sentence 1164
1165,.,OOP.pdf - Sentence 1165
1166,.,OOP.pdf - Sentence 1166
1167,.,OOP.pdf - Sentence 1167
1168,.,OOP.pdf - Sentence 1168
1169,.,OOP.pdf - Sentence 1169
1170,.,OOP.pdf - Sentence 1170
1171,.,OOP.pdf - Sentence 1171
1172,.,OOP.pdf - Sentence 1172
1173,.,OOP.pdf - Sentence 1173
1174,.,OOP.pdf - Sentence 1174
1175,.,OOP.pdf - Sentence 1175
1176,.,OOP.pdf - Sentence 1176
1177,.,OOP.pdf - Sentence 1177
1178,.,OOP.pdf - Sentence 1178
1179,.,OOP.pdf - Sentence 1179
1180,.,OOP.pdf - Sentence 1180
1181,.,OOP.pdf - Sentence 1181
1182,.,OOP.pdf - Sentence 1182
1183,.,OOP.pdf - Sentence 1183
1184,.,OOP.pdf - Sentence 1184
1185,.,OOP.pdf - Sentence 1185
1186,.,OOP.pdf - Sentence 1186
1187,.,OOP.pdf - Sentence 1187
1188,.,OOP.pdf - Sentence 1188
1189,.,OOP.pdf - Sentence 1189
1190,.,OOP.pdf - Sentence 1190
1191,.,OOP.pdf - Sentence 1191
1192,.,OOP.pdf - Sentence 1192
1193,.,OOP.pdf - Sentence 1193
1194,.,OOP.pdf - Sentence 1194
1195,.,OOP.pdf - Sentence 1195
1196,.,OOP.pdf - Sentence 1196
1197,.,OOP.pdf - Sentence 1197
1198,"30 11 Object-Oriented Design 1.1 Classes, Objects and Interfaces Object-oriented programs are made up of objects .",OOP.pdf - Sentence 1198
1199,An object packages both data and the procedures that operate on that data.,OOP.pdf - Sentence 1199
1200,The procedures are typically called methods orop- erations .,OOP.pdf - Sentence 1200
1201,An object performs an operation when it receives a request (or message) from a client.,OOP.pdf - Sentence 1201
1202,Requests are the only way to get an object to execute an operation.,OOP.pdf - Sentence 1202
1203,Operations are the only way to change an object's internal data.,OOP.pdf - Sentence 1203
1204,"Because of these restrictions, the object's internal state is said to be encapsulated ; it cannot be accessed directly, and its representation is invisible from outside the object.",OOP.pdf - Sentence 1204
1205,"Every operation declared by an object species the operation's name, the objects it takes as parameters, and the operation's return value.",OOP.pdf - Sentence 1205
1206,This is known as the operation's signature .,OOP.pdf - Sentence 1206
1207,The set of all signatures dened by an object's operations is called the interface to the object.,OOP.pdf - Sentence 1207
1208,An object's interface characterizes the complete set of requests that can be sent to the object.,OOP.pdf - Sentence 1208
1209,Any request that matches a signature in the object's interface may be sent to the object.,OOP.pdf - Sentence 1209
1210,Atype is a name used to denote a particular interface.,OOP.pdf - Sentence 1210
1211,"An object may have many types, and widely dierent objects can share a type.",OOP.pdf - Sentence 1211
1212,The class denes the object's internal state and the implementation of its operations.,OOP.pdf - Sentence 1212
1213,"In contrast, an object's type only refers to its interface | the set of requests to which it can respond.",OOP.pdf - Sentence 1213
1214,"Part of an object's interface may be characterized by one type, and other parts by other types.",OOP.pdf - Sentence 1214
1215,Two objects of the same type need only share parts of their interfaces.,OOP.pdf - Sentence 1215
1216,Interfaces can contain other interfaces as subsets.,OOP.pdf - Sentence 1216
1217,We say that a type is a subtype of another if its interface contains the interface of its supertype.,OOP.pdf - Sentence 1217
1218,Often we speak of a subtype inheriting the interface of its supertype.,OOP.pdf - Sentence 1218
1219,Objects are created by instantiating a class .,OOP.pdf - Sentence 1219
1220,The object is said to be an instance of the class.,OOP.pdf - Sentence 1220
1221,The process of instantiating a class allocates storage for the object's internal data (made up of instance variables) and associates the operations with these data.,OOP.pdf - Sentence 1221
1222,Many similar instances of an object can be created by instantiating a class.,OOP.pdf - Sentence 1222
1223,A useful analogy is as follows: A blueprint for a house design is like a class description.,OOP.pdf - Sentence 1223
1224,All the houses built from that blueprint are objects of that class.,OOP.pdf - Sentence 1224
1225,A given house is an instance.,OOP.pdf - Sentence 1225
1226,"1.2 Polymorphism The run-time association of a request to an object and one of its operations is known as dynamic binding , which means that issuing a request doesn't commit you to a particular implementation until run-time.",OOP.pdf - Sentence 1226
1227,"Consequently, you can write programs that expect an object with a particular interface, knowing that any object that has the correct interface will accept the request.",OOP.pdf - Sentence 1227
1228,"Moreover, dynamic binding lets you substitute objects that have identical interfaces for each other at run-time.",OOP.pdf - Sentence 1228
1229,"This substitutability is known as polymorphism , and it's a key concept in object-oriented systems.",OOP.pdf - Sentence 1229
1230,It lets a client object make few assumptions about other objects beyond supporting a particular interface.,OOP.pdf - Sentence 1230
1231,"Polymorphism simplies the denitions of clients, decouples objects from each other, and lets them vary their relationships to each other at run-time.",OOP.pdf - Sentence 1231
1232,21.3 Inheritence New classes can be dened in terms of existing classes using class inheritance .,OOP.pdf - Sentence 1232
1233,Class in- heritance is basically just a mechanism for extending an application's functionality by reusing functionality in parent classes.,OOP.pdf - Sentence 1233
1234,"When a subclass inherits from a parent class, it includes the def- initions of all the data and operations that the parent class denes.",OOP.pdf - Sentence 1234
1235,"Objects that are instances of the subclass will contain all data dened by the subclass and its parent classes, and they'll be able to perform all operations dened by this subclass and its parents.",OOP.pdf - Sentence 1235
1236,Inheritance's ability to dene families of objects with identical interfaces (usually by inheriting from an abstract class) is what allows polymorphism to work.,OOP.pdf - Sentence 1236
1237,Implementation dependencies can cause problems when you're trying to reuse a subclass.,OOP.pdf - Sentence 1237
1238,"Should any aspect of the inherited implementation not be appropriate for new problem do- mains, the parent class must be rewritten or replaced by something more appropriate.",OOP.pdf - Sentence 1238
1239,This dependency limits exibility and ultimately reusability.,OOP.pdf - Sentence 1239
1240,"One cure for this is to inherit only from abstract classes, since they usually provide little or no implementation.",OOP.pdf - Sentence 1240
1241,Anabstract class is one whose main purpose is to dene a common interface for its subclasses.,OOP.pdf - Sentence 1241
1242,An abstract class will defer some or all of its implementation to operations dened in subclasses; hence an abstract class cannot be instantiated.,OOP.pdf - Sentence 1242
1243,The operations that an abstract class declares but doesn't implement are called abstract operations.,OOP.pdf - Sentence 1243
1244,Classes that aren't abstract are called concrete classes .,OOP.pdf - Sentence 1244
1245,Subclasses can rene and redene behaviors of their parent classes.,OOP.pdf - Sentence 1245
1246,"More specically, a class may override an operation dened by its parent class.",OOP.pdf - Sentence 1246
1247,Overriding gives subclasses a chance to handle requests instead of their parent classes.,OOP.pdf - Sentence 1247
1248,"Class inheritance lets you dene classes simply by extending other classes, making it easy to dene families of objects having related functionality.",OOP.pdf - Sentence 1248
1249,"In contrast to class inheritance, interface inheritance or subtyping describes when an object can be used in place of another.",OOP.pdf - Sentence 1249
1250,Amixin class is a class that's intended to provide an optional interface or methods to other classes without having to be the parent class of those other classes.,OOP.pdf - Sentence 1250
1251,It's similar to an abstract class in that it's not intended to be instantiated.,OOP.pdf - Sentence 1251
1252,Mixin classes require multiple inheritance.,OOP.pdf - Sentence 1252
1253,"1.4 Interfaces Program to an interface, not an implementation This principle of object-oriented design has two main benets: 1.",OOP.pdf - Sentence 1253
1254,"Clients remain unaware of the specic types of objects they use, as long as the objects adhere to the interface that clients expect.",OOP.pdf - Sentence 1254
1255,2.,OOP.pdf - Sentence 1255
1256,Clients remain unaware of the classes that implement these objects.,OOP.pdf - Sentence 1256
1257,Clients only know about the abstract classes dening the interface.,OOP.pdf - Sentence 1257
1258,This greatly reduces implementation dependencies between subsystems.,OOP.pdf - Sentence 1258
1259,Don't declare variables to be instances of particular concrete classes.,OOP.pdf - Sentence 1259
1260,"Instead, commit only to an interface dened by an abstract class.",OOP.pdf - Sentence 1260
1261,"Though you will need to instantiate concrete classes in order to specify a particular implementation somewhere in your system { the creational patterns ensure that your system is written in terms of interfaces, not implementations.",OOP.pdf - Sentence 1261
1262,31.5 Composition Favor object composition over class inheritance.,OOP.pdf - Sentence 1262
1263,The two most common techniques for reusing functionality in object-oriented systems are class inheritance and object composition.,OOP.pdf - Sentence 1263
1264,Reuse by subclassing is often referred to as white-box reuse .,OOP.pdf - Sentence 1264
1265,"The term \white-box"" refers to visibility: With inheritance, the internals of parent classes are often visible to subclasses.",OOP.pdf - Sentence 1265
1266,Object composition is an alternative to class inheritance.,OOP.pdf - Sentence 1266
1267,"Here, new functionality is obtained by assembling or composing objects to get more complex functionality.",OOP.pdf - Sentence 1267
1268,Object composition requires that the objects being composed have well-dened interfaces.,OOP.pdf - Sentence 1268
1269,"This style of reuse is called black-box reuse , because no internal details of objects are visible.",OOP.pdf - Sentence 1269
1270,"Objects appear only as \black boxes."" Because objects are accessed solely through their interfaces, we don't break encapsulation.",OOP.pdf - Sentence 1270
1271,Any object can be replaced at run-time by another as long as it has the same type.,OOP.pdf - Sentence 1271
1272,"Moreover, because an object's implementation will be written in terms of object interfaces, there are substantially fewer implementation dependencies.",OOP.pdf - Sentence 1272
1273,"Additionally, favoring object composition over class inheritance helps you keep each class en- capsulated and focused on one task.",OOP.pdf - Sentence 1273
1274,Your classes and class hierarchies will remain small and will be less likely to grow into unmanageable monsters.,OOP.pdf - Sentence 1274
1275,"On the other hand, a design based on object composition will have more objects (if fewer classes), and the system's behavior will depend on their inter relationships instead of being dened in one class.",OOP.pdf - Sentence 1275
1276,1.6 Delegation Delegation is a way of making composition as powerful for reuse as inheritance.,OOP.pdf - Sentence 1276
1277,"In delegation, two objects are involved in handling a request: a receiving object delegates operations to its delegate.",OOP.pdf - Sentence 1277
1278,This is analogous to subclasses deferring requests to parent classes.,OOP.pdf - Sentence 1278
1279,Delegation is an extreme example of object composition.,OOP.pdf - Sentence 1279
1280,It shows that you can always replace inheritance with object composition as a mechanism for code reuse.,OOP.pdf - Sentence 1280
1281,"For example, instead of making class Window a subclass of Rectangle (because windows happen to be rectangular), the Window class might reuse the behavior of Rectangle by keeping a Rectangle instance variable and delegating Rectangle-specic behavior to it.",OOP.pdf - Sentence 1281
1282,"In other words, instead of a Window being a Rectangle, it would have a Rectangle and may call the Area method.",OOP.pdf - Sentence 1282
1283,The main advantage of delegation is that it makes it easy to compose behaviors at run-time and to change the way they're composed.,OOP.pdf - Sentence 1283
1284,"Our window can become circular at run-time simply by replacing its Rectangle instance with a Circle instance, assuming Rectangle and Circle have the same type.",OOP.pdf - Sentence 1284
1285,"Delegation has a disadvantage it shares with other techniques that make software more exible through object composition: Dynamic, highly parameterized software is harder to understand than more static software.There are also run-time ineciencies, but the human ineciencies are more important in the long run.",OOP.pdf - Sentence 1285
1286,Delegation is a good design choice only when it simplies more than it complicates.,OOP.pdf - Sentence 1286
1287,41.7 Parameterized Types Parameterized types give us a third way (in addition to class inheritance and object compo- sition) to compose behavior in object-oriented systems.,OOP.pdf - Sentence 1287
1288,This technique lets you dene a type without specifying all the other types it uses.,OOP.pdf - Sentence 1288
1289,The unspecied types are supplied as parame- ters at the point of use.,OOP.pdf - Sentence 1289
1290,"For example, a List class is parameterized by the type of elements it contains.",OOP.pdf - Sentence 1290
1291,"1.8 Run-Time and Compile-Time Structures Object composition lets you change the behavior being composed at run-time, but it also re- quires indirection and can be less ecient.",OOP.pdf - Sentence 1291
1292,Inheritance lets you provide default implementations for operations and lets subclasses override them.,OOP.pdf - Sentence 1292
1293,Parameterized types let you change the types that a class can use.,OOP.pdf - Sentence 1293
1294,But neither inheritance nor parameterized types can change at run-time.,OOP.pdf - Sentence 1294
1295,Many design patterns (in particular those that have object scope) capture the distinction be- tween compile-time and run-time structures explicitly.,OOP.pdf - Sentence 1295
1296,Composite and Decorator patterns are especially useful for building complex run-time structures.,OOP.pdf - Sentence 1296
1297,Observer involves run-time struc- tures that are often hard to understand unless you know the pattern.,OOP.pdf - Sentence 1297
1298,Chain of Responsibility also results in communication patterns that inheritance doesn't reveal.,OOP.pdf - Sentence 1298
1299,"In general, the run-time structures aren't clear from the code until you understand the patterns.",OOP.pdf - Sentence 1299
1300,"1.9 SOLID Principles Single-responsibility principle { A class should only have a single responsibility, that is, only changes to one part of the software's specication should be able to aect the specication of the class.",OOP.pdf - Sentence 1300
1301,"Open{closed principle { Software entities should be open for extension, but closed for modication.",OOP.pdf - Sentence 1301
1302,Liskov substitution principle { Objects in a program should be replaceable with instances of their subtypes without altering the correctness of that program.,OOP.pdf - Sentence 1302
1303,Interface segregation principle { Many client-specic interfaces are better than one general-purpose interface.,OOP.pdf - Sentence 1303
1304,"Dependency inversion principle { One should depend upon abstractions, not concre- tions.",OOP.pdf - Sentence 1304
1305,52 Design Patterns We classify design patterns by two criteria.,OOP.pdf - Sentence 1305
1306,"The rst criterion, called purpose , reects what a pattern does.",OOP.pdf - Sentence 1306
1307,"Patterns can have either creational ,structural , orbehavioral purpose.",OOP.pdf - Sentence 1307
1308,Creational patterns concern the process of object creation.,OOP.pdf - Sentence 1308
1309,Structural patterns deal with the composition of classes or objects.,OOP.pdf - Sentence 1309
1310,Behavioral patterns characterize the ways in which classes or objects interact and distribute responsibility.,OOP.pdf - Sentence 1310
1311,"The second criterion, called scope , species whether the pattern applies primarily to classes or to objects.",OOP.pdf - Sentence 1311
1312,Class patterns deal with relationships between classes and their subclasses.,OOP.pdf - Sentence 1312
1313,"These relationships are established through inheritance, so they are static | xed at compile-time.",OOP.pdf - Sentence 1313
1314,"Object patterns deal with object relationships, which can be changed at run-time and are more dynamic.",OOP.pdf - Sentence 1314
1315,Almost all patterns use inheritance to some extent.,OOP.pdf - Sentence 1315
1316,"So the only patterns labeled \class patterns"" are those that focus on class relationships.",OOP.pdf - Sentence 1316
1317,Note that most patterns are in the Object scope.,OOP.pdf - Sentence 1317
1318,"Creational class patterns defer some part of object creation to subclasses, while Creational object patterns defer it to another object.",OOP.pdf - Sentence 1318
1319,"The Structural class patterns use inheritance to compose classes, while the Structural object patterns describe ways to assemble objects.",OOP.pdf - Sentence 1319
1320,"The Behavioral class patterns use inheritance to describe algorithms and ow of control, whereas the Behavioral object patterns describe how a group of objects cooperate to perform a task that no single object can carry out alone Each design pattern lets some aspect of a system's structure vary independently of other aspects, thereby making a system more robust to a particular kind of change.",OOP.pdf - Sentence 1320
1321,"1.Creating an object by specifying a class explicitly { Avoid with: Abstract Factory, Factory Method, Prototype.",OOP.pdf - Sentence 1321
1322,"2.Dependence on specic operations { Avoid with: Chain of Responsibility, Command.",OOP.pdf - Sentence 1322
1323,"3.Dependence on hardware and software platform { Avoid with: Abstract Factory, Bridge.",OOP.pdf - Sentence 1323
1324,"4.Dependence on object representations or implementations { Avoid with: Abstract Factory, Bridge, Memento, Proxy.",OOP.pdf - Sentence 1324
1325,"5.Algorithmic dependencies { Avoid with: Builder, Iterator, Strategy, Template Method , Visitor.",OOP.pdf - Sentence 1325
1326,"6.Tight coupling { Avoid with: Abstract Factory, Bridge, Chain of Responsibility, Command, Facade, Me- diator, Observer.",OOP.pdf - Sentence 1326
1327,"7.Extending functionality by subclassing { Avoid with: Bridge, Chain of Responsibility, Composite, Decorator, Observer, Strategy.",OOP.pdf - Sentence 1327
1328,"8.Inability to alter classes conveniently { Avoid with: Adapter, Decorator, Visitor.",OOP.pdf - Sentence 1328
1329,672.1 Creational Patterns 2.1.1 Abstract Factory * Provide an interface for creating families of related or dependent objects without specifying their concrete classes.,OOP.pdf - Sentence 1329
1330,"Applicability Use the Abstract Factory pattern when a system should be independent of how its products are created, composed, and repre- sented.",OOP.pdf - Sentence 1330
1331,a system should be congured with one of multiple families of products.,OOP.pdf - Sentence 1331
1332,"a family of related product objects is designed to be used together, and you need to enforce this constraint.",OOP.pdf - Sentence 1332
1333,"you want to provide a class library of products, and you want to reveal just their interfaces, not their implementations.",OOP.pdf - Sentence 1333
1334,Consequences The Abstract Factory pattern has the following benets and liabilities: It isolates concrete classes.,OOP.pdf - Sentence 1334
1335,It makes exchanging product families easy.,OOP.pdf - Sentence 1335
1336,It promotes consistency among products.,OOP.pdf - Sentence 1336
1337,Supporting new kinds of products is dicult.,OOP.pdf - Sentence 1337
1338,82.1.2 Builder Separate the construction of a complex object from its representation so that the same con- struction process can create dierent representations.,OOP.pdf - Sentence 1338
1339,Applicability Use the Builder pattern when the algorithm for creating a complex object should be independent of the parts that make up the object and how they're assembled.,OOP.pdf - Sentence 1339
1340,the construction process must allow dierent representations for the object that's con- structed.,OOP.pdf - Sentence 1340
1341,Consequences It lets you vary a product's internal representation.,OOP.pdf - Sentence 1341
1342,It isolates code for construction and representation.,OOP.pdf - Sentence 1342
1343,It gives you ner control over the construction process.,OOP.pdf - Sentence 1343
1344,"92.1.3 Factory Method * Dene an interface for creating an object, but let subclasses decide which class to instantiate.",OOP.pdf - Sentence 1344
1345,Factory Method lets a class defer instantiation to subclasses.,OOP.pdf - Sentence 1345
1346,Applicability Use the Factory Method pattern when a class can't anticipate the class of objects it must create.,OOP.pdf - Sentence 1346
1347,a class wants its subclasses to specify the objects it creates.,OOP.pdf - Sentence 1347
1348,"classes delegate responsibility to one of several helper subclasses, and you want to localize the knowledge of which helper subclass is the delegate.",OOP.pdf - Sentence 1348
1349,Consequences Factory methods eliminate the need to bind application-specic classes into your code.,OOP.pdf - Sentence 1349
1350,The code only deals with the Product interface; therefore it can work with any user-dened Con- creteProduct classes.,OOP.pdf - Sentence 1350
1351,A potential disadvantage of factory methods is that clients might have to subclass the Creator class just to create a particular ConcreteProduct object.,OOP.pdf - Sentence 1351
1352,"Subclassing is ne when the client has to subclass the Creator class anyway, but otherwise the client now must deal with another point of evolution.",OOP.pdf - Sentence 1352
1353,Factory Method has the additional consequences: Provides hooks for subclasses.,OOP.pdf - Sentence 1353
1354,Connects parallel class hierarchies.,OOP.pdf - Sentence 1354
1355,"102.1.4 Prototype Specify the kinds of objects to create using a prototypical instance, and create new objects by copying this prototype.",OOP.pdf - Sentence 1355
1356,"Applicability Use the Prototype pattern when a system should be independent of how its products are created, composed, and represented when the classes to instantiate are specied at run-time, for example, by dynamic loading.",OOP.pdf - Sentence 1356
1357,to avoid building a class hierarchy of factories that parallels the class hierarchy of products.,OOP.pdf - Sentence 1357
1358,when instances of a class can have one of only a few dierent combinations of state.,OOP.pdf - Sentence 1358
1359,"Consequences Prototype has many of the same consequences that Abstract Factory and Builder have: It hides the concrete product classes from the client, thereby reducing the number of names clients know about.",OOP.pdf - Sentence 1359
1360,"Moreover, these patterns let a client work with application-specic classes without modication.",OOP.pdf - Sentence 1360
1361,Additional benets of the Prototype pattern include Adding and removing products at run-time.,OOP.pdf - Sentence 1361
1362,Specifying new objects by varying values Specifying new objects by varying structure.,OOP.pdf - Sentence 1362
1363,Reduced subclassing.,OOP.pdf - Sentence 1363
1364,Conguring an application with classes dynamically.,OOP.pdf - Sentence 1364
1365,"112.1.5 Singleton Ensure a class only has one instance, and provide a global point of access to it.",OOP.pdf - Sentence 1365
1366,"Applicability Use the Singleton pattern when there must be exactly one instance of a class, and it must be accessible to clients from a well-known access point.",OOP.pdf - Sentence 1366
1367,"when the sole instance should be extensible by subclassing, and clients should be able to use an extended instance without modifying their code.",OOP.pdf - Sentence 1367
1368,Consequences The Singleton pattern has several benets: Controlled access to sole instance.,OOP.pdf - Sentence 1368
1369,Reduced name space.,OOP.pdf - Sentence 1369
1370,Permits renement of operations and representation.,OOP.pdf - Sentence 1370
1371,Permits a variable number of instances.,OOP.pdf - Sentence 1371
1372,More exible than class operations.,OOP.pdf - Sentence 1372
1373,122.2 Structural Patterns 2.2.1 Adapter * Convert the interface of a class into another interface clients expect.,OOP.pdf - Sentence 1373
1374,Adapter lets classes work together that couldn't otherwise because of incompatible interfaces.,OOP.pdf - Sentence 1374
1375,"Applicability Use the Adapter pattern when you want to use an existing class, and its interface does not match the one you need.",OOP.pdf - Sentence 1375
1376,"you want to create a reusable class that cooperates with unrelated or unforeseen classes, that is, classes that don't necessarily have compatible interfaces.",OOP.pdf - Sentence 1376
1377,"(object adapter only) you need to use several existing subclasses, but it's unpractical to adapt their interface by subclassing every one.",OOP.pdf - Sentence 1377
1378,An object adapter can adapt the interface of its parent class Consequences Class and object adapters have dierent trade-os.,OOP.pdf - Sentence 1378
1379,A class adapter adapts Adaptee to Target by committing to a concrete Adaptee class.,OOP.pdf - Sentence 1379
1380,"lets Adapter override some ofAdaptee'sbehavior, since Adapter is a subclass of Adaptee.",OOP.pdf - Sentence 1380
1381,"introduces only one object, no additional pointer indirection is needed for the adaptee An object adapter lets a single Adapter work with many Adaptees makes it harder to override Adaptee behavior 132.2.2 Bridge Decouple an abstraction from its implementation so that the two can vary independently.",OOP.pdf - Sentence 1381
1382,Applicability Use the Bridge pattern when you want to avoid a permanent binding between an abstraction and its implementation.,OOP.pdf - Sentence 1382
1383,both the abstractions and their implementations should be extensible by subclassing.,OOP.pdf - Sentence 1383
1384,"changes in the implementation of an abstraction should have no impact on clients; that is, their code should not have to be recompiled.",OOP.pdf - Sentence 1384
1385,"you have a proliferation of hierarchical classes (\nested generalizations"") you want to share an implementation among multiple objects, and this fact should be hidden from the client.",OOP.pdf - Sentence 1385
1386,Consequences The Bridge pattern has the following consequences: Decoupling interface and implementation.,OOP.pdf - Sentence 1386
1387,Improved extensibility.,OOP.pdf - Sentence 1387
1388,Hiding implementation details from clients.,OOP.pdf - Sentence 1388
1389,142.2.3 Composite * Compose objects into tree structures to represent part-whole hierarchies.,OOP.pdf - Sentence 1389
1390,Composite lets clients treat individual objects and compositions of objects uniformly.,OOP.pdf - Sentence 1390
1391,Applicability Use the Composite pattern when you want to represent part-whole hierarchies of objects.,OOP.pdf - Sentence 1391
1392,you want clients to be able to ignore the dierence between compositions of objects and individual objects Consequences The Composite pattern denes class hierarchies consisting of primitive objects and composite objects makes the client simple.,OOP.pdf - Sentence 1392
1393,makes it easier to add new kinds of components.,OOP.pdf - Sentence 1393
1394,can make your design overly general.,OOP.pdf - Sentence 1394
1395,152.2.4 Decorator * Attach additional responsibilities to an object dynamically.,OOP.pdf - Sentence 1395
1396,Decorators provide a exible alter- native to subclassing for extending functionality.,OOP.pdf - Sentence 1396
1397,"Applicability Use Decorator to add responsibilities to individual objects dynamically and transparently, that is, with- out aecting other objects.",OOP.pdf - Sentence 1397
1398,for responsibilities that can be withdrawn.,OOP.pdf - Sentence 1398
1399,when extension by subclassing is impractical.,OOP.pdf - Sentence 1399
1400,Consequences The Decorator pattern has at least two key benets and two liabilities: More exibility than static inheritance.,OOP.pdf - Sentence 1400
1401,Avoids feature-laden classes high up in the hierarchy.,OOP.pdf - Sentence 1401
1402,A decorator and its component aren't identical.,OOP.pdf - Sentence 1402
1403,Lots of little objects.,OOP.pdf - Sentence 1403
1404,162.2.5 Facade Provide a unied interface to a set of interfaces in a subsystem.,OOP.pdf - Sentence 1404
1405,Facade denes a higher-level interface that makes the subsystem easier to use.,OOP.pdf - Sentence 1405
1406,Applicability Use the Facade pattern when you want to provide a simple interface to a complex subsystem there are many dependencies between clients and the implementation classes of an ab- straction you want to layer your subsystems.,OOP.pdf - Sentence 1406
1407,"Consequences The Facade pattern oers the following benets: It shields clients from subsystem components, thereby reducing the number of objects that clients deal with and making the subsystem easier to use.",OOP.pdf - Sentence 1407
1408,It promotes weak coupling between the subsystem and its clients.,OOP.pdf - Sentence 1408
1409,It doesn't prevent applications from using subsystem classes if they need to.,OOP.pdf - Sentence 1409
1410,Thus you can choose between ease of use and generality 172.2.6 Flyweight Use sharing to support large numbers of ne-grained objects eciently.,OOP.pdf - Sentence 1410
1411,Applicability The Flyweight pattern's eectiveness depends heavily on how and where it's used.,OOP.pdf - Sentence 1411
1412,Apply the Flyweight pattern when all of the following are true: An application uses a large number of objects Storage costs are high because of the sheer quantity of objects.,OOP.pdf - Sentence 1412
1413,Most object state can be made extrinsic.,OOP.pdf - Sentence 1413
1414,Many groups of objects may be replaced by relatively few shared objects once extrinsic state is removed.,OOP.pdf - Sentence 1414
1415,The application doesn't depend on object identity.,OOP.pdf - Sentence 1415
1416,"Since yweight objects may be shared, identity tests will return true for conceptually distinct objects.",OOP.pdf - Sentence 1416
1417,"Consequences Flyweights may introduce run-time costs associated with transferring, nding, and/or comput- ing extrinsic state.",OOP.pdf - Sentence 1417
1418,"However, such costs are oset by space savings, which increase as more yweights are shared.",OOP.pdf - Sentence 1418
1419,182.2.7 Proxy Provide a surrogate or placeholder for another object to control access to it.,OOP.pdf - Sentence 1419
1420,Applicability Proxy is applicable whenever there is a need for a more versatile or sophisticated reference to an object than a simple pointer.,OOP.pdf - Sentence 1420
1421,Here are several common situations in which the Proxy pattern is applicable: A remote proxy provides a local representative for an object in a dierent address space.,OOP.pdf - Sentence 1421
1422,A virtual proxy creates expensive objects on demand.,OOP.pdf - Sentence 1422
1423,A protection proxy controls access to the original object.,OOP.pdf - Sentence 1423
1424,Protection proxies are useful when objects should have dierent access rights.,OOP.pdf - Sentence 1424
1425,A smart reference is a replacement for a bare pointer that performs additional actions when an object is accessed.,OOP.pdf - Sentence 1425
1426,Consequences The Proxy pattern introduces a level of indirection when accessing an object.,OOP.pdf - Sentence 1426
1427,"The additional indirection has many uses, depending on the kind of proxy: A remote proxy can hide the fact that an object resides in a dierent address space.",OOP.pdf - Sentence 1427
1428,A virtual proxy can perform optimizations such as creating an object on demand.,OOP.pdf - Sentence 1428
1429,Both protection proxies and smart references allow additional housekeeping tasks when an object is accessed 192.3 Behavioural Patterns 2.3.1 Chain of Responsibility Avoid coupling the sender of a request to its receiver by giving more than one object a chance to handle the request.,OOP.pdf - Sentence 1429
1430,Chain the receiving objects and pass the request along the chain until an object handles it.,OOP.pdf - Sentence 1430
1431,"Applicability Use Chain of Responsibility when more than one object may handle a request, and the handler isn't known a priori.",OOP.pdf - Sentence 1431
1432,you want to issue a request to one ofseveral objects without specifying the receiver ex- plicitly.,OOP.pdf - Sentence 1432
1433,the set of objects that can handle a request should be specied dynamically.,OOP.pdf - Sentence 1433
1434,Consequences Chain of Responsibility has the following benets and liabilities: Reduced coupling.,OOP.pdf - Sentence 1434
1435,Added exibility in assigning responsibilities to objects Receipt isn't guaranteed.,OOP.pdf - Sentence 1435
1436,"202.3.2 Command Encapsulate a request as an object, thereby letting you parameterize clients with dierent requests, queue or log requests, and support undo-able operations.",OOP.pdf - Sentence 1436
1437,Applicability Use the Command pattern when you want to parameterize objects by an action to perform.,OOP.pdf - Sentence 1437
1438,"specify, queue, and execute requests at dierent times.",OOP.pdf - Sentence 1438
1439,support undo.,OOP.pdf - Sentence 1439
1440,support logging changes so that they can be reapplied in case of a system crash.,OOP.pdf - Sentence 1440
1441,structure a system around high-level operations built on primitives operations.,OOP.pdf - Sentence 1441
1442,Consequences The Command pattern has the following consequences: Command decouples the object that invokes the operation from the one that knows how to perform it.,OOP.pdf - Sentence 1442
1443,Commands are rst-class objects.,OOP.pdf - Sentence 1443
1444,They can be manipulated and extended like any other object.,OOP.pdf - Sentence 1444
1445,You can assemble commands into a composite command.,OOP.pdf - Sentence 1445
1446,"It's easy to add new Commands, because you don't have to change existing classes.",OOP.pdf - Sentence 1446
1447,"212.3.3 Interpreter Use the Interpreter pattern when there is a language to interpret, and you can represent state- ments in the language as abstract syntax trees.",OOP.pdf - Sentence 1447
1448,Applicability Use the Command pattern when you want to the grammar is simple.,OOP.pdf - Sentence 1448
1449,"For complex grammars, the class hierarchy for the grammar becomes large and unmanageable.",OOP.pdf - Sentence 1449
1450,eciency is not a critical concern.,OOP.pdf - Sentence 1450
1451,The most ecient interpreters are usually not im- plemented by interpreting parse trees directly but by rst translating them into another form.,OOP.pdf - Sentence 1451
1452,Consequences The Interpreter pattern has the following benets and liabilities: It's easy to change and extend the grammar Implementing the grammar is easy.,OOP.pdf - Sentence 1452
1453,Complex grammars are hard to maintain.,OOP.pdf - Sentence 1453
1454,Easier to add new ways to interpret expressions.,OOP.pdf - Sentence 1454
1455,222.3.4 Iterator Provide a way to access the elements of an aggregate object sequentially without exposing its underlying representation.,OOP.pdf - Sentence 1455
1456,Applicability Use the Iterator pattern to access an aggregate object's contents without exposing its internal representation (i.e.,OOP.pdf - Sentence 1456
1457,a list).,OOP.pdf - Sentence 1457
1458,to support multiple traversals of aggregate objects.,OOP.pdf - Sentence 1458
1459,"to provide a uniform interface for traversing dierent aggregate structures (that is, to support polymorphic iteration) Consequences The Iterator pattern has three important consequences: It supports variations in the traversal of an aggregate Iterators simplify the Aggregate interface.",OOP.pdf - Sentence 1459
1460,More than one traversal can be pending on an aggregate.,OOP.pdf - Sentence 1460
1461,232.3.5 Mediator Dene an object that encapsulates how a set of objects interact.,OOP.pdf - Sentence 1461
1462,"Mediator promotes loose coupling by keeping objects from referring to each other explicitly, and it lets you vary their interaction independently.",OOP.pdf - Sentence 1462
1463,Applicability Use the Mediator pattern when a set of objects communicate in well-dened but complex ways.The resulting interdepen- dencies are unstructured and dicult to understand.,OOP.pdf - Sentence 1463
1464,reusing an object is dicult because it refers to and communicates with many other objects.,OOP.pdf - Sentence 1464
1465,a behavior that's distributed between several classes should be customizable without a lot of subclassing Consequences The Mediator pattern has the following benets and drawbacks: It limits subclassing.,OOP.pdf - Sentence 1465
1466,It decouples colleagues.,OOP.pdf - Sentence 1466
1467,It simplies object protocols.,OOP.pdf - Sentence 1467
1468,It abstracts how objects cooperate.,OOP.pdf - Sentence 1468
1469,It centralizes control.,OOP.pdf - Sentence 1469
1470,"242.3.6 Memento Without violating encapsulation, capture and externalize an object's internal state so that the object can be restored to this state later.",OOP.pdf - Sentence 1470
1471,Applicability Use the Memento pattern when a snapshot of (some portion of) an object's state must be saved so that it can be restored to that state later.,OOP.pdf - Sentence 1471
1472,a direct interface to obtaining the state would expose implementation details and break the object's encapsulation.,OOP.pdf - Sentence 1472
1473,Consequences The Memento pattern has several consequences: Preserving encapsulation boundaries.,OOP.pdf - Sentence 1473
1474,It simplies Originator.,OOP.pdf - Sentence 1474
1475,Using mementos might be expensive.,OOP.pdf - Sentence 1475
1476,Dening narrow and wide interfaces.,OOP.pdf - Sentence 1476
1477,Hidden costs in caring for mementos.,OOP.pdf - Sentence 1477
1478,"252.3.7 Observer * Dene a one-to-many dependency between objects so that when one object changes state, all its dependents are notied and updated automatically.",OOP.pdf - Sentence 1478
1479,"Applicability Use the Observer pattern in any of the following situations: When an abstraction has two aspects, one dependent on the other.",OOP.pdf - Sentence 1479
1480,Encapsulating these aspects in separate objects lets you vary and reuse them independently.,OOP.pdf - Sentence 1480
1481,"When a change to one object requires changing others, and you don't know how many objects need to be changed.",OOP.pdf - Sentence 1481
1482,"When an object should be able to notify other objects without making assumptions about who these objects are.In other words, you don't want these objects tightly coupled.",OOP.pdf - Sentence 1482
1483,Consequences The Observer pattern lets you vary subjects and observers independently.,OOP.pdf - Sentence 1483
1484,Further benets and liabilities of the Observer pattern include the following: Abstract coupling between Subject and Observer.,OOP.pdf - Sentence 1484
1485,Support for broadcast communication.,OOP.pdf - Sentence 1485
1486,Unexpected updates.,OOP.pdf - Sentence 1486
1487,262.3.8 State Allow an object to alter its behavior when its internal state changes.,OOP.pdf - Sentence 1487
1488,The object will appear to change its class.,OOP.pdf - Sentence 1488
1489,"Applicability Use the State pattern in either of the following cases: An object's behavior depends on its state, and it must change its behavior at run-time depending on that state.",OOP.pdf - Sentence 1489
1490,"Operations have large, multipart conditional statements that depend on the object's state.",OOP.pdf - Sentence 1490
1491,Consequences The State pattern has the following consequences: It localizes state-specic behavior and partitions behavior for dierent states.,OOP.pdf - Sentence 1491
1492,It makes state transitions explicit.,OOP.pdf - Sentence 1492
1493,State objects can be shared.,OOP.pdf - Sentence 1493
1494,"272.3.9 Strategy * Dene a family of algorithms, encapsulate each one, and make them interchangeable.",OOP.pdf - Sentence 1494
1495,Strategy lets the algorithm vary independently from clients that use it.,OOP.pdf - Sentence 1495
1496,Applicability Use the Strategy pattern when many related classes dier only in their behavior.,OOP.pdf - Sentence 1496
1497,Strategies provide a way to congure a class with one of many behaviors.,OOP.pdf - Sentence 1497
1498,you need dierent variants of an algorithm.,OOP.pdf - Sentence 1498
1499,an algorithm uses data that clients shouldn't know about.,OOP.pdf - Sentence 1499
1500,"a class denes many behaviors, and these appear as multiple conditional statements in its operations.",OOP.pdf - Sentence 1500
1501,Consequences The Strategy pattern has the following benets and drawbacks: Families of related algorithms.,OOP.pdf - Sentence 1501
1502,An alternative to subclassing.,OOP.pdf - Sentence 1502
1503,Strategies eliminate conditional statements.,OOP.pdf - Sentence 1503
1504,A choice of implementations.,OOP.pdf - Sentence 1504
1505,Clients must be aware of dierent Strategies.,OOP.pdf - Sentence 1505
1506,Communication overhead between Strategy and Context.,OOP.pdf - Sentence 1506
1507,Increased number of objects.,OOP.pdf - Sentence 1507
1508,"282.3.10 Template Method * Dene the skeleton of an algorithm in an operation, deferring some steps to subclasses.",OOP.pdf - Sentence 1508
1509,Tem- plate Method lets subclasses redene certain steps of an algorithm without changing the algo- rithm's structure.,OOP.pdf - Sentence 1509
1510,Applicability The Template Method pattern should be used to implement the invariant parts of an algorithm once and leave it up to subclasses to implement the behavior that can vary.,OOP.pdf - Sentence 1510
1511,when common behavior among subclasses should be factored and localized in a common class to avoid code duplication.,OOP.pdf - Sentence 1511
1512,to control subclasses extensions.,OOP.pdf - Sentence 1512
1513,Consequences Template methods are a fundamental technique for code reuse.,OOP.pdf - Sentence 1513
1514,Template methods lead to an inverted control structure.,OOP.pdf - Sentence 1514
1515,This refers to how a parent class calls the operations of a subclass and not the other way around.,OOP.pdf - Sentence 1515
1516,"Template methods call the following kinds of operations: concrete operations (either on the ConcreteClass or on client classes) concrete AbstractClass operations (i.e., operations that are generally useful to subclasses) primitive operations (i.e., abstract operations) factory methods hook operations, which provide default behavior that subclasses can extend if necessary.",OOP.pdf - Sentence 1516
1517,A hook operation often does nothing by default.,OOP.pdf - Sentence 1517
1518,292.3.11 Visitor Represent an operation to be performed on the elements of an object structure.,OOP.pdf - Sentence 1518
1519,Visitor lets you dene a new operation without changing the classes of the elements on which it operates.,OOP.pdf - Sentence 1519
1520,"Applicability Use the Visitor pattern when an object structure contains many classes of objects with diering interfaces, and you want to perform operations on these objects that depend on their concrete classes.",OOP.pdf - Sentence 1520
1521,"many distinct and unrelated operations need to be performed on objects in an object structure, and you want to avoid \polluting"" their classes with these operations.",OOP.pdf - Sentence 1521
1522,"the classes dening the object structure rarely change, but you often want to dene new operations over the structure.",OOP.pdf - Sentence 1522
1523,Consequences Some of the benets and liabilities of the Visitor pattern are as follows: Visitor makes adding new operations easy.,OOP.pdf - Sentence 1523
1524,A visitor gathers related operations and separates unrelated ones.,OOP.pdf - Sentence 1524
1525,Adding new ConcreteElement classes is hard.,OOP.pdf - Sentence 1525
1526,Visiting across class hierarchies.,OOP.pdf - Sentence 1526
1527,"30References [1] Gamma, E., Helm, R., Johnson, R., Vlissides, J.",OOP.pdf - Sentence 1527
1528,M.,OOP.pdf - Sentence 1528
1529,(1994).,OOP.pdf - Sentence 1529
1530,Design Patterns: Elements of Reusable Object-Oriented Software.,OOP.pdf - Sentence 1530
1531,Addison-Wesley Professional.,OOP.pdf - Sentence 1531
1532,ISBN: 0201633612 31,OOP.pdf - Sentence 1532
